// HTMLParser_HTMLParser_Master_Branch_master_V1.0.0.9
{"version":3,"sources":["HTMLParser.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","Object","defineProperty","value","HIGHLIGHT_TAG","WRAPPER_TAG","THDomRange_ERROR","THDomRange_TARGET_SAME","THDomRange_AFTER_TARGET","THDomRange_BEFORE_TARGET","THDomRange_TARGET_INSIDE","THDomRange_TARGET_INCLUDES_THIS","THDomRange_OVERLAPS_END_OF_TARGET","THDomRange_OVERLAPS_START_OF_TARGET","THDomRange_TARGET_INCLUDES_THIS_AT_START","THDomRange_TARGET_INCLUDES_THIS_AT_END","SPEECH_RANGE_COLOUR","SPEECH_WORD_COLOUR","2","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","Attribute","this","p_node","p_strName","nodeType","attr","indexOf","getAttribute","p_strVal","setAttribute","removeAttribute","3","_interopRequireWildcard","obj","__esModule","newObj","hasOwnProperty","DomNavigation","undefined","_Utilities","_SSDOM","_Attribute","_MathSpeak","_Constants","Constants","p_endNode","nextSibling","rightNode","parentNode","firstChild","p_theBody","p_strPath","attribute","theNode","lastIndexOf","nPos","substring","aStr","split","nLen","nVal","parseInt","bIsText","bWasLastText","tagName","toLowerCase","rw_getAttribute","ssdom","SSDOM","txt","isInvalidNode","isIgnored","nodeValue","strTagName","tmpAttr","trimTH","innerHTML","isMathJax","mathSpeak","MathSpeak","getTextFromMathJax","utils","Utilities","trim","getTextFromMathMl","p_bGoByStyle","getNextNodeImpl","p_bAllowImg","lastChild","isSpecialCaseWithIgnoredContent","tmpNode","bIgnored","prevNode","getPreviousTextNode","getPreviousTextNodeNoImg","p_bIncludeBlanks","leftNode","getPreviousTextNodeNoBlank","strToCheck","rw_isWordSpeakable","bMatch","getPreviousNode","previousSibling","isStyleNode","getNextTextNode","getNextTextNodeNoImg","getNextTextNodeNoBlank","spanEl","createWrapperElement","replaceChild","appendChild","g_bIE","strML","outerHTML","replace","getNextNode","p_bDeferEndNodeCheck","p_bAlwaysIgnoreChild","bInvalid","checkIfElementInsideElement","src/Constants/Constants","src/SpeechStream/DOM/Attribute","src/SpeechStream/DOM/SSDOM","src/SpeechStream/MathJax/MathSpeak","src/SpeechStream/THCaret","src/SpeechStream/THCaretRange","src/SpeechStream/Utilities/Utilities","4","DomSentences","_DomNavigation","_THCaret","_THCaretRange","p_thCaret","rightCaret","getSentenceBreakToRight","leftCaret","getSentenceBreakToLeft","range","THCaretRange","setCaretRange","p_caretRange","domNav","curNode","node","curOffset","offset","rw_checkForHiddenParent","isSpecialCase","getNextNodeIgnoreChildren","THCaret","tmpText","thCaretRange","checkSentence","rw_caretRangeIsSpeakable","tmpTxt","nLastPos","RWTH_COMPONENT","startNode","bod","ownerDocument","body","className","endNode","nOffset","forwardBias","aChar","charAt","matchedNode","matchedOffset","leftOffset","bFound","lastChar","isSpecialCaseNested","checkForSpecialParent","rw_isFullStop","rw_isTextChar","rw_isWhiteSpace","rightOffset","testChar","utilities","src/SpeechStream/DOM/DomNavigation","5","_typeof","Symbol","iterator","constructor","_THRange","_THDomRefPt","_DomSentences","getBody","document","math","p_innerElement","p_containingElement","tmp","p_strWord","tmpWord","tmpC","charCodeAt","createObject","g_bOverrideSpan","p_attrList","p_strId","p_strClass","createObjectForDoc","p_doc","theObj","createElement","id","strName","strAttr","isInStyleList","strStyleList","compStyle","getComputedStyle","visibility","display","p_elem","window","bDefault","strIgnoreAttr","strAllowAttr","aNode","aChild","allTextFromNodeTH","parNode","doc","txtNode","createTextNode","removeChild","bChanged","nRightOffset","nLeftOffset","tmpChar","rightText","leftText","err","console","log","p_char","search","domSent","caretRange","p_nCode","p_txt","p_nPos","bFS","nextChar","str2","str3","str4","eba_abbr_array","strAbbr","nItems","p_thCaretRange","bInitialLoop","bSpecial","getTextFromNode","getNextNodeAllowMoveToChild","computedStyle","p_nOffset","RWTH_GENERATED","tmpPar","THDomRefPt","getPositionInDom","theParent","rw_getNodeOffset","thgenAttr","ignore","rw_getNodeOffsetImpl","p_theNode","strPos","nLeftCount","prefix","ttmp","innerPos","String","fromCharCode","p_body","p_refPt","getCaretFromDomPosition","path","p_bForwardBias","p_bForceSpecial","getNodeFromPosition","tmpCaret","setSpecialCase","isSpecialCaseHighlightable","getFirstChildTextNode","getLastChildTextNode","lastSafeNode","nDiff","p_startNode","resultList","getActualNextNodeIgnoreChildren","push","getActualNextNode","top","frames","curBody","activeBody","tmpBod","p_textRange","tmpRange","duplicate","collapse","startRefPt","rw_getTextRangeAsRefPtIE","endRefPt","THRange","p_strLeftPath","p_nLeftOffset","p_strRightPath","p_nRightOffset","getRangeObject","lNode","rNode","moveToElementText","rw_moveEnd","select","range2","setEndPoint","sel","getSelectionObject","collapseToStart","execCommand","theRange","g_ipadSelectionRange","getSelection","tmpSel","foundSel","isCollapsed","getFrameSelectionSFF","selection","createRange","text","theWindow","getFrameSelectionOldIE","p_frame","res","g_bIgnoreFrames","tmpFrame","tmpRes","getFrameSelection","tmpObj","src/SpeechStream/DOM/DomSentences","src/SpeechStream/THDomRefPt","src/SpeechStream/THRange","6","EventBus","events","Array","event","callback","splice","data","7","HighlightBaseController","_THReturnObject","p_textNode","p_nStartPt","p_nEndPt","p_state","p_strCol","THReturnObject","rw_setNodeBackgroundImpl","startTextNode","endTextNode","rw_setSpeechRangeImpl","parentState","p_parentNode","bSpeech","strCol","rw_highlightMathElement","bAll","tmpEl","rw_setAttribute","strClass","txtLeft","txtMid","txtRight","txtNodeLeft","txtNodeRight","insertBefore","p_mathNode","p_rwstate","p_strStyle","p_bStarted","strTag","bIE","style","grandparNode","elFont","rw_removeAttribute","p_startCaret","p_endCaret","arr","src/SpeechStream/THReturnObject","8","MathJaxHighlightController","_MathJaxHighlighter","sentence","m_setupHash","m_defaultContextBg","g","b","m_defaultContextFg","m_defaultWordBg","m_defaultWordFg","m_contextBg","m_contextFg","m_wordBg","m_wordFg","m_strContextStyle","m_strWordStyle","lastMathId","p_id","elem","getElementById","jax","getJaxFor","h","MathJaxHighlighter","setHighlightStyle","getSpanId","clearHighlights","highlight","jaxSpanid","root","spanID","CHTMLnodeID","PHTMLspanID","highlightNodes","wordNo","p_spanId","getWordRange","p_strType","p_rgbFg","p_rgbBg","p_rgb","g_bIE11","MathJax","Hub","jaxID","tmpStr","substr","tmpElem","p_strMathMl","nPos2","strTmp","src/SpeechStream/MathJax/MathJaxHighlighter","9","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","SpeechHighlightController","_ScrollInToView","_HighlightBaseController","_HighlightBaseControl","_this","getPrototypeOf","getRange","startRef","endRef","rw_removeSpeechHighlight","getListOfHighlightableNodes","getWords","thRange","scrollInToView","ScrollInToView","result","rw_scrollToObject","p_arr","p_bWord","rw_checkNodeIsSpeechText","higherParentNode","mergeTextNodes","parent","p_startOffset","p_endOffset","p_strState","rw_setNodeBackground","src/SpeechStream/Highlighting/HighlightBaseController","src/SpeechStream/ScrollInToView","src/SpeechStream/Sentence/SentenceObject","src/SpeechStream/SpeechObject","10","SpeechHighlightManager","_SpeechHighlightController","_MathJaxHighlightController","isMathML","highlightController","highlightRange","unHighlightRange","highlightWord","src/SpeechStream/Highlighting/MathJaxHighlightController","src/SpeechStream/Highlighting/SpeechHighlightController","11","StudySkillsHighlighting","_THDomRange","g_aTextRange","g_aHighlightColour","g_bIEOld","wordList","tmpArr","strWord","slice","pop","toString","m_bSentenceSelection","sort","sortBy","sortBySFF","nTmpLen","_loop","escapeRegex","string","j","characters","flags","RegExp","p_strColour","strFull","strForColour","nCount","iSegIndex","collection","tmpTextRange","tmpTHRange","rw_getTextRangeAsTHRange","parentElement","rw_getTHCaretRangeFromTHRange","rw_getTHCaretRangeFromTHDomRange","getTextOverCaretRange","rw_filterForHtml","color","colors","colorTextArray","compareEndPoints","exc","equals","refresh","aEnd","getEndAsRange","bEnd","compareBoundaryPoints","selObj","selectionRange","startCaret","endCaret","thDomRange","THDomRange","rw_checkTHRangeForValidHighlight","rw_getAsTextRange","rw_collapseSelection","studySkillsHTMLHighlightRangeImpl","reporter","SpeechStream","analytics","report","categories","HIGHLIGHT","p_range","bDisplayIssueMatch","storedDisplayValue","strSelectText","blnAddNewRange","nInfiniteCount","bChangeMade","rw_getTextFromRange","theStyle","studySkillsHTMLRefreshRanges","iRangeIndex","storedRange","dupCurrentTextRange","bStart","inRange","case1IE","case2IE","case3IE","tmpDomRange","nResult","compareRange","status","rw_removeHighlight","case1SFF","case2SFF","case3SFF","g_bIENew","studySkillsClearRangeIE","rw_ieSpecificCallToSetHighlight","rw_setHighlight","resStart","resEnd","start","end","g_nIcons","strike_icon","rw_checkNodeIsHighlightedText","tmpFont","rw_getNestedNodeForHighlightedText","bFail","p_bForceClear","selWindow","frame","g_lastInputSelectSFF","selectionStart","selectionEnd","agree","compatMode","equalsTH","nLenFrames","expand","dupRange","storedRangePost","moveStart","storedRangePre","moveEnd","itemsToRemove","tempTextRange","blnItemRemoved","exe","p_selectionRange","p_thDomRangeType","strOrigColour","origDomRange","startLeftRefPt","endLeftRefPt","startRightRefPt","endRightRefPt","src/SpeechStream/THDomRange","12","ElementHelper","_LoopState","dataElem","spanId","state","pushToList","count","found","looper","LoopState","getList","src/SpeechStream/MathJax/LoopState","13","HighlightData","fg","bg","lastSpanId","14","list","15","_HighlightData","_ElementHelper","highlightDataStore","highlightJaxRoot","highlightClearLast","elementHelper","type","tmpData","clearHighlightNodesImpl","nR","nG","nB","parseColor","highlightImpl","val","tmpVal","item","mathoutline","previousline","removeFromPrevious","len","mathunderline","previouscolor","mathcolor","mathbackground","spanElem","HTMLspanElement","CHTMLnodeElement","bSuccess","HTMLremoveColor","setupPostFix","HTMLhandleColor","PHTMLhandleColor","setdownPostFix","sp","background","colorHandle","CHTMLhandleColor","textDecoration","p_span","p_bAdding","HTMLCSS","OutputJax","strTypeAsAdded","strSpanID","idPostfix","m_strTmpPostFix","src/SpeechStream/MathJax/ElementHelper","src/SpeechStream/MathJax/HighlightData","16","sre","System","getInstance","setupEngine","semantics","domain","strMathCode","mml","toMathML","elementID","element","mathJaxText","getMathMLText","mathJaxObject","getMathMLObject","processExpression","getMathMLWithBookmarks","originalText","oParser","DOMParser","oDOM","parseFromString","documentElement","nodeName","error","mathsObject","mathsText","includeBookmarks","span","repl","17","Prediction","curser","properties","controlEdit","currentChar","getCurrentCharacter","setSelectionRange","word","modify","selectedRange","getRangeAt","removeAllRanges","addRange","left","fontSize","getPropertyValue","coordinates","getCaretCoordinates","x","y","GetOffset","scrollTop","scrollLeft","object","offsetLeft","offsetTop","offsetParent","position","mirrorDiv","computed","whiteSpace","wordWrap","borderTopWidth","forEach","prop","overflow","textContent","backgroundColor","input","focus","createTextRange","caretPos","move","newText","el","rwPredictionPositionElement","setCaretPositionDiv","currentContextControlID","replaceSelectedText","CurrentPosition","setCaretPosition","replacementText","moveCount","activeElement","navigator","appVersion","regex","match","rangeCount","deleteContents","insertNode","deleteFromDocument","selectedText","textComponent","startPos","endPos","18","_EventBus","$g_bMouseSpeech","getWindow","divOffsetObj","parentTest","tmpBody","bScrolledDiv","storedMatchObj","rw_isDivScrollable","rw_scrollToObjectDivCheck","screenLeft","screenTop","screenWidth","screenHeight","nWidthOffset","rw_getScreenOffsetLeft","rw_getScreenOffsetTop","innerWidth","innerHeight","clientHeight","clientWidth","bNeedX","bNeedY","publish","scrollTo","g_bTouchScreen","rw_positionToolbar","rw_positionAllDivBars","p_window","pageXOffset","pageYOffset","scrollX","p_div","p_prevDivOffsetObj","nDivOffsetX","nDivOffsetY","nObjHeight","nObjWidth","clientRectWidth","getBoundingClientRect","right","nTmpOffsetTop","nTmpOffsetLeft","rw_safeOffsetParent","offsetHeight","offsetWidth","p_obj","startObj","endObj","bScrollable","scrollHeight","overflowY","scrollWidth","overflowX","src/SpeechStream/Events/EventBus","19","BaseSelection","clearBrowserSelection","empty","20","HoverSpeak","_BaseSelection2","_SpeechObject","_BaseSelection","timerEvent","subscribe","clearTimer","bind","readRange","_this2","clearTimeout","setTimeout","startSpeech","caretRangeFromPoint","docRange","clientX","clientY","startContainer","startOffset","endContainer","endOffset","caretPositionFromPoint","offsetNode","localSpeechObject","SpeechObject","processRange","newSentence","getFirstSentence","oldSentText","newSentText","getRawText","src/SpeechStream/Selection/BaseSelection","21","SelectionController","getSelection_","g_ipadSelectionWindow","focusNode","anchorNode","anchorOffset","focusOffset","mozRange","getRangeFromSelectionPoint","setStart","setEnd","startCon","startOff","endCon","endOff","hasChildNodes","childNodes","tmpBlock","22","BaseObject","p_type","m_range","m_type","m_bValid","m_contents","Types","WORD","SENTENCE","SSML","DOCUMENT","SILENCE","p_bValid","p_contents","isOverridingText","getWordCount","words","concat","caret","rw_getCaretFromRefPt","23","MathWordObject","_BaseObject2","_BaseObject","m_strWord","m_strPronunciation","src/SpeechStream/Sentence/BaseObject","24","SentenceObject","_TextOverRangeBeanClass","_WordObject","_MathWordObject","m_caretRange","m_strRawText","getSpeechWithBookmarksFromElement","splitMathIntoWords","sentenceSpanId","m_strMarkedText","p_strVoice","m_strVoice","rw_getTHRangeFromTHCaretRange","WordObject","setContents","wordsArray","getContents","getWord","p_strRawText","p_strMarkedText","setValid","isValid","setVoice","setRawText","setMarkedText","bookmarks","addContent","processTextToSpeakInSentenceObjectImpl","elems","elemNode","getFirstNode","isNestedSsml","insertInWrappingSsml","checkForSsmlAttribute","p_elems","wrapElement","canContainContent","tmpToBeContained","tmpFollowing","tmpFollowingNode","stateData","TextOverRangeBeanClass","setupCheck","rw_getRefPt","currentNode","checkIfTooLong","handleSpecialCase","handleElement","handleTextNode","moveToNextNode","p_data","curTxt","storedText","rw_getBreakInCurrentWord","strWordToAdd","filterWordToSpeak","moveStoredTextToWordObject","p_strText","ssmlElem","tmpNote","getTextOverRangeToSpeakAddFullStop","p_storedText","tmpLen","trimEndTH","c","rw_isLetter","firstNode","lastNode","sentenceObject","clearState","MAX_WORDCOUNT_TO_SPEAK","p_curNode","checkForSsmlNoNamespace","checkForSsmlNamespace","g_bUseCommands","sentences","getSentences","getCaretRange","startElement","rw_findCommandNode","newRightCommandCaret","rw_checkForCommandChange","clone","followingSentence","newRange","followingLeftCaret","moveCaret","followingRange","setSentences","src/SpeechStream/Sentence/MathWordObject","src/SpeechStream/Sentence/WordObject","src/SpeechStream/TextOverRangeBeanClass","25","setRange","p_strPron","str","26","_toConsumableArray","isArray","arr2","from","_SentenceObject","m_bBatch","SSML_NAMESPACE","SSMS_TYPES","SUB","PHONEME","SAYAS","EMPHASIS","BREAK","PROSODY","SSMS_ATTRIBUTES","ALPHABET","PH","ALIAS","INTERPRETAS","FORMAT","LEVEL","STRENGTH","TIME","PITCH","RATE","VOLUME","sentenceNo","p_bBatch","continousReading","getNextSentence","last","getSentenceFromPoint","next","processSentence","apply","hoverSpeak","sent","setWords","_sentences","hasMoreSentences","nextSentence","_sentences2","checkRange","currentSentence","splitSentenceByLanguage","processTextToSpeakInSentenceObject","_splitSentenceByLanguage","_x","arguments","p_currentSentence","bInTranslatePopup","strVoice","rw_getVoiceSetForNode","newRightCaret","rw_checkForVoiceChange","secondSentenceCaret","leftNewCaretRange","rightNewCaretRange","secondSentence","27","specialCase","p_bSpecialCase","bValid","p_caret","28","p_strPathLeft","p_nPosLeft","p_strPathRight","p_nPosRight","getCaretPairFromDomPosition","strResult","elemList","getNodesOverRange","29","p_nStartOffset","p_nEndOffset","getNodeOffset_","check","getTextSpokenOverCaretRange","p_target","selectedStart","getStartAsRange","selectedEnd","targetStart","targetEnd","nStartDiff1","nStartDiff2","nEndDiff1","nEndDiff2","30","getOffset","31","p_startRefPt","p_endRefPt","getAsRange","32","33","p_sentenceObject","34","strOut","35","ParserAPI","_SelectionController","_SpeechHighlightManager","_HoverSpeak","_StudySkillsHighlighting","_Prediction","loadLoadFiles","url","selectionController","speechHighlightManager","speechObject","studySkills","hoverSpeakOn","mathLoaded","Ajax","Load","load_script","predictionOn","prediction","pauseHover","isHoverSpeakEnabled","addEventListener","iframeCallback","speechCallback","mouseMoved","pauseHoverTimer","unPauseHover","clearHoverSpeak","source","new_script","src","getElementsByTagName","enabled","getPositionOfPopup","getSentence","insertText","isEditable","hasSelection","getSelectionRange","clearSelection_","getCurrentSentence","colour","selectionObject","studySkillsHTMLHighlightRange","studySkillsClearHighlights","highlights","studySkillsCollateForColour","fileName","fetchWords","setEditControl","textHelp","parsers","HTMLParserAPI","src/SpeechStream/Highlighting/SpeechHighlightManager","src/SpeechStream/Highlighting/StudySkillsHighlighting","src/SpeechStream/Prediction/Prediction","src/SpeechStream/Selection/HoverSpeak","src/SpeechStream/Selection/SelectionController","36","src/api/ParserAPI"],"mappings":"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","file":"HTMLParser.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Created by kevinml on 03/06/2016.\n */\n\nvar HIGHLIGHT_TAG = exports.HIGHLIGHT_TAG = \"texthelp-highlight-span\";\nvar WRAPPER_TAG = exports.WRAPPER_TAG = \"texthelp-wrapper-span\";\nvar THDomRange_ERROR = exports.THDomRange_ERROR = -1;\nvar THDomRange_TARGET_SAME = exports.THDomRange_TARGET_SAME = 0;\nvar THDomRange_AFTER_TARGET = exports.THDomRange_AFTER_TARGET = 1;\nvar THDomRange_BEFORE_TARGET = exports.THDomRange_BEFORE_TARGET = 2;\nvar THDomRange_TARGET_INSIDE = exports.THDomRange_TARGET_INSIDE = 3;\nvar THDomRange_TARGET_INCLUDES_THIS = exports.THDomRange_TARGET_INCLUDES_THIS = 4;\nvar THDomRange_OVERLAPS_END_OF_TARGET = exports.THDomRange_OVERLAPS_END_OF_TARGET = 5;\nvar THDomRange_OVERLAPS_START_OF_TARGET = exports.THDomRange_OVERLAPS_START_OF_TARGET = 6;\nvar THDomRange_TARGET_INCLUDES_THIS_AT_START = exports.THDomRange_TARGET_INCLUDES_THIS_AT_START = 7;\nvar THDomRange_TARGET_INCLUDES_THIS_AT_END = exports.THDomRange_TARGET_INCLUDES_THIS_AT_END = 8;\n\nvar SPEECH_RANGE_COLOUR = exports.SPEECH_RANGE_COLOUR = \"colour:#rrggbb; background:#FFFF00\";\nvar SPEECH_WORD_COLOUR = exports.SPEECH_WORD_COLOUR = \"color:#FFFFFF; background:#0000FF; padding: 2px; margin: -2px; border-radius: 4px; text-shadow: 0 3px 8px #2A2A2A\";\n\n},{}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevinml on 03/05/2016.\n */\n\nvar Attribute = exports.Attribute = function () {\n    function Attribute() {\n        _classCallCheck(this, Attribute);\n    }\n\n    // attribute support for html5\n    /**\n     * This gets attribute for custom types.  Custom types in html5 are to have data- in front of them.\n     * This assumes that call is made without the data- prefex.\n     *\n     * If it does not have a data- prefix it will check with that added, then if no match check without the prefix.\n     *\n     * If it does have the data- prefix, will just check that.\n     *\n     * Returns null if not found\n     *\n     * @param p_node\n     * @param p_strName\n     */\n\n\n    _createClass(Attribute, [{\n        key: \"rw_getAttribute\",\n        value: function rw_getAttribute(p_node, p_strName) {\n            if (p_node != null && p_node.nodeType == 1 && typeof p_strName == \"string\") {\n                var attr = null;\n                if (p_strName.indexOf(\"data-texthelp-\") != 0) {\n                    // Not called with data- try first with data-\n                    attr = p_node.getAttribute(\"data-texthelp-\" + p_strName);\n                }\n\n                if (attr == null && p_strName.indexOf(\"data-\") != 0) {\n                    // Not called with data- try first with data-\n                    attr = p_node.getAttribute(\"data-\" + p_strName);\n                }\n\n                if (attr == null) {\n                    attr = p_node.getAttribute(p_strName);\n                }\n                return attr;\n            }\n            return null;\n        }\n\n        /**\n         * This sets attribute for custom types.  Custom types in html5 are to have data- in front of them.\n         * This will add a data- to the front if not there.\n         * @param p_node\n         * @param p_strName\n         * @param p_strVal\n         */\n\n    }, {\n        key: \"rw_setAttribute\",\n        value: function rw_setAttribute(p_node, p_strName, p_strVal) {\n            if (p_node != null && p_node.nodeType == 1 && typeof p_strName == \"string\" && typeof p_strVal == \"string\") {\n                if (p_strName == \"style\" && false /*SSHL.dat.browser.bIEOld*/) {\n                        //workaround for IE bug of setAttribute not working for style\n                        p_node.style.setAttribute(\"cssText\", p_strVal, 0); // third parameter is for case sensitive or not (0 for not)\n                        return;\n                    }\n\n                if (p_strName.indexOf(\"data-\") != 0 && p_strName != \"style\") {\n                    p_strName = \"data-\" + p_strName;\n                }\n\n                p_node.setAttribute(p_strName, p_strVal);\n            }\n        }\n\n        /**\n         * This removes attribute for custom types.  Custom types in html5 are to have data- in front of them.\n         * This will add a data- to the front if not there to check that first.\n         * @param p_node\n         * @param p_strName\n         */\n\n    }, {\n        key: \"rw_removeAttribute\",\n        value: function rw_removeAttribute(p_node, p_strName) {\n            if (p_node != null && p_node.nodeType == 1 && typeof p_strName == \"string\") {\n                if (p_strName.indexOf(\"data-\") != 0) {\n                    // doesn't start with \"data-\"\n                    if (p_node.getAttribute(\"data-\" + p_strName) != null) {\n                        p_node.removeAttribute(\"data-\" + p_strName);\n                        return;\n                    }\n                }\n\n                if (p_node.getAttribute(p_strName) != null) {\n                    p_node.removeAttribute(p_strName);\n                }\n            }\n        }\n    }]);\n\n    return Attribute;\n}();\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DomNavigation = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevinml on 03/05/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nvar _MathSpeak = require('src/SpeechStream/MathJax/MathSpeak');\n\nvar _THCaret = require('src/SpeechStream/THCaret');\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nvar _Constants = require('src/Constants/Constants');\n\nvar Constants = _interopRequireWildcard(_Constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DomNavigation = exports.DomNavigation = function () {\n    function DomNavigation() {\n        _classCallCheck(this, DomNavigation);\n    }\n\n    /**\n     * This will get actual next node, looking in order next/next of parent\n     * @param p_node\n     * @param p_endNode\n     * @returns {*}  null of error or no next\n     */\n\n\n    _createClass(DomNavigation, [{\n        key: 'getActualNextNodeIgnoreChildren',\n        value: function getActualNextNodeIgnoreChildren(p_node, p_endNode) {\n            if (p_node == null || p_node == p_endNode) {\n                return null;\n            }\n\n            if (p_node.nextSibling != null) {\n                return p_node.nextSibling;\n            } else //up to right\n                {\n                    var rightNode = p_node;\n                    while (rightNode != null) {\n                        rightNode = rightNode.parentNode;\n                        if (p_endNode == rightNode) {\n                            // don't go past end\n                            return null;\n                        }\n                        if (rightNode.nextSibling != null) {\n                            // doesn't matter if this is end or not, allowed to move to end, just not past it.\n                            return rightNode.nextSibling;\n                        }\n                    }\n\n                    return null;\n                }\n        }\n    }, {\n        key: 'getActualNextNode',\n\n\n        /**\n         * This will get actual next node, looking in order child/next/next of parent.\n         * This can move to the end node but not past it.\n         * Going past means going to next sibling from an end node, or up tree to right by moving from or over end node.\n         * As inclusive will include contents of the children of the end node.  (So goes up to the end of the end node.)\n         *\n         * @param p_node\n         * @param p_endNode\n         * @returns {*}  null of error or no next\n         */\n        value: function getActualNextNode(p_node, p_endNode) {\n            if (p_node == null) {\n                return null;\n            }\n\n            if (p_node.firstChild != null) {\n                return p_node.firstChild;\n            }\n\n            if (p_node == p_endNode) {\n                // don't go past end\n                return null;\n            }\n\n            if (p_node.nextSibling != null) {\n                return p_node.nextSibling;\n            } else //up to right\n                {\n                    var rightNode = p_node;\n                    while (rightNode != null) {\n                        rightNode = rightNode.parentNode;\n                        if (p_endNode == rightNode) {\n                            // don't go past end\n                            return null;\n                        }\n                        if (rightNode.nextSibling != null) {\n                            // doesn't matter if this is end or not, allowed to move to end, just not past it.\n                            return rightNode.nextSibling;\n                        }\n                    }\n\n                    return null;\n                }\n        }\n    }, {\n        key: 'getNodeFromPosition',\n\n\n        /*Used by getCaretFromDomPosition\n         returns a node or null if error occurs*/\n        value: function getNodeFromPosition(p_theBody, p_strPath) {\n            var attribute = new _Attribute.Attribute();\n            var theNode = p_theBody;\n\n            // logic to remove chunk part of path\n            if (p_strPath.lastIndexOf(\"*\") > -1) {\n                var nPos = p_strPath.lastIndexOf(\"*\");\n                p_strPath = p_strPath.substring(nPos + 1);\n            }\n\n            // parse offset values and iterate end to start,\n            //moving set number of nodes to right before going to next level\n            var aStr = p_strPath.split(\"~\");\n            var nLen = aStr.length;\n            var i;\n\n            for (i = nLen - 2; i > -1; i--) {\n                theNode = theNode.firstChild;\n                if (theNode == null) {\n                    //error\n                    return null;\n                }\n                var nVal;\n                if (aStr[i].length == 0) {\n                    nVal = 0;\n                } else {\n                    nVal = parseInt(aStr[i], 10);\n                }\n\n                // To check for multiple text nodes together\n\n                var bIsText = false;\n                var bWasLastText = theNode.nodeType == 3 || theNode.nodeType == 1 && theNode.tagName.toLowerCase() == Constants.HIGHLIGHT_TAG && attribute.rw_getAttribute(theNode, \"rwstate\") != null;\n\n                while (nVal > 0) {\n                    // need to move right\n                    theNode = theNode.nextSibling;\n\n                    if (theNode == null) {\n                        return null;\n                    }\n\n                    bIsText = theNode.nodeType == 3 || theNode.nodeType == 1 && theNode.tagName.toLowerCase() == Constants.HIGHLIGHT_TAG && attribute.rw_getAttribute(theNode, \"rwstate\") != null;\n                    if (bIsText && bWasLastText) {\n                        // text together keep moving\n                        // leave bWasLastText as is\n                    } else {\n                        --nVal;\n                        bWasLastText = bIsText;\n                    }\n\n                    // for all non text will decrease nVal\n                    // for non text to non text will leave bWasLastText false\n                    // for non text to text will set bWasLastText true\n\n                    // for text to text will leave as is; and no decrease of nVal\n                    // for text to non text will set bWasLastText to false; and decrease nVal\n\n                    // doesn't care here if text is empty here, if that is a problem need to remove empty\n                    // text in tagsentences method, as is done with pkt\n                }\n            }\n            return theNode;\n        }\n    }, {\n        key: 'getTextFromNode',\n\n\n        //Get text that can be spoken from a node or element,\n        // but only from immediate level, not down tree\n        value: function getTextFromNode(p_node) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            var txt = \"\";\n\n            if (ssdom.isInvalidNode(p_node) || ssdom.isIgnored(p_node)) {\n                return txt;\n            }\n\n            if (p_node.nodeType == 3) {\n                if (p_node.parentNode.tagName.toLowerCase() != \"textarea\") {\n                    txt = p_node.nodeValue;\n                }\n            } else if (p_node.nodeType == 1) {\n                var strTagName = p_node.tagName.toLowerCase();\n                if (strTagName == \"img\") {\n                    var tmpAttr = attribute.rw_getAttribute(p_node, \"msg\");\n                    if (tmpAttr != null && tmpAttr.trimTH().length > 0) {\n                        txt = \" \" + tmpAttr.trimTH() + \" \";\n                    }\n                } else if (strTagName == \"span\") {\n                    var tmpAttr = attribute.rw_getAttribute(p_node, \"pron\");\n                    if (tmpAttr != null && tmpAttr.trimTH().length > 0) {\n                        txt = tmpAttr.trimTH();\n                    }\n\n                    tmpAttr = attribute.rw_getAttribute(p_node, \"chunk\");\n                    if (tmpAttr != null && tmpAttr == \"1\") {\n                        txt = p_node.innerHTML;\n                    }\n                    tmpAttr = p_node.isMathJax;\n                    if (tmpAttr) {\n                        var mathSpeak = new _MathSpeak.MathSpeak();\n                        txt = mathSpeak.getTextFromMathJax(p_node);\n                    }\n                } else if (strTagName == \"acronym\" || strTagName == \"abbr\") {\n                    // acronym and abbr are required to have a title, but this is displayed in browser\n                    // and may not be pronounced correctly, rather than have the title spelt as pronounced\n                    // and have user see this, have title and pron attributes and use pron for correct pronunciation.\n                    var tmpAttr = attribute.rw_getAttribute(p_node, \"pron\");\n                    var utils = new _Utilities.Utilities();\n                    if (tmpAttr != null && utils.trim(tmpAttr).length > 0) {\n                        txt = utils.trim(tmpAttr);\n                    } else {\n                        tmpAttr = p_node.getAttribute(\"title\");\n                        if (tmpAttr != null && utils.trim(tmpAttr).length > 0) {\n                            txt = utils.trim(tmpAttr);\n                        }\n                    }\n                } else if (strTagName == \"math\") {\n                    txt = this.getTextFromMathMl(p_node);\n                }\n            }\n\n            return txt;\n        }\n\n        /*Use this when p_node might equal p_endNode and do not want to\n         just return null in this case.  Moving to child allowed from end node, but not to next.\n         This should be used on first loop only, on subsequent loops reaching p_endNode\n         would either mean moved to end node or returned to node, not starting from end node.\n         (This is needed for example in searching range of children of single node, so start and end node are same,\n         without this would just skip all children in that case.)\n         */\n\n    }, {\n        key: 'getNextNodeAllowMoveToChild',\n        value: function getNextNodeAllowMoveToChild(p_node, p_bGoByStyle, p_endNode) {\n            return this.getNextNodeImpl(p_node, p_bGoByStyle, p_endNode, true, false);\n        }\n\n        /*Returns the next node, either directly to right or up to right.\n         Returns null if no right node.\n          allowed to move to end node but if end node passed in as node return null*/\n\n    }, {\n        key: 'getNextNodeIgnoreChildren',\n        value: function getNextNodeIgnoreChildren(p_node, p_bGoByStyle, p_endNode) {\n            return this.getNextNodeImpl(p_node, p_bGoByStyle, p_endNode, false, true);\n        }\n    }, {\n        key: 'getLastChildTextNode',\n\n\n        /* Use this to get the bottom child text node at end of the element\n         using same rules for ignoring nodes.\n         <br>\n         p_node the node to get last child of\n          return the first text node reached , null if cannot get one\n         Could also be img element with msg\n         If no valid children will return itself.\n         */\n        value: function getLastChildTextNode(p_node, p_bAllowImg) {\n            var attribute = new _Attribute.Attribute();\n            var ssdom = new _SSDOM.SSDOM();\n            if (p_node == null || p_node.lastChild == null || ssdom.isInvalidNode(p_node)) {\n                return p_node;\n            }\n\n            if (ssdom.isSpecialCaseWithIgnoredContent(p_node)) {\n                // No valid child text to go to and this is the top level node so can't go to previous.\n                return p_node;\n            }\n\n            // need to get down to absolute last child for get previous to work.\n            //(different to get first as getnext goes down tree while getPrev doesn't)\n\n            var tmpNode = p_node.lastChild;\n            while (tmpNode != null) {\n                var bIgnored = ssdom.isIgnored(p_node);\n\n                if (!bIgnored && tmpNode.nodeType == 3) {\n                    return tmpNode;\n                } else if (!bIgnored && tmpNode.nodeType == 1 && p_bAllowImg && tmpNode.tagName.toLowerCase() == \"img\" && attribute.rw_getAttribute(tmpNode, \"msg\") != null && attribute.rw_getAttribute(tmpNode, \"msg\").length > 0) {\n                    return tmpNode;\n                } else if (ssdom.isInvalidNode(tmpNode) || tmpNode.lastChild == null || ssdom.isSpecialCaseWithIgnoredContent(p_node)) {\n                    // can't go down and no match yet so look to previous\n                    var prevNode;\n                    if (p_bAllowImg) {\n                        prevNode = this.getPreviousTextNode(tmpNode, false, p_node);\n                    } else {\n                        prevNode = this.getPreviousTextNodeNoImg(tmpNode, false, p_node, true);\n                    }\n\n                    return prevNode;\n                } else {\n                    tmpNode = tmpNode.lastChild;\n                }\n            } //nb wont ever actually exit normally from this, will always be left via a return.\n\n            // if cannot get to child return self\n            return p_node;\n        }\n    }, {\n        key: 'getPreviousTextNodeNoImg',\n\n\n        /*Use this to get guaranteed text node and not img with msg\n         */\n        value: function getPreviousTextNodeNoImg(p_node, p_bGoByStyle, p_endNode, p_bIncludeBlanks) {\n            var leftNode = p_bIncludeBlanks ? this.getPreviousTextNode(p_node, p_bGoByStyle, p_endNode) : this.getPreviousTextNodeNoBlank(p_node, p_bGoByStyle, p_endNode);\n\n            while (leftNode != null && leftNode.nodeType != 3 && leftNode != p_endNode) {\n                if (leftNode.tagName.toLowerCase() == \"math\") {\n                    break;\n                }\n\n                if (leftNode.isMathJax) {\n                    break;\n                }\n\n                leftNode = p_bIncludeBlanks ? this.getPreviousTextNode(leftNode, p_bGoByStyle, p_endNode) : this.getPreviousTextNodeNoBlank(leftNode, p_bGoByStyle, p_endNode);\n            }\n\n            return leftNode;\n        }\n    }, {\n        key: 'getPreviousTextNodeNoBlank',\n\n\n        /* This script gets the position of the previous text node immediately before the one passed to the script\n         but only if contains useful text.\n          p_node start node to look from\n         p_bGoByStyle if true keep looking till reach non style node (passes back original of nothing found)\n         p_endNode, a node to not go past and not to be included as a return node\n         */\n        value: function getPreviousTextNodeNoBlank(p_node, p_bGoByStyle, p_endNode) {\n            var attribute = new _Attribute.Attribute();\n            var ssdom = new _SSDOM.SSDOM();\n            var leftNode = p_node;\n\n            while (leftNode != null && leftNode != p_endNode) {\n                leftNode = this.getPreviousTextNode(leftNode, p_bGoByStyle, p_endNode);\n\n                if (leftNode != null) {\n                    var strToCheck;\n\n                    //Either text node or msg img\n                    if (leftNode.nodeType == 3) {\n                        strToCheck = leftNode.nodeValue.trimTH();\n                    } else {\n                        if (leftNode.tagName.toLowerCase() == \"img\" && attribute.rw_getAttribute(leftNode, \"msg\") != null) {\n                            strToCheck = attribute.rw_getAttribute(leftNode, \"msg\").trimTH();\n                        } else if (leftNode.tagName.toLowerCase() == \"math\") {\n                            strToCheck = this.getTextFromMathMl(leftNode);\n                        } else if (leftNode.isMathJax) {\n                            var mathSpeak = new _MathSpeak.MathSpeak();\n                            strToCheck = mathSpeak.getTextFromMathJax(leftNode);\n                        }\n                    }\n\n                    if (ssdom.rw_isWordSpeakable(strToCheck)) {\n                        return leftNode;\n                    }\n                }\n            }\n            return null;\n        }\n    }, {\n        key: 'getPreviousTextNode',\n\n\n        /* This script gets the position of the previous text node of the one passed to the script\n         This will give the text node immediately before the current node if match found and\n         will include img elements with msg text.\n          p_node start node to look from\n         p_bGoByStyle if true then stop if hit non style node\n         p_endNode, a node to not go past and not to be included as a return node\n          return previous text node or null if no previous text node or it non style or end node, or returns element if image with msg text.\n         */\n        value: function getPreviousTextNode(p_node, p_bGoByStyle, p_endNode) {\n            var attribute = new _Attribute.Attribute();\n            var leftNode = p_node;\n            var bMatch = false;\n\n            // Note leftNode could equal end node from return from get prev Node\n            // okay to return this if a match, but do not want to search on before this to prev node.\n\n            while (leftNode != null && leftNode != p_endNode) {\n                leftNode = this.getPreviousNode(leftNode, p_bGoByStyle, p_endNode);\n\n                if (leftNode != null) {\n                    if (leftNode.nodeType == 3 && leftNode.parentNode.tagName.toLowerCase() != \"textarea\") {\n                        if (leftNode.nodeValue.length > 0) {\n                            bMatch = true;\n                        }\n                    }\n\n                    if (leftNode.nodeType == 1 && leftNode.tagName.toLowerCase() == \"math\") {\n                        bMatch = true;\n                    } else if (leftNode.nodeType == 1 && leftNode.isMathJax) {\n                        bMatch = true;\n                    } else if (leftNode.nodeType == 1 && leftNode.tagName.toLowerCase() == \"img\") {\n                        var tmpAttr = attribute.rw_getAttribute(leftNode, \"msg\");\n                        if (tmpAttr != null && tmpAttr.length > 0) {\n                            bMatch = true;\n                        }\n                    }\n\n                    if (bMatch) {\n                        return leftNode;\n                    }\n                }\n            }\n\n            return null;\n        }\n    }, {\n        key: 'getPreviousNode',\n\n\n        /*Returns the previous node.\n         This ignores child nodes of the current node.\n         If the node has no previous siblings it will go to the parent.\n         This gives the immediate node to the left except in one case.\n         If the node moved to has child nodes, immediately move to the bottom.  The nodes skipped will be\n         hit in following calls to getPreviouosNode as it goes up the tree again.  This is needed to\n         remove abiquity of direction to step (when given node with down and left, assume always came\n         from the one below).\n         p_aNode gives the start node\n         p_bGoByStyle determines whether the move should only go over style elements, stopping when hits anything else\n         (needed here rather checked by caller, as caller wont know if elements jumped on a 'left and down' move)\n         p_bEndNode - if not null then check if node matches the end node,\n         if pass in p_node that matches end node then return null is no next\n         however if moves to the end node then return that as allowed to move to next that is end node, just dont want to go past it\n         if it does then break from while loop and return that, if invalid return null.\n          returns a node.  null if no left node found (either to being at start or due to p_bGoByStyle or end node.\n         */\n        value: function getPreviousNode(p_node, p_bGoByStyle, p_endNode) {\n            var ssdom = new _SSDOM.SSDOM();\n            if (p_node == null || p_node == p_endNode) {\n                return null;\n            }\n\n            var leftNode = p_node;\n            // check if can go left\n            if (leftNode.previousSibling != null) {\n                // move left\n                leftNode = leftNode.previousSibling;\n                if (p_bGoByStyle) {\n                    if (!ssdom.isStyleNode(leftNode)) {\n                        return null;\n                    }\n                }\n\n                if (leftNode != null && ssdom.isInvalidNode(leftNode)) {\n                    if (p_endNode == leftNode) {\n                        // don't go past and do not want to return an invalid node so return null\n                        return null;\n                    }\n                    leftNode = this.getPreviousNode(leftNode, p_bGoByStyle, p_endNode);\n                } else {\n                    //move to end of child nodes\n                    //If find a node that is not invalid or non style type, do not need to check if is end node\n                    // as even if is behaviour is to just return the node, which will happen anyway,\n                    // only check for end node when alternative is to continue looking to previous node via new method call.\n\n                    while (leftNode != null && leftNode.lastChild != null) {\n                        if (ssdom.isSpecialCaseWithIgnoredContent(leftNode)) {\n                            // don't go to child of this.\n                            break;\n                        }\n\n                        leftNode = leftNode.lastChild;\n                        if (p_bGoByStyle) {\n                            if (!ssdom.isStyleNode(leftNode)) {\n                                leftNode = null;\n                            }\n                        }\n\n                        // if pass style check also want to check if invalid.\n                        if (leftNode != null && ssdom.isInvalidNode(leftNode)) {\n                            if (p_endNode == leftNode) {\n                                // don't go past and do not want to return an invalid node so return null\n                                return null;\n                            }\n                            leftNode = this.getPreviousNode(leftNode, p_bGoByStyle, p_endNode);\n                            break;\n                        }\n                    }\n\n                    if (leftNode != null && ssdom.isIgnored(leftNode)) {\n                        if (leftNode == p_endNode) {\n                            // don't go past and do not want to return an ignored node so return null\n                            return null;\n                        } else {\n                            leftNode = this.getPreviousNode(leftNode, p_bGoByStyle, p_endNode);\n                        }\n                    }\n                }\n            } else {\n                // move up\n                // Not checking for invalid here as should never get to sub child of invalid node.\n\n                leftNode = leftNode.parentNode;\n                if (p_bGoByStyle && leftNode != null) {\n                    if (!ssdom.isStyleNode(leftNode)) {\n                        leftNode = null;\n                    }\n                }\n\n                if (leftNode != null && ssdom.isIgnored(leftNode)) {\n                    if (leftNode == p_endNode) {\n                        return null;\n                    } else {\n                        leftNode = this.getPreviousNode(leftNode, p_bGoByStyle, p_endNode);\n                    }\n                }\n            }\n\n            return leftNode;\n        }\n    }, {\n        key: 'getFirstChildTextNode',\n\n\n        /* Use this to get the bottom child text node at start of the element\n         using same rules for ignoring nodes.\n         <br>\n         p_node the node to get first child of\n          return the first text node reached ,\n         Could also be img element with msg\n         If no valid children will return itself.\n         This means the result is not necessarily a text node.\n          */\n        value: function getFirstChildTextNode(p_node, p_bAllowImg) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            if (p_node == null || p_node.firstChild == null || ssdom.isInvalidNode(p_node)) {\n                return p_node;\n            }\n\n            if (ssdom.isSpecialCaseWithIgnoredContent(p_node)) {\n                // No valid child text to go to and this is the top level node so can't go to next.\n                return p_node;\n            }\n\n            var tmpNode = p_node.firstChild;\n            if (tmpNode.nodeType == 3) {\n                return tmpNode;\n            } else if (tmpNode.nodeType == 1 && p_bAllowImg && tmpNode.tagName.toLowerCase() == \"img\" && attribute.rw_getAttribute(tmpNode, \"msg\") != null && attribute.rw_getAttribute(tmpNode, \"msg\").length > 0) {\n                return tmpNode;\n            } else {\n                if (p_bAllowImg) {\n                    return this.getNextTextNode(tmpNode, false, p_node);\n                } else {\n                    return this.getNextTextNodeNoImg(tmpNode, false, p_node, true);\n                }\n            }\n        }\n    }, {\n        key: 'getNextTextNodeNoImg',\n\n\n        /*Use this to get guaranteed text node and not img with msg\n         */\n        value: function getNextTextNodeNoImg(p_node, p_bGoByStyle, p_endNode, p_bIncludeBlanks) {\n            var rightNode = p_bIncludeBlanks ? this.getNextTextNode(p_node, p_bGoByStyle, p_endNode) : this.getNextTextNodeNoBlank(p_node, p_bGoByStyle, p_endNode);\n\n            while (rightNode != null && rightNode.nodeType != 3 && rightNode != p_endNode) {\n                if (rightNode.tagName.toLowerCase() == \"math\") {\n                    break;\n                }\n                if (rightNode.isMathJax) {\n                    break;\n                }\n                rightNode = p_bIncludeBlanks ? this.getNextTextNode(rightNode, p_bGoByStyle, p_endNode) : this.getNextTextNodeNoBlank(rightNode, p_bGoByStyle, p_endNode);\n            }\n\n            return rightNode;\n        }\n    }, {\n        key: 'getNextTextNodeNoBlank',\n\n\n        /* This script gets the position of the next text node immediately after the one passed to the script\n         but only if contains useful text.\n          p_node start node to look from\n         p_bGoByStyle if true keep looking till reach non style node (passes back original of nothing found)\n         p_endNode, a node to not go past and not to be included as a return node\n          Return either a text node that is not blank or null\n         */\n        value: function getNextTextNodeNoBlank(p_node, p_bGoByStyle, p_endNode) {\n            var attribute = new _Attribute.Attribute();\n            var ssdom = new _SSDOM.SSDOM();\n            var rightNode = p_node;\n\n            while (rightNode != null && rightNode != p_endNode) {\n                rightNode = this.getNextTextNode(rightNode, p_bGoByStyle, p_endNode);\n\n                if (rightNode != null) {\n                    //Either text node or msg img\n                    var strToCheck;\n                    if (rightNode.nodeType == 3) {\n                        strToCheck = rightNode.nodeValue.trimTH();\n                    } else {\n                        if (rightNode.tagName.toLowerCase() == \"img\" && attribute.rw_getAttribute(rightNode, \"msg\") != null) {\n                            strToCheck = attribute.rw_getAttribute(rightNode, \"msg\").trimTH();\n                        } else if (rightNode.tagName.toLowerCase() == \"math\") {\n                            strToCheck = this.getTextFromMathMl(rightNode);\n                        } else if (rightNode.isMathJax) {\n                            var mathSpeak = new _MathSpeak.MathSpeak();\n                            strToCheck = mathSpeak.getTextFromMathJax(rightNode);\n                        }\n                    }\n\n                    if (ssdom.rw_isWordSpeakable(strToCheck)) {\n                        return rightNode;\n                    }\n                }\n            }\n            return null;\n        }\n    }, {\n        key: 'getTextFromMathMl',\n\n\n        /**\n         *\n         * @param p_node should be mathml node\n         */\n        value: function getTextFromMathMl(p_node) {\n            var ssdom = new _SSDOM.SSDOM();\n            // if has prev or next need other logic.\n            if (p_node.previousSibling != null || p_node.nextSibling != null) {\n                // move down level\n                var spanEl = ssdom.createWrapperElement();\n                p_node.parentNode.replaceChild(spanEl, p_node);\n                spanEl.appendChild(p_node);\n            }\n            var g_bIE = false;\n            if (g_bIE) {\n\n                var strML = p_node.outerHTML;\n                if (strML == null) {\n                    return \"\";\n                } else {\n                    if (strML.indexOf(\"<?import namespace\") > -1) {\n                        var n = strML.indexOf(\"/>\");\n                        if (n > -1) {\n                            strML = strML.substring(n + 2);\n                            strML = strML.replace(/m:/gi, \"\");\n                        }\n                    }\n                    return strML;\n                }\n            } else {\n\n                var strML = p_node.parentNode.innerHTML;\n                if (strML != null && strML.length > 0) {\n                    return strML;\n                } else {\n                    return \"\";\n                }\n            }\n        }\n    }, {\n        key: 'getNextTextNode',\n\n\n        /* This script gets the position of the next text node of the one passed to the script\n         This will give the text node immediately after the current node if match found and\n         will include img elements with msg text.\n          p_node start node to look from\n         p_bGoByStyle if true then stop if hit non style node\n         p_endNode, a node to not go past, if move to this node will return that if valid and go no further\n          return next text node or null if no next text node or it non style or end node\n         */\n        value: function getNextTextNode(p_node, p_bGoByStyle, p_endNode) {\n            var attribute = new _Attribute.Attribute();\n            var rightNode = p_node;\n            var bMatch = false;\n\n            // Note rightNode could equal end node from return from get next Node\n            // okay to return this if a match, but do not want to search on past this to next node.\n\n            while (rightNode != null && rightNode != p_endNode) {\n                rightNode = this.getNextNode(rightNode, p_bGoByStyle, p_endNode);\n\n                if (rightNode != null) {\n                    if (rightNode.nodeType == 3 && rightNode.parentNode.tagName.toLowerCase() != \"textarea\") {\n                        if (rightNode.nodeValue.length > 0) {\n                            bMatch = true;\n                        }\n                    }\n\n                    if (rightNode.nodeType == 1 && rightNode.tagName.toLowerCase() == \"math\") {\n                        bMatch = true;\n                    } else if (rightNode.nodeType == 1 && rightNode.isMathJax) {\n                        bMatch = true;\n                    } else if (rightNode.nodeType == 1 && rightNode.tagName.toLowerCase() == \"img\") {\n                        var tmpAttr = attribute.rw_getAttribute(rightNode, \"msg\");\n                        if (tmpAttr != null && tmpAttr.length > 0) {\n                            bMatch = true;\n                        }\n                    }\n\n                    if (bMatch) {\n                        return rightNode;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        /*Returns the next node.<br>\n         This includes child nodes of the current node.\n         If the node has no children it will move to the right.\n         If the node has no nodes to the right it will move up until it can move to the right\n          The nodes skipped will have been in previous calls to getNextNode as it came down the tree.\n         This is needed to remove ambiguity of direction to step\n         (when given node with down, assume is on way down). <p>\n         p_aNode gives the start node        <br>\n         p_bGoByStyle determines whether the move should only go over style elements,\n         stopping when hits anything else\n         (needed here rather checked by caller, as caller wont know if elements jumped on an up and right move)    <br>\n         p_bEndNode - if not null then check if node matches the end node,\n         if pass in p_node that matches end node then return null as no next\n         however if moves to the end node then return that as allowed to move to next that is end node, just dont want to go past it\n         if it does then break from while loop and return that, if invalid return null.\n          returns a node.  null if no right node found (either to being at end or due to p_bGoByStyle or end node).\n         */\n\n    }, {\n        key: 'getNextNode',\n        value: function getNextNode(p_node, p_bGoByStyle, p_endNode) {\n            return this.getNextNodeImpl(p_node, p_bGoByStyle, p_endNode, false, false);\n        }\n    }, {\n        key: 'getNextNodeImpl',\n\n\n        /*Returns the next node.<br>\n         This includes child nodes of the current node.\n         If the node has no children it will move to the right.\n         If the node has no nodes to the right it will move up until it can move to the right\n          The nodes skipped will have been in previous calls to getNextNode as it came down the tree.\n         This is needed to remove ambiguity of direction to step\n         (when given node with down, assume is on way down). <p>\n         p_aNode gives the start node        <br>\n         p_bGoByStyle determines whether the move should only go over style elements,\n         stopping when hits anything else\n         (needed here rather checked by caller, as caller wont know if elements jumped on an up and right move)    <br>\n         p_bEndNode - if not null then check if node matches the end node,\n         if pass in p_node that matches end node then return null as no next\n         however if moves to the end node then return that as allowed to move to next that is end node, just dont want to go past it\n         if it does then break from while loop and return that, if invalid return null.\n         p_bDeferEndNodeCheck - used if want the first pass to ignore the end node (i.e. if start and end node are same still want to check the child)\n         p_bAlwaysIgnoreChild - never look to child\n          returns a node.  null if no right node found (either to being at end or due to p_bGoByStyle or end node).\n         */\n        value: function getNextNodeImpl(p_node, p_bGoByStyle, p_endNode, p_bDeferEndNodeCheck, p_bAlwaysIgnoreChild) {\n            var ssdom = new _SSDOM.SSDOM();\n            if (p_node == null || p_node == p_endNode && (p_bAlwaysIgnoreChild || !p_bDeferEndNodeCheck)) {\n                return null;\n            }\n\n            var bInvalid = ssdom.isInvalidNode(p_node);\n\n            if (ssdom.isSpecialCaseWithIgnoredContent(p_node)) {\n                // math or textarea or msg img\n                bInvalid = true;\n            }\n\n            var rightNode = null;\n\n            if (p_node == p_endNode && p_bDeferEndNodeCheck) {\n                // can go to child, but if starting at end node, can only go to child.\n                if (!bInvalid && p_node.firstChild != null) {\n                    rightNode = p_node.firstChild;\n                } else {\n                    return null;\n                }\n            } else {\n                // The normal case\n                rightNode = p_node;\n\n                if (rightNode.firstChild != null && !bInvalid && !p_bAlwaysIgnoreChild) {\n                    rightNode = rightNode.firstChild;\n                } else if (rightNode.firstChild != null && p_bAlwaysIgnoreChild && p_endNode != null && ssdom.checkIfElementInsideElement(p_endNode, rightNode)) {\n                    // cannot use end node nor go past it.       //NOTE, cannot see exactly why this is here but was added as bug fix, but don't know what the bug was or how this fixes it.  Need to see if this can be removed safely.\n                    return null;\n                } else if (rightNode.nextSibling != null) {\n                    rightNode = rightNode.nextSibling;\n                } else //up to right\n                    {\n                        while (rightNode != null && rightNode.nextSibling == null) {\n                            rightNode = rightNode.parentNode;\n                            if (p_bGoByStyle) {\n                                if (!ssdom.isStyleNode(rightNode)) {\n                                    rightNode = null;\n                                }\n                            }\n                            if (p_endNode == rightNode) {\n                                // okay to move to end node but not to start at it, so return end node here\n                                break;\n                            }\n                        }\n                        if (rightNode != null && p_endNode != rightNode) {\n                            rightNode = rightNode.nextSibling;\n                        }\n                    }\n            }\n\n            if (rightNode != null) {\n                if (p_bGoByStyle) {\n                    if (!ssdom.isStyleNode(rightNode)) {\n                        rightNode = null;\n                    }\n                }\n            }\n\n            if (rightNode != null) {\n                if (ssdom.isInvalidNode(rightNode)) {\n                    //invalid look to next.\n                    rightNode = this.getNextNodeImpl(rightNode, p_bGoByStyle, p_endNode, false, true);\n                } else if (ssdom.isIgnored(rightNode)) {\n                    //ignored look to next.\n                    rightNode = this.getNextNodeImpl(rightNode, p_bGoByStyle, p_endNode, false, false);\n                }\n\n                // For deferred end node check this could move to the end node, so need to block this.\n                if (p_bDeferEndNodeCheck && rightNode == p_endNode && p_node == p_endNode) {\n                    // start and end the same, and child is invalid.\n                    rightNode = null;\n                }\n            }\n            return rightNode;\n        }\n    }]);\n\n    return DomNavigation;\n}();\n\n},{\"src/Constants/Constants\":1,\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/MathJax/MathSpeak\":16,\"src/SpeechStream/THCaret\":27,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/Utilities/Utilities\":34}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DomSentences = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevinml on 03/05/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nvar _DomNavigation = require('src/SpeechStream/DOM/DomNavigation');\n\nvar _THCaret = require('src/SpeechStream/THCaret');\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DomSentences = exports.DomSentences = function () {\n    function DomSentences() {\n        _classCallCheck(this, DomSentences);\n    }\n\n    /* Returns THCaretRange for the first sentence in the page for a given body\n     */\n\n\n    _createClass(DomSentences, [{\n        key: 'getSentenceFromPoint',\n        value: function getSentenceFromPoint(p_thCaret) {\n            var rightCaret = this.getSentenceBreakToRight(p_thCaret);\n            var leftCaret = this.getSentenceBreakToLeft(rightCaret);\n\n            if (leftCaret == null || rightCaret == null) {\n                return null;\n            }\n            var range = new _THCaretRange.THCaretRange();\n            range.setCaretRange(leftCaret, rightCaret);\n            return range;\n        }\n    }, {\n        key: 'getNextSentence',\n\n\n        /*Get the sentence break after passed range.\n         p_caretRange the range of the current sentence.\n         returns THCaretRange\n         */\n        value: function getNextSentence(p_caretRange, p_endNode) {\n            var domNav = new _DomNavigation.DomNavigation();\n            var ssdom = new _SSDOM.SSDOM();\n            if (p_caretRange == null) {\n                return null;\n            }\n\n            if (typeof p_endNode == \"undefined\") {\n                p_endNode = null;\n            }\n\n            var curNode = p_caretRange.rightCaret.node;\n            var curOffset = p_caretRange.rightCaret.offset;\n            if (ssdom.rw_checkForHiddenParent(p_caretRange.rightCaret.node)) {\n                return null;\n            }\n\n            if (p_caretRange.rightCaret.isSpecialCase()) {\n                curNode = domNav.getNextNodeIgnoreChildren(curNode, false, p_endNode);\n                curOffset = 0;\n            }\n\n            var rightCaret;\n            var leftCaret;\n\n            while (curNode != null) {\n                // check if in a text node and offset not at the end\n                if (curNode.nodeType == 3 && curOffset < curNode.nodeValue.length) {\n                    // search from within current node\n                    rightCaret = this.getSentenceBreakToRight(new _THCaret.THCaret(curNode, curOffset, false), p_endNode);\n\n                    if (rightCaret == null) {\n                        return null;\n                    }\n\n                    // check if returns same point, at paragraph break this will not get to next\n                    if (rightCaret.node == curNode && rightCaret.offset == curOffset) {\n                        // need to force move to next node\n                        var tmpText = domNav.getNextTextNodeNoBlank(curNode, false, p_endNode);\n                        if (tmpText == null) {\n                            return null;\n                        }\n                        rightCaret = this.getSentenceBreakToRight(new _THCaret.THCaret(tmpText, 0, false), p_endNode);\n                    }\n                } else {\n                    // if either not a text node or at end of node so need to move to next\n                    var tmpText = domNav.getNextTextNodeNoBlank(curNode, false, p_endNode);\n                    if (tmpText == null) {\n                        return null;\n                    }\n                    rightCaret = this.getSentenceBreakToRight(new _THCaret.THCaret(tmpText, 0, false), p_endNode);\n                }\n\n                leftCaret = this.getSentenceBreakToLeft(rightCaret, null);\n                if (leftCaret == null) {\n                    return null;\n                }\n\n                // check that this is not same as current leftCaret\n                if (p_caretRange.leftCaret.node != leftCaret.node || p_caretRange.leftCaret.offset != leftCaret.offset) {\n                    var thCaretRange = new _THCaretRange.THCaretRange();\n                    thCaretRange.setCaretRange(leftCaret, rightCaret);\n                    if (this.checkSentence(thCaretRange) && ssdom.rw_caretRangeIsSpeakable(thCaretRange)) {\n                        return thCaretRange;\n                    }\n                }\n\n                // else need to keep looking\n                curNode = rightCaret.node;\n\n                if (curNode.nodeType == 3) {\n                    // set up next loop so that search from right point. i.e. a full stop after the last break point\n                    var tmpTxt = curNode.nodeValue.replace(/[\\x21\\x3f\\x3a]/g, \".\"); // change !?: to .\n                    var nLastPos = tmpTxt.indexOf(\".\", rightCaret.offset + 1);\n                    if (nLastPos == -1) {\n                        curOffset = tmpTxt.length;\n                    } else {\n                        curOffset = nLastPos;\n                    }\n                } // curOffset irrelevant if not text node\n            }\n            return null;\n        }\n    }, {\n        key: 'checkSentence',\n\n\n        /**\n         * Check if is valid sentence to read that is not from one of our controls.\n         * (When navigating through a page it can reach the components that we have added,\n         * these should not be reached by next or previous or first sentence calls ever)\n         *\n         * @param p_caretRange THCaretRange\n         *\n         * Return true if valid, false otherwise.\n         */\n        value: function checkSentence(p_caretRange) {\n            var attribute = new _Attribute.Attribute();\n            var RWTH_COMPONENT = \"rwTHcomp\" + \"\";\n            // Check first and last for being component or subcomponet with attribute rwthcomp\n            var startNode = p_caretRange.leftCaret.node;\n            var bod = startNode.ownerDocument.body;\n            while (startNode != null && startNode != bod) {\n                if (startNode.nodeType == 1) {\n                    if (startNode.className == \"rwDictDefin\" || startNode.className == \"rwPopupContent\" || startNode.className == \"rwToolbarBarCollect\") {\n                        // allow continuous reading even if in dictionary component, or any popup content, or collect highlight\n                        break;\n                    }\n                    // This check is too broad.  Stops all continuous inside as well as in entering leaving.\n                    // Need to change all over to having stops at the start and end rather than blocking all continuous\n                    // inside the element.\n                    if (attribute.rw_getAttribute(startNode, RWTH_COMPONENT) != null) {\n                        return false;\n                    }\n                }\n                startNode = startNode.parentNode;\n            }\n\n            var endNode = p_caretRange.rightCaret.node;\n            if (endNode != startNode) {\n                while (endNode != null && endNode != bod) {\n                    if (endNode.className == \"rwDictDefin\" || endNode.className == \"rwPopupContent\" || endNode.className == \"rwToolbarBarCollect\") {\n                        // allow continuous reading even if in dictionary component\n                        break;\n                    }\n\n                    if (endNode.nodeType == 1 && attribute.rw_getAttribute(endNode, RWTH_COMPONENT) != null) {\n                        return false;\n                    }\n                    endNode = endNode.parentNode;\n                }\n            }\n            return true;\n        }\n    }, {\n        key: 'getPreviousSentence',\n\n        /*Get the sentence break before passed point.\n         p_caretRange the range of the current sentence.\n         returns THCaretRange\n         */\n        value: function getPreviousSentence(p_caretRange, p_endNode) {\n            var domNav = new _DomNavigation.DomNavigation();\n            var ssdom = new _SSDOM.SSDOM();\n            if (typeof p_endNode == \"undefined\") {\n                p_endNode = null;\n            }\n\n            var curNode = p_caretRange.leftCaret.node;\n            var curOffset = p_caretRange.leftCaret.offset;\n            var leftCaret;\n            var rightCaret;\n\n            while (curNode != null) {\n                // find previous full stop.  Iterate back through text nodes till find it.\n                //(Note need to find full stop directly and not use getSentenceBreakToLeft,\n                //as that gives a point after the full stop of unknown distance after it so would need this search anyway)\n                if (curNode.nodeType == 3) {\n                    var tmpTxt = curNode.nodeValue.replace(/[\\x21\\x3f\\x3a]/g, \".\"); // change !?: to .\n                    var nLastPos;\n                    if (curOffset > 0) {\n                        nLastPos = tmpTxt.lastIndexOf(\".\", curOffset);\n                    } else if (curOffset == 0) {\n                        // is at start so need to move to previous node\n                        nLastPos = -1;\n                    } else // -1\n                        {\n                            // need to search full text node\n                            nLastPos = tmpTxt.lastIndexOf(\".\");\n                        }\n\n                    while (nLastPos > -1) {\n                        curOffset = nLastPos;\n\n                        // if this is not a valid break point then the\n                        // break point to right of here will match the one passed in\n                        rightCaret = this.getSentenceBreakToRight(new _THCaret.THCaret(curNode, curOffset, true), p_endNode);\n                        if (rightCaret == null) {\n                            return null;\n                        }\n\n                        if (rightCaret.node != p_caretRange.rightCaret.node || rightCaret.offset != p_caretRange.rightCaret.offset) {\n                            // found previous break point\n                            leftCaret = this.getSentenceBreakToLeft(rightCaret, p_endNode);\n                            if (leftCaret == null) {\n                                return null;\n                            }\n\n                            var thCaretRange = new _THCaretRange.THCaretRange();\n                            thCaretRange.setCaretRange(leftCaret, rightCaret);\n                            if (this.checkSentence(thCaretRange) && ssdom.rw_caretRangeIsSpeakable(thCaretRange)) {\n                                return thCaretRange;\n                            }\n                        }\n\n                        if (nLastPos == 0) {\n                            nLastPos = -1;\n                        } else {\n                            nLastPos = tmpTxt.lastIndexOf(\".\", nLastPos - 1);\n                        }\n                    }\n                }\n\n                curOffset = -1;\n\n                // first search without going past non style type nodes so looking for split sentences in\n                // same paragraph.  If get null then need to move to previous section and use that\n                // i.e. Moving from span to table or different paragraph will get null on first call\n                // This test does not need to look for img with msg as this is never a break,\n                // only consider if need to go past a style node, as may get to a sentence that only contains an img with msg.\n                tmpNode = domNav.getPreviousTextNodeNoImg(curNode, true, p_endNode, false);\n                if (tmpNode != null) {\n                    // carry on to next loop\n                    curNode = tmpNode;\n                } else {\n                    // For this need to check for img with msg\n                    curNode = domNav.getPreviousTextNodeNoBlank(curNode, false, p_endNode);\n                    // As moved back to previous paragraph, that counts as a sentence\n                    // break even if there is no full stop.\n                    if (curNode != null) {\n                        if (curNode.nodeType == 3) {\n                            rightCaret = this.getSentenceBreakToRight(new _THCaret.THCaret(curNode, curNode.nodeValue.length, false), p_endNode);\n                        } else {\n                            rightCaret = this.getSentenceBreakToRight(new _THCaret.THCaret(curNode, 0, false), p_endNode);\n                        }\n\n                        if (rightCaret == null) {\n                            return null;\n                        }\n\n                        // if this is not a valid break point then the\n                        // break point to right of here will match the one passed in\n                        if (rightCaret.node != p_caretRange.rightCaret.node || rightCaret.offset != p_caretRange.rightCaret.offset) {\n                            // at previous sentence\n                            leftCaret = this.getSentenceBreakToLeft(rightCaret, p_endNode);\n                            if (leftCaret == null) {\n                                return null;\n                            }\n                            return new _THCaretRange.THCaretRange(leftCaret, rightCaret);\n                        }\n                        //else should never actually get an else here, but if does, carry on looping\n                    }\n                }\n            }\n\n            return null;\n        }\n    }, {\n        key: 'getSentenceBreakToLeft',\n\n\n        /* Use this to get left break point as a THCaret <br>\n         p_thCaret point to start from\n         p_endNode optional if have a node do not want to go past\n         */\n        value: function getSentenceBreakToLeft(p_thCaret, p_endNode) {\n            var domNav = new _DomNavigation.DomNavigation();\n            var ssdom = new _SSDOM.SSDOM();\n            if (typeof p_endNode == \"undefined\") {\n                p_endNode = null;\n            }\n\n            if (p_thCaret == null || p_thCaret.node == null) {\n                return null;\n            }\n\n            var node = p_thCaret.node;\n            var nOffset = p_thCaret.offset;\n\n            if (p_thCaret.node.nodeType == 1 && p_thCaret.node.tagName.toLowerCase() == \"math\") {\n                return p_thCaret;\n            }\n\n            if (p_thCaret.node.nodeType == 1 && p_thCaret.node.isMathJax) {\n                return p_thCaret;\n            }\n\n            if (p_thCaret.forwardBias) {\n                if (node.nodeType == 3 && nOffset == node.nodeValue.length) {\n                    // move to actual char the caret is pointing forward to (if node ended in . wouldn't have lastchar to check against otherwise)\n                    node = domNav.getNextTextNode(node, true, p_endNode);\n                    nOffset = 0;\n                    if (node == null) {\n                        // with no next node, safe to use original\n                        node = p_thCaret.node;\n                        nOffset = p_thCaret.offset;\n                    }\n                }\n            } else {\n                // as end is after break need to move back space to find previous one\n                if (nOffset > 0) {\n                    --nOffset;\n                } else {\n                    // relates to last character of previous text node, need to move to that\n                    node = domNav.getPreviousTextNode(node, true, p_endNode);\n                    if (node == null) {\n                        // no previous point to go back to\n                        return p_thCaret;\n                    }\n                    if (node.nodeType == 3) {\n                        nOffset = node.nodeValue.length - 1;\n                    } else {\n                        // is special case (i.e. img with text).\n                        nOffset = 0;\n\n                        // if this moves back to a math element, need to break here\n                        if (node.tagName.toLowerCase() == \"math\") {\n                            return p_thCaret;\n                        }\n\n                        // if this moves back to a math element, need to break here\n                        if (node.isMathJax) {\n                            return p_thCaret;\n                        }\n                    }\n                }\n            }\n\n            // check if is at a full stop already\n            // lastIndexOf looks from after current character note before so if at a .\n            // will find spot it is on rather than looking before it.\n            if (node.nodeType == 3) {\n                var aChar = node.nodeValue.charAt(nOffset);\n                if (aChar == '.' || aChar == '!' || aChar == '?' || aChar == ':') {\n                    // move back one.\n                    if (nOffset > 0) {\n                        --nOffset;\n                    } else {\n                        node = domNav.getPreviousTextNode(node, true, p_endNode);\n                        if (node == null) {\n                            return p_thCaret;\n                        }\n                        if (node.nodeType == 3) {\n                            // even if length = 0 will still work due to check later\n                            nOffset = node.nodeValue.length - 1;\n                        } else {\n                            nOffset = 0;\n                            // if this moves back to a math element, need to break here\n                            if (node.tagName.toLowerCase() == \"math\") {\n                                return p_thCaret;\n                            }\n\n                            if (node.isMathJax) {\n                                return p_thCaret;\n                            }\n                        }\n                    }\n                }\n            }\n\n            var matchedNode = node;\n            var matchedOffset = nOffset;\n            var leftNode = node;\n            var leftOffset = nOffset;\n\n            // cycle to previous break point.\n\n            var bFound = false;\n\n            var lastChar = ' ';\n\n            while (!bFound) {\n                if (ssdom.isSpecialCaseNested(leftNode)) {\n                    leftNode = ssdom.checkForSpecialParent(leftNode);\n                    // note if nested will not necessary match this straight away but looping will hit this eventually.\n                    // if this moves back to a math element, need to break here\n                    if (leftNode.tagName.toLowerCase() == \"math\") {\n                        bFound = true;\n                        break;\n                    }\n\n                    // if this moves back to a math element, need to break here\n                    if (leftNode.isMathJax) {\n                        bFound = true;\n                        break;\n                    }\n\n                    matchedNode = leftNode;\n                    matchedOffset = 0;\n                } else if (leftNode.nodeType == 3) {\n                    // only look to break points in text nodes\n                    //first get text to check\n                    var txt = leftNode.nodeValue;\n\n                    if (txt.length > 0) {\n                        // iterate left to break point if there\n                        // look for full stop\n\n                        if (leftOffset == -1) {\n                            leftOffset = txt.length;\n                        }\n\n                        txt = txt.replace(/[\\x21\\x3f\\x3a]/g, \".\"); // change !?: to .\n\n                        var nPos = txt.lastIndexOf(\".\", leftOffset);\n\n                        while (nPos > -1) {\n                            //found possible sentence end\n                            //check if abbr then\n                            // check against lastChar\n                            if (ssdom.rw_isFullStop(txt, nPos, leftNode)) {\n                                if (nPos < txt.length - 1) {\n                                    // if before last char safe to assume sentence break\n                                    matchedNode = leftNode;\n                                    matchedOffset = nPos + 1;\n                                    bFound = true;\n                                    break;\n                                } else {\n                                    //else is full stop at end of node need to check against first char of next node held in lastChar\n                                    if (!ssdom.rw_isTextChar(lastChar)) {\n                                        // allow last match set in prev iteration to stand.\n                                        bFound = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (nPos == 0) {\n                                //Note, javascript lastIndexOf, does NOT work same as Java lastIndexOf.  If pass -1 as start point, get an incorrect result.  (Most likely bug in javascript.)\n                                nPos = -1;\n                            } else {\n                                nPos = txt.lastIndexOf(\".\", nPos - 1);\n                            }\n                        }\n\n                        if (bFound) {\n                            // escalate the break\n                            break;\n                        }\n\n                        //No sentence end found so set start of this node to match\n                        // only do this if the node contains text\n                        var utils = new _Utilities.Utilities();\n                        if (utils.trim(txt).length > 0) {\n                            matchedNode = leftNode;\n                            matchedOffset = 0;\n                        }\n\n                        lastChar = txt.charAt(0);\n                    }\n                }\n\n                // get previous node\n                leftNode = domNav.getPreviousNode(leftNode, true, p_endNode); //is null if doesnt find suitable node to left\n                leftOffset = -1; //set to -1 and set to length later rather than check if text node here (as check again next loop anyway)\n                if (leftNode == null) {\n                    // Gone back as far as need to, use matched value that currently have\n                    bFound = true;\n                    break;\n                }\n\n                // check if moved to a special case going backwards\n                if (leftNode.nodeType == 3 && ssdom.isSpecialCaseNested(leftNode)) {\n                    //is special case\n                    leftNode = ssdom.checkForSpecialParent(leftNode);\n\n                    if (leftNode == null) {\n                        // Gone back as far as need to, use matched value that currently have\n                        bFound = true;\n                        break;\n                    }\n                }\n            }\n\n            // here matched should match the left sentence break point\n\n            // check for whitespace in node before text\n            if (matchedNode.nodeType == 3) {\n                var txt = matchedNode.nodeValue;\n                if (matchedOffset < txt.length) {\n                    while (matchedOffset < txt.length) {\n                        if (ssdom.rw_isWhiteSpace(txt.charAt(matchedOffset))) {\n                            //                    if(matchedNode == p_thCaret.node &&\n                            //                        matchedOffset >= p_thCaret.offset)\n                            //                    {   // do not go beyond caret passed in.\n                            //                        break;\n                            //                    }\n                            //                    else\n                            //                    {\n                            ++matchedOffset;\n                            //                    }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return new _THCaret.THCaret(matchedNode, matchedOffset, true);\n        }\n    }, {\n        key: 'getSentenceBreakToRight',\n\n\n        /* Use this to get right break point as a THCaret <br>\n         This will not go past non style nodes, so if the passed caret is last value\n         before a break the same value will be returned.<br>\n         p_thCaret point to start from\n         p_endNode optional, include if have node do not wish to go past, should not be same as node in p_thCaret.\n         */\n        value: function getSentenceBreakToRight(p_thCaret, p_endNode) {\n            var domNav = new _DomNavigation.DomNavigation();\n            var ssdom = new _SSDOM.SSDOM();\n            if (typeof p_endNode == \"undefined\") {\n                p_endNode = null;\n            }\n            // Note will not break inside an element that has readable text (i.e. img with text)\n            // only in actual text nodes\n\n            if (p_thCaret == null || p_thCaret.node == null) {\n                return null;\n            }\n\n            var rightNode = p_thCaret.node;\n            var rightOffset = p_thCaret.offset;\n\n            // matched node, when right node goes past end of sentence use last matched node.\n            var matchedNode = rightNode;\n            var matchedOffset = rightOffset;\n\n            // cycle to next break point.\n\n            var bFound = false;\n\n            var lastChar = ' ';\n\n            var cmdElem = null;\n            var tmpCmdElem = null;\n            //todo remove or add\n            //        if(g_bUseCommands)\n            //        {\n            //            cmdElem = rw_findCommandNode(rightNode);\n            //        }\n\n            while (!bFound) {\n                if (ssdom.isSpecialCaseNested(rightNode)) {\n                    rightNode = ssdom.checkForSpecialParent(rightNode);\n                    // note if nested will not necessary match this straight away but looping will hit this eventually.\n                    if (rightNode.tagName.toLowerCase() == \"math\") {\n                        bFound = true;\n                        break;\n                    }\n\n                    if (rightNode.isMathJax) {\n                        bFound = true;\n                        break;\n                    }\n\n                    matchedNode = rightNode;\n                    matchedOffset = 0;\n                    // get next node.\n                    rightNode = domNav.getNextNodeIgnoreChildren(rightNode, true, p_endNode); //is null if doesnt find suitable node to right\n                } else if (rightNode.nodeType == 3) {\n                    // only look to break points in text nodes\n                    //first get text to check\n                    var txt = rightNode.nodeValue;\n\n                    if (txt.length > 0) {\n                        // iterate right to break point if there\n\n                        //if last char is a . need to check if next is letter or digit\n                        //   if is a non letter or digit (i.e. whitespace symbol) then treat as sentence break\n                        if (lastChar == '.') {\n                            var testChar = txt.charAt(rightOffset);\n                            if (!ssdom.rw_isTextChar(testChar)) {\n                                // is sentence end, dont include this allow matched from end of last node\n                                bFound = true;\n                                break;\n                            }\n                        }\n\n                        txt = txt.replace(/[\\x21\\x3f\\x3a]/g, \".\"); // change !?: to .\n                        var nPos = txt.indexOf(\".\", rightOffset);\n\n                        while (nPos > -1) {\n                            //found possible sentence end\n                            // check if full stop based on following char or preceeding abbr.\n                            if (ssdom.rw_isFullStop(txt, nPos, rightNode)) {\n                                if (nPos < txt.length - 1) {\n                                    matchedNode = rightNode;\n                                    matchedOffset = nPos + 1; // set to point after full stop (sentence is range before to just after sentence to include full stop.)\n                                    bFound = true;\n                                }\n                                // else nPos == txt.length -1 and is last char of string,\n                                //might be end but need to check next node\n                                //break to go to next loop\n\n                                break;\n                            }\n\n                            rightOffset = nPos + 1;\n                            nPos = txt.indexOf(\".\", rightOffset);\n                        }\n\n                        if (bFound) {\n                            // escalate the break\n                            break;\n                        }\n\n                        //No sentence end found so set end of this node to match\n                        //assuming that this has actual content, no need to extend to empty text nodes\n                        var utilities = new _Utilities.Utilities();\n                        if (utilities.trim(txt).length > 0) {\n                            matchedNode = rightNode;\n                            matchedOffset = txt.length;\n                        }\n\n                        lastChar = txt.charAt(txt.length - 1);\n                        if (lastChar == '.') {\n                            // don't want last char set to a . if this is part of an abbreviation, as otherwise\n                            // the next loop will see it as a possible sentence break\n                            if (!ssdom.rw_isFullStop(txt, txt.length - 1, rightNode)) {\n                                lastChar = ' ';\n                            }\n                        }\n                    }\n\n                    // get next node.\n                    rightNode = domNav.getNextNode(rightNode, true, p_endNode); //is null if doesnt find suitable node to right\n                } else {\n                    // get next node.\n                    rightNode = domNav.getNextNode(rightNode, true, p_endNode); //is null if doesnt find suitable node to right\n                }\n\n                rightOffset = 0;\n                if (rightNode == null) {\n                    // Gone forward as far as need to, use matched value that currently have\n                    bFound = true;\n                    break;\n                } else {\n                    //                if(g_bUseCommands) todo\n                    //                {\n                    //                    tmpCmdElem = rw_findCommandNode(rightNode);\n                    //                    if(cmdElem == null)\n                    //                    {\n                    //                        cmdElem = tmpCmdElem;\n                    //                    }\n                    //                    else\n                    //                    {\n                    //                        if(tmpCmdElem != cmdElem)\n                    //                        {   // command change, break\n                    //                            bFound = true;\n                    //                            break;\n                    //                        }\n                    //                    }\n                    //                }\n                }\n            }\n\n            // here matched should match the left sentence break point\n\n            // check for whitespace in node before text\n            if (matchedNode.nodeType == 3) {\n                var txt = matchedNode.nodeValue;\n                if (matchedOffset > 0 && matchedOffset <= txt.length) {\n                    while (matchedOffset > 0) {\n                        if (ssdom.rw_isWhiteSpace(txt.charAt(matchedOffset - 1))) {\n                            //                    if(matchedNode == p_thCaret.node &&\n                            //                        matchedOffset <= p_thCaret.offset)\n                            //                    {   // do not go before caret passed in.\n                            //                        break;\n                            //                    }\n                            //                    else\n                            //                    {\n                            --matchedOffset;\n                            //                    }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return new _THCaret.THCaret(matchedNode, matchedOffset, false);\n        }\n    }]);\n\n    return DomSentences;\n}();\n\n},{\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/DomNavigation\":3,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/THCaret\":27,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/Utilities/Utilities\":34}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SSDOM = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevin on 01/04/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _THCaret = require('src/SpeechStream/THCaret');\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nvar _THRange = require('src/SpeechStream/THRange');\n\nvar _THDomRefPt = require('src/SpeechStream/THDomRefPt');\n\nvar _MathSpeak = require('src/SpeechStream/MathJax/MathSpeak');\n\nvar _DomNavigation = require('src/SpeechStream/DOM/DomNavigation');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nvar _DomSentences = require('src/SpeechStream/DOM/DomSentences');\n\nvar _Constants = require('src/Constants/Constants');\n\nvar Constants = _interopRequireWildcard(_Constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SSDOM = exports.SSDOM = function () {\n    function SSDOM() {\n        _classCallCheck(this, SSDOM);\n    }\n\n    _createClass(SSDOM, [{\n        key: 'checkForSpecialParent',\n        value: function checkForSpecialParent(p_node) {\n            if (p_node != null) {\n                var bod = this.getBody(p_node);\n                var tmpNode = p_node;\n                while (tmpNode != null && tmpNode != bod) {\n                    if (this.isSpecialCase(tmpNode)) {\n                        return tmpNode;\n                    }\n                    tmpNode = tmpNode.parentNode;\n                }\n            }\n            return null;\n        }\n    }, {\n        key: 'getBody',\n        value: function getBody(p_node) {\n            // This exists for IE 5.5 so for a browser we no longer support.\n            if (p_node.document) {\n                return p_node.document.body;\n            } else {\n                return p_node.ownerDocument.body;\n            }\n        }\n        /* Check if it is a special case where text cannot be used directly, i.e.\n         span with pron or chunk or element with ignore attribute.  Or acronym or abbr. OR Img with msg attribute. OR mathML\n         <p>\n         return boolean\n         */\n\n    }, {\n        key: 'isSpecialCase',\n        value: function isSpecialCase(p_node) {\n            var attribute = new _Attribute.Attribute();\n            if (p_node == null) {\n                return false;\n            }\n            if (p_node.nodeType == 1) {\n                var tagName = p_node.tagName.toLowerCase();\n                if (tagName == Constants.HIGHLIGHT_TAG || tagName == \"span\") {\n                    var attr = attribute.rw_getAttribute(p_node, \"pron\");\n                    if (attr != null) {\n                        return true;\n                    }\n                    attr = attribute.rw_getAttribute(p_node, \"chunk\");\n                    if (attr != null) {\n                        return true;\n                    }\n                    attr = p_node.isMathJax;\n                    if (attr != null && attr) {\n                        return true;\n                    }\n                } else if (tagName == \"acronym\" || tagName == \"abbr\") {\n                    var attr = p_node.getAttribute(\"title\");\n                    if (attr != null) {\n                        return true;\n                    }\n                } else if (tagName == \"chunk\") {\n                    return true;\n                } else if (tagName == \"img\") {\n                    var attr = attribute.rw_getAttribute(p_node, \"msg\");\n                    if (attr != null) {\n                        return true;\n                    }\n                } else if (tagName == \"math\") {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'isSpecialCaseHighlightable',\n        value: function isSpecialCaseHighlightable(p_node) {\n            var attribute = new _Attribute.Attribute();\n            if (p_node.nodeType == 1) {\n                var tagName = p_node.tagName.toLowerCase();\n                if (tagName == \"span\") {\n                    var attr = attribute.rw_getAttribute(p_node, \"pron\");\n                    if (attr != null) {\n                        return true;\n                    }\n                    attr = attribute.rw_getAttribute(p_node, \"chunk\");\n                    if (attr != null && attr == \"1\") {\n                        return true;\n                    }\n                    attr = p_node.isMathJax;\n                    if (attr != null && attr) {\n                        var math = new _MathSpeak.MathSpeak();\n                        var strML = math.getTextFromMathJax(p_node);\n                        if (strML.length > 0) {\n                            return true;\n                        }\n                    }\n                } else if (tagName == \"acronym\" || tagName == \"abbr\") {\n                    var attr = p_node.getAttribute(\"title\");\n                    if (attr != null) {\n                        return true;\n                    }\n                } else if (tagName == \"math\") {\n                    // mathml without mathjax is not highlighted.\n                    return false;\n                }\n            }\n            return false;\n        }\n        /**\n         * Check if the inner element is contained within the containing element.  Return True if it is, false otherwise.\n         * @param p_innerElement\n         * @param p_containingElement\n         */\n\n    }, {\n        key: 'checkIfElementInsideElement',\n        value: function checkIfElementInsideElement(p_innerElement, p_containingElement) {\n            if (p_innerElement == null || p_containingElement == null) {\n                return false;\n            }\n            var tmp = p_innerElement.parentNode;\n            while (tmp != null) {\n                if (tmp == p_containingElement) {\n                    return true;\n                }\n                tmp = tmp.parentNode;\n            }\n\n            return false;\n        }\n    }, {\n        key: 'isSpecialCaseWithIgnoredContent',\n\n\n        /**\n         * Check if it is a special case where the child elements are to be ignored to to this parent element\n         * having special treatment.\n         *\n         * i.e.\n         * span with mathjax, textarea, Img with msg attribute. or mathML\n         * @param p_node\n         * @returns {boolean}\n         */\n        value: function isSpecialCaseWithIgnoredContent(p_node) {\n            var attribute = new _Attribute.Attribute();\n            if (p_node == null) {\n                return false;\n            }\n            if (p_node.nodeType == 1) {\n                var tagName = p_node.tagName.toLowerCase();\n                if (tagName == \"span\") {\n                    var attr = p_node.isMathJax;\n                    if (attr != null && attr) {\n                        return true;\n                    }\n                } else if (tagName == \"textarea\") {\n                    // don't go into textareas covered separate from normal logic flow.\n                    // dont go to next as would be going past p_node not to child\n                    return true;\n                } else if (tagName == \"img\") {\n                    var attr = attribute.rw_getAttribute(p_node, \"msg\");\n                    if (attr != null) {\n                        return true;\n                    }\n                } else if (tagName == \"math\") {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'rw_isWordSpeakable',\n\n\n        /*Use this to check if the word actually contains anything that can be spoken.\n         returns true if so, false otherwise.*/\n        value: function rw_isWordSpeakable(p_strWord) {\n            if (p_strWord == null || p_strWord.length == 0) {\n                return false;\n            }\n            var utilities = new _Utilities.Utilities();\n\n            var tmpWord = utilities.trim(p_strWord);\n            if (tmpWord.length == 1) {\n                var tmpC = tmpWord.charCodeAt(0);\n                if (tmpC == 96 || //         `   grave\n                tmpC == 180 || //         '   acute\n                tmpC == 8216 || //        '   quoteleft\n                tmpC == 8217 || //        '   quoteright\n                tmpC == 8220 || //        \"   quotedblleft\n                tmpC == 8221) //          \"   quotedblright\n                    {\n                        return false;\n                    }\n            }\n\n            // loop through till get character to read\n            var nLen = tmpWord.length;\n            var i = 0;\n            var nVal;\n            for (i = 0; i < nLen; i++) {\n                nVal = tmpWord.charCodeAt(i);\n                if (nVal > 63 && nVal < 91 || nVal > 96 && nVal < 123 || nVal > 127 && nVal != 160) {\n                    // @A-Z a-z high ascii\n                    return true;\n                } else if (nVal > 46 && nVal < 58) {\n                    // / 0-9\n                    return true;\n                } else if (nVal > 35 && nVal < 39 || nVal == 43 || nVal == 61) {\n                    // $ % & + =\n                    return true;\n                }\n                // Removed ' as only read if part of a word in which case will pass on the character.  Don't want ' to be read by itself.\n                else if ( /*nVal == 39 || */nVal == 42 || nVal == 45 || nVal == 92 || nVal > 93 && nVal < 97) {// 39 '  42 *  45 -  92 \\  94 ^  95 _  96 `\n                        //only if not VW Kate\n                        //                if(g_strVoice != \"VW Kate\")\n                        //                {   // Not worrying about target maybe using different voice as people using Kate will not be using options that allow that\n                        //                    return true;\n                        //                }\n                    }\n            }\n            //todo\n            //        if(g_bMathsSymbols)\n            //        {   // This only checks for symbol by itself.  Symbol with text will be caught above,\n            //            // maths symbols immediately next to other symbols need to be explicitly added to count.\n            //            if(rw_mathsSymbolCheck(tmpWord))\n            //            {\n            //                return true;\n            //            }\n            //        }\n\n            return false;\n        }\n    }, {\n        key: 'createWrapperElement',\n        value: function createWrapperElement() {\n            return this.createObject(Constants.WRAPPER_TAG, null, null, g_bOverrideSpan ? \"thspan\" : null);\n        }\n    }, {\n        key: 'createObject',\n\n\n        /**\n         * Create object in the current document\n         * @param p_strName the name of the tag to create\n         * @param p_attrList atrribute list in form [\"key\",\"value\",...]\n         * @param p_strId the id\n         * @param p_strClass the class\n         */\n        value: function createObject(p_strName, p_attrList, p_strId, p_strClass) {\n            return this.createObjectForDoc(p_strName, p_attrList, p_strId, p_strClass, document);\n        }\n    }, {\n        key: 'createObjectForDoc',\n\n\n        /**\n         * Create object in the current document\n         * @param p_strName the name of the tag to create\n         * @param p_attrList atrribute list in form [\"key\",\"value\",...]\n         * @param p_strId the id\n         * @param p_strClass the class\n         * @param p_doc document to use\n         */\n        value: function createObjectForDoc(p_strName, p_attrList, p_strId, p_strClass, p_doc) {\n            var theObj = p_doc.createElement(p_strName);\n            if (p_strId != null) {\n                theObj.id = p_strId;\n            }\n\n            if (p_strClass != null) {\n                theObj.className = p_strClass;\n            }\n\n            if (p_attrList != null) {\n                var nLen = p_attrList.length;\n\n                //            if(SSDOM.bIEOld)\n                //            {\n                //                for(var i = 0; i < nLen; i += 2)\n                //                {\n                //                    if(p_attrList[i] == \"style\")\n                //                    {\n                //                        SSDOM.setStyle(theObj, p_attrList[i + 1]);\n                //                    }\n                //                    else\n                //                    {\n                //                        theObj.setAttribute(p_attrList[i], p_attrList[i + 1]);\n                //                    }\n                //                }\n                //            }\n                //            else\n                {\n                    for (var i = 0; i < nLen; i += 2) {\n                        theObj.setAttribute(p_attrList[i], p_attrList[i + 1]);\n                    }\n                }\n            }\n            return theObj;\n        }\n    }, {\n        key: 'isStyleNode',\n\n\n        /*isStyleNode takes the node to check and a boolean attr to ignore started attr in nodes, defaults to false  */\n        /**\n         * Style node is one that is not a sentence breaker, such as &lt;b&gt;.  Just affects appearance and not a test divider.\n         * A span or custom element used by the toolbar is a style element, unless it is part of highlighted speech or\n         * specific attribute set to make it a breaker.\n         *\n         * @param p_node\n         * @returns {*}\n         */\n        value: function isStyleNode(p_node) {\n            var attribute = new _Attribute.Attribute();\n            if (p_node == null) {\n                // happened due to node being orphaned and passed in parent which was null.\n                // Also changed caller, but check here as used from many point.\n                return false;\n            }\n\n            if (p_node.nodeType != 1) {\n                // text node and comment treat as style.\n                return p_node.nodeType == 3 || p_node.nodeType == 8;\n            }\n\n            var strName = p_node.tagName.toLowerCase().trimTH();\n            if (strName == Constants.HIGHLIGHT_TAG) //probably span\n                {\n                    var strAttr = attribute.rw_getAttribute(p_node, \"started\");\n                    if (strAttr != null && strAttr == \"1\") {\n                        return false;\n                    }\n                }\n            //todo is this needed\n            //        if (this.rw_getAttribute(p_node, RWTH_SKIP_CONTINUOUS) != null) {\n            //            return false;\n            //        }\n\n            return this.isInStyleList(strName);\n        }\n    }, {\n        key: 'isInStyleList',\n        value: function isInStyleList(p_strName) {\n            var strStyleList = \"~em~strong~b~i~u~tt~font~kbd~dfn~cite~sup~sub~a~embed~span~small~nobr~wbr~acronym~\" + \"abbr~code~s~chunk~th:pron~img~/th:pron~w~/w~lic/lic~break~silence~thspan~beelinereader~beelinespan~\" + Constants.HIGHLIGHT_TAG + \"~\" + Constants.WRAPPER_TAG + \"~\";\n\n            return strStyleList.indexOf(\"~\" + p_strName + \"~\") > -1;\n        }\n    }, {\n        key: 'isInvalidNode',\n\n        //Checks if node is invalid for being read.  returns true if invalid.\n        value: function isInvalidNode(p_node) {\n            if (p_node == null) {\n                return true;\n            }\n\n            if (p_node.nodeType != 1) {\n                if (p_node.nodeType == 3) {\n                    return this.isInvalidNode(p_node.parentNode);\n                } else {\n                    return true;\n                }\n            }\n\n            var attr;\n            //todo is this needed\n            //attr = this.rw_getAttribute(p_node, RWTH_SKIP_CONTINUOUS);\n            //        if(attr != null && false)//SSDAT.controlData.bIgnoreSkipSection)\n            //        {\n            //            return true;\n            //        }\n\n            //Some users may wish to cache even hidden text, but typically should ignore hidden items.\n            //todo is this needed\n            if (true) //&& g_bIgnoreHidden)\n                {\n                    // need to use computed style rather than normal style as css not taken into account otherwise\n                    var compStyle = this.getComputedStyle(p_node);\n                    if (compStyle != null) {\n                        if (compStyle.visibility == \"hidden\" || compStyle.display == \"none\") {\n                            return true;\n                        }\n                    }\n                }\n\n            var strName = p_node.tagName.toLowerCase();\n\n            return strName == \"link\" || strName == \"area\" || strName == \"script\" || strName == \"noscript\" || strName == \"annotation\" || strName == \"style\" || strName == \"!--\" || strName == \"title\" || strName == \"html:script\"; // last is from firebug\n        }\n    }, {\n        key: 'getComputedStyle',\n\n\n        /**\n         * Use this to get the computed style, the manor differs between IE and others.\n         * @param p_elem\n         */\n        value: function getComputedStyle(p_elem) {\n            if (p_elem == null) {\n                return null;\n            }\n\n            if (p_elem.nodeType == 3) {\n                p_elem = p_elem.parentNode;\n                if (p_elem == null) {\n                    return null;\n                }\n            }\n\n            //        if(SSDOM.bIEOld)\n            //        {\n            //            return p_elem.currentStyle;\n            //        }\n            //        else\n            {\n                return window.getComputedStyle(p_elem, null);\n            }\n        }\n    }, {\n        key: 'isIgnored',\n\n\n        // Check if nested in invalid node\n        // Checks if in ignore attribute node\n        // or if in button when ignore button is on.\n        // Addition added for 'allow'  also for default case to always ignore unless allow.\n        value: function isIgnored(p_node) {\n            var attribute = new _Attribute.Attribute();\n            //todo is this needed\n            //        if(SSDOM.bOverrideIgnore)\n            //        {\n            //            return false;\n            //        }\n\n            var bDefault = false; //SpeechStream.tools.getPageControl().isIgnorePageDefault();\n\n            if (p_node != null && p_node.nodeType == 3) {\n                p_node = p_node.parentNode;\n            }\n\n            if (p_node == null) {\n                return true;\n            }\n\n            // note this searches for base match of ignore, plus ignore with prefix.\n\n            var strIgnoreAttr = \"ignore\"; // SSDAT.getAttributeData().IGNORE_ATTR;\n            var strAllowAttr = \"allow\"; //SSDAT.getAttributeData().ALLOW_ATTR;\n\n            var bod = p_node.ownerDocument.body;\n\n            var tmpNode = p_node;\n            while (tmpNode != null && tmpNode.nodeType == 1) {\n                if (attribute.rw_getAttribute(tmpNode, strIgnoreAttr) != null) {\n                    return true;\n                }\n                if (attribute.rw_getAttribute(tmpNode, strAllowAttr) != null) {\n                    return false;\n                }\n                //todo is this needed if(g_bIgnoreButtons)\n                {\n                    if (tmpNode.tagName.toLowerCase() == \"button\") {\n                        return true;\n                    }\n                }\n                if (tmpNode == bod) {\n                    break;\n                }\n                tmpNode = tmpNode.parentNode;\n            }\n            return bDefault;\n        }\n    }, {\n        key: 'allTextFromNodeTH',\n\n\n        /* Returns text from passed node\n         This only gives text from text nodes and ignores other types.\n         Assumes all text is to be included, whitespace for padding between nodes would be included, so\n         only use this method when sure that will not be an issue. */\n        value: function allTextFromNodeTH(aNode) {\n            var txt = \"\";\n            if (aNode.nodeType == 3) {\n                txt = aNode.nodeValue;\n            } else if (aNode.nodeType == 1) {\n                var aChild = aNode.firstChild;\n                while (aChild != null) {\n                    if (aChild.nodeType == 3) {\n                        txt += aChild.nodeValue;\n                    } else if (aChild.nodeType == 1) {\n                        txt += this.allTextFromNodeTH(aChild);\n                    }\n                    aChild = aChild.nextSibling;\n                }\n            }\n            return txt;\n        }\n    }, {\n        key: 'mergeTextNodes',\n\n        /*Merges text nodes around passed node.\n         i.e.\n         <span><TextNode textContent=\"aaa\"><TextNode textContent=\"bbb\"></span>\n          becomes\n         <span><TextNode textContent=\"aaabbb\"></span>\n          Returns the resulting text node. This will be the original node if it is unchanged.\n          */\n        value: function mergeTextNodes(p_node) {\n            if (p_node == null) {\n                return p_node;\n            }\n\n            var parNode = p_node.parentNode;\n\n            if (parNode != null && p_node.nodeType == 3) {\n                var doc = p_node.ownerDocument;\n                while (p_node.previousSibling != null && p_node.previousSibling.nodeType == 3) {\n                    var txt = p_node.previousSibling.nodeValue + p_node.nodeValue;\n                    var txtNode = doc.createTextNode(txt);\n                    parNode.removeChild(p_node.previousSibling);\n                    parNode.replaceChild(txtNode, p_node);\n                    p_node = txtNode;\n                }\n                while (p_node.nextSibling != null && p_node.nextSibling.nodeType == 3) {\n                    var txt = p_node.nodeValue + p_node.nextSibling.nodeValue;\n                    var txtNode = doc.createTextNode(txt);\n                    parNode.removeChild(p_node.nextSibling);\n                    parNode.replaceChild(txtNode, p_node);\n                    p_node = txtNode;\n                }\n            }\n            return p_node;\n        }\n    }, {\n        key: 'rw_reduceSelectionForNonSpeechChar',\n\n\n        /**\n         * Reduce selection for non speech characters.\n         *\n         */\n        value: function rw_reduceSelectionForNonSpeechChar(p_caretRange) {\n            var domNav = new _DomNavigation.DomNavigation();\n            var bChanged = false;\n            var rightNode = p_caretRange.rightCaret.node;\n            var nRightOffset = p_caretRange.rightCaret.offset;\n            var leftNode = p_caretRange.leftCaret.node;\n            var nLeftOffset = p_caretRange.leftCaret.offset;\n\n            try {\n                var tmpNode;\n                var tmpChar;\n\n                if (!p_caretRange.rightCaret.isSpecialCase()) {\n                    var rightText = rightNode.nodeValue;\n\n                    while (true) {\n                        if (nRightOffset == 0) {\n                            tmpNode = domNav.getPreviousTextNode(rightNode, false, leftNode);\n                            if (tmpNode == null) {\n                                // don't move any further\n                                break;\n                            }\n\n                            if (tmpNode.nodeType == 1) {\n                                // move to image then don't move any further\n                                rightNode = tmpNode;\n                                nRightOffset = 0;\n                                bChanged = true;\n                                break;\n                            }\n\n                            rightNode = tmpNode;\n                            rightText = rightNode.nodeValue;\n                            nRightOffset = rightText.length;\n                            bChanged = true;\n                        }\n\n                        if (rightNode == leftNode && nRightOffset == nLeftOffset) {\n                            // right reduced to reach left point.\n                            break;\n                        }\n\n                        if (nRightOffset > 0) {\n                            tmpChar = rightText.charAt(nRightOffset - 1);\n\n                            // if whitespace\n                            if (this.rw_isWhiteSpace(tmpChar)) {\n                                --nRightOffset;\n                                bChanged = true;\n                            } else {\n                                break;\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n\n                if (!p_caretRange.leftCaret.isSpecialCase()) {\n                    var leftText = leftNode.nodeValue;\n\n                    var nLen = leftText.length;\n                    while (true) {\n                        if (nLeftOffset == nLen) {\n                            tmpNode = domNav.getNextTextNode(leftNode, false, rightNode);\n                            if (tmpNode == null) {\n                                // don't move any further\n                                break;\n                            }\n\n                            if (tmpNode.nodeType == 1) {\n                                // move to image then don't move any further\n                                leftNode = tmpNode;\n                                nLeftOffset = 0;\n                                nLen = 0;\n                                bChanged = true;\n                                break;\n                            }\n\n                            leftNode = tmpNode;\n                            leftText = leftNode.nodeValue;\n                            nLeftOffset = 0;\n                            nLen = leftText.length;\n                            bChanged = true;\n                        }\n\n                        if (rightNode == leftNode && nRightOffset == nLeftOffset) {\n                            // left reduced to reach right point.\n                            break;\n                        }\n\n                        if (nLeftOffset < nLen) {\n                            tmpChar = leftText.charAt(nLeftOffset);\n\n                            // if whitespace\n                            if (this.rw_isWhiteSpace(tmpChar)) {\n                                ++nLeftOffset;\n                                bChanged = true;\n                            } else {\n                                break;\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            } catch (err) {\n                console.log(err);\n            }\n\n            if (!bChanged) {\n                return p_caretRange;\n            } else {\n                return new _THCaretRange.THCaretRange(new _THCaret.THCaret(leftNode, nLeftOffset, true), new _THCaret.THCaret(rightNode, nRightOffset, false));\n            }\n        }\n\n        // returns true if whitespace, should pass single character only to this\n\n    }, {\n        key: 'rw_isWhiteSpace',\n        value: function rw_isWhiteSpace(p_char) {\n            return p_char.search(/[\\s\\xa0]/) > -1;\n        }\n\n        //todo move this to right class\n        /* Returns THCaretRange for the first sentence in the page for a given body\n         */\n\n    }, {\n        key: 'getSentenceFromPointByLang',\n        value: function getSentenceFromPointByLang(p_thCaret) {\n            var domSent = new _DomSentences.DomSentences();\n            var rightCaret = domSent.getSentenceBreakToRight(p_thCaret);\n\n            // check if language changed over move\n            //var strVoice = rw_getVoiceSetForNode(p_thCaret.node);\n            //        var newRightCaret = rw_checkForVoiceChange(p_thCaret.node, rightCaret.node, strVoice);\n            //        if(newRightCaret != null)\n            //        {\n            //            rightCaret = newRightCaret;\n            //        }\n\n            // then need to check that no language changes between left and right, could be multiple changes\n            var leftCaret = domSent.getSentenceBreakToLeft(rightCaret);\n\n            //        strVoice = rw_getVoiceSetForNode(leftCaret.node);\n            //        var newLeftCaret = rw_checkForVoiceChangeRightToLeft(leftCaret.node, rightCaret.node, strVoice);\n            //        if(newLeftCaret != null)\n            //        {\n            //            leftCaret = newLeftCaret;\n            //        }\n            //\n            //        if(leftCaret == null || rightCaret == null)\n            //        {\n            //            return null;\n            //        }\n            var caretRange = new _THCaretRange.THCaretRange();\n            caretRange.setCaretRange(leftCaret, rightCaret);\n\n            return caretRange;\n        }\n    }, {\n        key: 'isSpecialCaseNested',\n\n\n        /**\n         * Check if is special or nested in special case.\n         * @param p_node\n         * @returns boolean\n         */\n        value: function isSpecialCaseNested(p_node) {\n            if (p_node != null) {\n                var bod = this.getBody(p_node);\n                var tmpNode = p_node;\n                while (tmpNode != null && tmpNode != bod) {\n                    if (this.isSpecialCase(tmpNode)) {\n                        return true;\n                    }\n                    tmpNode = tmpNode.parentNode;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'rw_isTextChar',\n\n\n        /*Check for text character as oppossed to whitespace or symbol.  Used to\n         check if character surrounding . makes the . part of the word rather than sentence break,\n         hence @ and _ included here.\n         check if ascii code if for letter digit or @  _ `\n         @ 0-9 a-z A-Z _ `\n         (note inlcude ` and not ' as can't include ' as would then fail on sentence inside single quotes, and ` doesn't really need to be here but when including _ easier to include it than not to.)\n         */\n        value: function rw_isTextChar(p_nCode) {\n            return p_nCode > 47 && p_nCode < 58 || p_nCode > 63 && p_nCode < 91 || p_nCode > 94 && p_nCode < 123;\n        }\n\n        /**This function determines whether the full stop is sentence break or not.\n         Check if followed by letter or number\n         or if is abbreviation that we recognise.\n         Can loop back on itself to check previous node, but in this case p_node is null and just checking previous text for dr etc.\n          * @param p_txt\n         * @param p_nPos Position in node that is full stop (or !?)\n         * @param p_node\n         */\n\n    }, {\n        key: 'rw_isFullStop',\n        value: function rw_isFullStop(p_txt, p_nPos, p_node) {\n            var domNav = new _DomNavigation.DomNavigation();\n            var bFS = true;\n            var nLen = p_txt.length;\n\n            // check if next char a letter or number\n            if (nLen > p_nPos + 1) {\n                var nextChar = p_txt.charCodeAt(p_nPos + 1);\n\n                if (this.rw_isTextChar(nextChar)) {\n                    // do not need to split at this point\n                    // look to next point\n                    bFS = false;\n                }\n                //todo maths\n                //            // check for !=\n                //            if(g_bMathsSymbols && nextChar == 61)\n                //            {   // next char is =\n                //                if(rw_mathsSymbolCheck(\"!=\"))\n                //                {\n                //                    // check if current is \"!\"\n                //                    if(p_node != null && p_node.nodeValue.charAt(p_nPos) == '!')\n                //                    {\n                //                        bFS = false;\n                //                    }\n                //                }\n                //            }\n            }\n\n            if (bFS) {\n                // if at this point the original was something other than . such as ! ?  then just return true;\n                if (p_node != null && p_node.nodeValue.charAt(p_nPos) != '.') {\n                    return true;\n                }\n            }\n\n            if (bFS) {\n                if (p_nPos > 1) {\n                    // check for Dr etc.\n                    var str2 = p_txt.substring(p_nPos - 2, p_nPos);\n\n                    if ((str2.charAt(0) == ' ' || str2.charAt(0) == '\\n' || str2.charAt(0) == '\\r' || str2.charAt(0) == '\\t') && str2.charCodeAt(1) > 63 && str2.charCodeAt(1) < 91) {\n                        // Is an initial i.e.  Mr. S. McWilliams this will stop breaks at the S.\n                        // Will get some miss hits on this but considered more important to catch this case than\n                        // the occassional merged sentences that it will cause.\n                        bFS = false;\n                    } else if (str2.charAt(0) == '.' && this.rw_isTextChar(str2.charCodeAt(1))) {\n                        // is .x. with x being any text char.  Most likely this is part of an acronym\n                        bFS = false;\n                    } else {\n                        if (str2 == \"Dr\" || str2 == \"Mr\" || str2 == \"Ms\" || str2 == \"Av\" || str2 == \"St\" || str2 == \"eg\") {\n                            bFS = false;\n                        } else if (p_nPos > 2) {\n                            var str3 = p_txt.substring(p_nPos - 3, p_nPos);\n                            if (str3 == \"Mrs\" || str3 == \"etc\" || str3 == \"i.e\" || str3 == \"P.O\" || str3 == \"PhD\") {\n                                bFS = false;\n                            } else if (p_nPos > 3) {\n                                var str4 = p_txt.substring(p_nPos - 4, p_nPos);\n                                if (str4 == \"Ph.D\") {\n                                    bFS = false;\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    // first char in txt.\n                    try {\n                        if (p_node != null && p_nPos == 0) {\n                            // get last text node of any kind, but not past any breaks\n                            var tmpNode = domNav.getPreviousTextNode(p_node, true, null);\n                            if (tmpNode != null && tmpNode.nodeType == 3 && tmpNode != p_node) {\n                                //noinspection RedundantIfStatementJS\n                                if (!this.rw_isFullStop(tmpNode.nodeValue + p_txt, tmpNode.nodeValue.length, null)) {\n                                    return false;\n                                } else {\n                                    return true;\n                                }\n                            }\n                        }\n                    } catch (err) {}\n                }\n            }\n\n            var eba_abbr_array = null;\n            if (bFS && eba_abbr_array != null && (typeof eba_abbr_array === 'undefined' ? 'undefined' : _typeof(eba_abbr_array)) == \"object\" && typeof eba_abbr_array.length == \"number\") {\n                var nItems = eba_abbr_array.length;\n                var i;\n                var strAbbr;\n                for (i = 0; i < nItems; i++) {\n                    strAbbr = eba_abbr_array[i];\n                    if (typeof strAbbr == \"string\") {\n                        if (p_nPos - strAbbr.length > -1) {\n                            if (p_txt.substring(p_nPos - strAbbr.length, p_nPos) == strAbbr) {\n                                bFS = false;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return bFS;\n        }\n\n        /*\n         This determines if there is speakable text in the range.  Returns true as soon as match found\n         saves processing whole range.<br>\n         takes p_thCaretRange.\n         */\n\n    }, {\n        key: 'rw_caretRangeIsSpeakable',\n        value: function rw_caretRangeIsSpeakable(p_thCaretRange) {\n            var domNav = new _DomNavigation.DomNavigation();\n            try {\n                if (p_thCaretRange == null || p_thCaretRange.leftCaret == null || p_thCaretRange.rightCaret == null) {\n                    return false;\n                }\n\n                // check if hidden\n                if (this.rw_checkForHiddenParent(p_thCaretRange.leftCaret.node)) {\n                    return false;\n                }\n\n                var leftCaret = p_thCaretRange.leftCaret;\n                var rightCaret = p_thCaretRange.rightCaret;\n\n                var leftNode = leftCaret.node;\n                var rightNode = rightCaret.node;\n\n                var bInitialLoop = true;\n                var bSpecial = false;\n                var curNode = leftNode;\n                var txt = \"\";\n                while (curNode != null) {\n                    bSpecial = this.isSpecialCase(curNode);\n\n                    //                todo if(SpeechStream.pauseHandler.isPauseElement(curNode))\n                    //                {\n                    //                    bSpecial = true;\n                    //                }\n\n                    if (bSpecial || curNode.nodeType == 3) {\n                        var tmp = domNav.getTextFromNode(curNode);\n                        if (tmp != null && tmp != \"\") {\n                            if (!bSpecial) {\n                                if (curNode == rightNode && rightCaret.offset > -1) {\n                                    tmp = tmp.substring(0, rightCaret.offset);\n                                }\n                                if (curNode == leftNode && leftCaret.offset > 0) {\n                                    tmp = tmp.substring(leftCaret.offset);\n                                }\n                            }\n\n                            if (this.rw_isWordSpeakable(tmp)) {\n                                return true;\n                            }\n                        }\n                    }\n\n                    if (bSpecial) {\n                        curNode = domNav.getNextNodeIgnoreChildren(curNode, false, rightNode);\n                    } else {\n                        if (bInitialLoop) {\n                            curNode = domNav.getNextNodeAllowMoveToChild(curNode, true, rightNode);\n                        } else {\n                            curNode = domNav.getNextNode(curNode, false, rightNode);\n                        }\n                    }\n                    bInitialLoop = false;\n                }\n            } catch (err) {\n                // console.log(err);\n            }\n\n            return false;\n        }\n\n        /**\n         * A play point could be nested inside a point in the page that is hidden but that the browser does not report as hidden.\n         * i.e. if a higher element is set to display none in css then nested elements do not report this even through\n         * computed style.  (Sounds like browser bug but exists across browsers so maybe deliberate for some reason.)\n         * Need to check computed style on all parents as well\n         *\n         * @param p_node start point\n         * returns true for hidden found, false otherwise.\n         */\n\n    }, {\n        key: 'rw_checkForHiddenParent',\n        value: function rw_checkForHiddenParent(p_node) {\n            try {\n                // Check if any parent is display none.\n                var computedStyle = this.getComputedStyle(p_node);\n                if (computedStyle != null && (computedStyle.display == \"none\" || computedStyle.visibility == \"hidden\")) {\n                    return true;\n                } else {\n                    var tmpNode = p_node;\n                    var bod = tmpNode.ownerDocument.body;\n                    while (tmpNode != bod) {\n                        tmpNode = tmpNode.parentNode;\n                        if (this.getComputedStyle(tmpNode).display == \"none\") {\n                            return true;\n                        }\n                    }\n                }\n            } catch (e) {/**/}\n            return false;\n        }\n        /* Returns the THDomRefPt to the parent that contains the target node and\n         is not likely to be removed by rwonline bar.  i.e. skips element added\n         for speech and highlighting as can be removed at any time.\n         If p_node is an element rather than a text node the offset is used directly, if dont\n         want it to go down to text when resolving it pass a negative number\n         */\n\n    }, {\n        key: 'rw_getRefPt',\n        value: function rw_getRefPt(p_node, p_nOffset) {\n            var attribute = new _Attribute.Attribute();\n            var RWTH_GENERATED = \"rwTHgen\" + \"\";\n            try {\n                // if text node want ref to parent with offset to get to right point\n                // if passed element want direct ref to it and offset is irrelevant\n                if (p_node == null) {\n                    return null;\n                }\n\n                if (p_node.nodeType == 1 || p_node.nodeType == 3) {\n                    // check if text is inside special case\n\n                    var tmpPar = this.checkForSpecialParent(p_node);\n                    if (tmpPar != null) {\n                        // is in special case so need to extend range to include whole item\n                        return new _THDomRefPt.THDomRefPt(this.getPositionInDom(tmpPar), p_nOffset);\n                    }\n\n                    // get offset of passed node\n                    var nOffset;\n\n                    var theParent;\n\n                    if (p_node.nodeType == 1) {\n                        nOffset = 0;\n                        theParent = p_node;\n                    } else {\n                        // causes a problem in tinymce, not sure why this is there, but been long time so risk of some\n                        // bizarre side affect here.\n                        //todo check how this affects sticky notes.\n                        //                // special check for selecting node where is in whitespace only element, might only exist on\n                        //                // firefox\n                        //                if(p_node.nodeValue.trimTH().length == 0)\n                        //                {\n                        //                   p_nOffset = 0;\n                        //                }\n\n                        nOffset = this.rw_getNodeOffset(p_node);\n                        theParent = p_node.parentNode;\n                    }\n\n                    var attr = attribute.rw_getAttribute(theParent, \"rwstate\");\n                    var thgenAttr = attribute.rw_getAttribute(theParent, RWTH_GENERATED);\n                    while (attr != null && attr.length > 0 || thgenAttr != null) {\n                        // It is a rwonline added element move up again ( ss sp or csp)\n                        // or is autogenerate span tag for split text node\n                        // or if font element as this added by IE for highlighting\n                        nOffset += this.rw_getNodeOffset(theParent);\n                        theParent = theParent.parentNode;\n                        attr = attribute.rw_getAttribute(theParent, \"rwstate\");\n                        thgenAttr = attribute.rw_getAttribute(theParent, RWTH_GENERATED);\n                    }\n                    if (p_nOffset == -1) {\n                        // case of text node in a special case (abbr)\n                        nOffset = -1;\n                    }\n                    return new _THDomRefPt.THDomRefPt(this.getPositionInDom(theParent), nOffset + p_nOffset);\n                } else {\n                    return null;\n                }\n            } catch (ignore) {\n                // likely invalid node passed giving null parent\n                return null;\n            }\n        }\n\n        // Get the text offset of the node from all text contained by the parent.\n\n    }, {\n        key: 'rw_getNodeOffset',\n        value: function rw_getNodeOffset(p_node) {\n            if (p_node == null) {\n                return 0;\n            }\n            var nOffset = 0;\n            var leftNode = p_node.previousSibling;\n            if (leftNode != null) {\n                nOffset = this.rw_getNodeOffsetImpl(leftNode);\n            }\n            return nOffset;\n        }\n    }, {\n        key: 'getPositionInDom',\n        value: function getPositionInDom(p_theNode) {\n            var attribute = new _Attribute.Attribute();\n            var strPos = \"\";\n            var nLeftCount = 0;\n            var prefix = \"\";\n            if (p_theNode != null && p_theNode.ownerDocument != null) {\n                var bWasLastText = false;\n                var bIsText = false;\n                var bod = p_theNode.ownerDocument.body;\n                while (p_theNode != null && p_theNode != bod) {\n\n                    if (this.isSpecialCase(p_theNode)) {\n                        // reset path so directs straight to this\n                        strPos = \"\";\n                    }\n                    bWasLastText = p_theNode.nodeType == 3 || p_theNode.nodeType == 1 && p_theNode.tagName.toLowerCase() == Constants.HIGHLIGHT_TAG && attribute.rw_getAttribute(p_theNode, \"rwstate\") != null; // set true if text for orig.\n                    var aNode = p_theNode.previousSibling;\n                    while (aNode != null) {\n                        bIsText = aNode.nodeType == 3 || aNode.nodeType == 1 && aNode.tagName.toLowerCase() == Constants.HIGHLIGHT_TAG && attribute.rw_getAttribute(aNode, \"rwstate\") != null; // set for current node\n                        if (bWasLastText && bIsText) {// dont increment for two text nodes together\n                        } else {\n                            ++nLeftCount;\n                        }\n                        aNode = aNode.previousSibling;\n                        bWasLastText = bIsText;\n                    }\n                    strPos = strPos + nLeftCount + \"~\";\n                    nLeftCount = 0;\n                    p_theNode = p_theNode.parentNode;\n                    if (p_theNode != null && p_theNode.getAttribute != null && p_theNode.tagName != null) {\n                        var ttmp = attribute.rw_getAttribute(p_theNode, \"chunk\");\n                        if (p_theNode.tagName.toLowerCase() == \"span\" && ttmp == \"1\") {\n                            var innerPos = this.getPositionInDom(p_theNode);\n                            prefix = \"#^th*\" + innerPos + \"#^th*\";\n                        }\n                    }\n                }\n            }\n            return prefix + strPos;\n        }\n    }, {\n        key: 'rw_getBreakInCurrentWord',\n\n\n        // return pos of word break in text\n        value: function rw_getBreakInCurrentWord(p_txt) {\n            // look for non character or digit or _\n            if (p_txt == null || p_txt.length == 0) {\n                return -1;\n            }\n\n            return p_txt.search(\"[\" + String.fromCharCode(8212) + \"\\\\s\\\"]\");\n        }\n\n        //check if ascii code if for letter\n\n    }, {\n        key: 'rw_isLetter',\n        value: function rw_isLetter(p_nCode) {\n            return p_nCode > 64 && p_nCode < 91 || p_nCode > 96 && p_nCode < 123;\n        }\n\n        // Get the text offset of the node from all text contained by the parent.\n\n    }, {\n        key: 'rw_getNodeOffsetImpl',\n        value: function rw_getNodeOffsetImpl(p_node) {\n            var nOffset = 0;\n            var leftNode = p_node;\n            var tmpTxt;\n            while (leftNode != null) {\n                if (leftNode.nodeType == 3 && !this.isIgnored(leftNode)) {\n                    tmpTxt = leftNode.nodeValue;\n                    nOffset += tmpTxt.length;\n                } else if (leftNode.nodeType == 1) {\n                    if (!this.isInvalidNode(leftNode)) {\n                        if (this.isSpecialCase(leftNode)) {\n                            nOffset += 1;\n                        } else if (leftNode.tagName.toLowerCase() != \"textarea\") {\n                            nOffset += this.rw_getNodeOffsetImpl(leftNode.lastChild);\n                        } else {\n                            nOffset += 1;\n                        }\n                    }\n                } // if other non element type do nothing\n                leftNode = leftNode.previousSibling;\n            }\n            return nOffset;\n        }\n    }, {\n        key: 'rw_getCaretFromRefPt',\n        value: function rw_getCaretFromRefPt(p_body, p_refPt) {\n            return this.getCaretFromDomPosition(p_body, p_refPt.path, p_refPt.offset, true);\n        }\n\n        /*This uses a position in the dom to get the text node referred to.\n         The offset is used to handle case were the target node has been split and\n         the target word is not in the first part.  Set to p_nPos to 0 to always get the\n         first text node regardless of split.  Set p_nPos to -1 to get the target node\n         even if it is now an element and not a text node.\n         <p>\n         NB count multiple text nodes together as single item.  Text could be split\n         since the count made.  Also to match this when counting take adjacent text nodes as one.\n         <p>\n         For special case, directs to element node not text node, here need to take either start or end of contained text based on p_bForwardBias\n         <p>\n         p_theBody to body containing the node that path is referenced from\n         p_strPath the path from the body\n         p_nPos the offset\n         p_bForwardBias set true if caret is to refer to character after itself, false if is to refer to character before it\n         <p> Returns THCaret object containing the node and offset.\n         */\n\n    }, {\n        key: 'getCaretFromDomPosition',\n        value: function getCaretFromDomPosition(p_theBody, p_strPath, p_nPos, p_bForwardBias, p_bForceSpecial) {\n            var domNav = new _DomNavigation.DomNavigation();\n            if (typeof p_bForceSpecial == \"undefined\") {\n                p_bForceSpecial = false;\n            }\n\n            try {\n                if (p_theBody == null) {\n                    return null;\n                }\n                // Get the node from the position string\n                var theNode = domNav.getNodeFromPosition(p_theBody, p_strPath);\n\n                // First check if it is a special case\n\n                if (p_bForceSpecial) {\n                    var tmpCaret = new _THCaret.THCaret(theNode, 0, p_bForwardBias);\n                    tmpCaret.setSpecialCase(true);\n                    return tmpCaret;\n                }\n\n                var tmpNode = this.checkForSpecialParent(theNode);\n\n                if (tmpNode != null) {\n                    theNode = tmpNode;\n\n                    //if not a highlightable one should just return the item\n                    if (this.isSpecialCaseHighlightable(tmpNode)) {\n                        if (p_bForwardBias) {\n                            // get start\n                            var startNode = domNav.getFirstChildTextNode(theNode, false);\n                            if (startNode != null) {\n                                return new _THCaret.THCaret(startNode, 0, p_bForwardBias);\n                            } else {\n                                // treat as non highlightable\n                                return new _THCaret.THCaret(theNode, 0, p_bForwardBias);\n                            }\n                        } else {\n                            //get end\n                            var endNode = domNav.getLastChildTextNode(theNode, false);\n                            if (endNode != null) {\n                                if (endNode.nodeType == 3) {\n                                    return new _THCaret.THCaret(endNode, endNode.length, p_bForwardBias);\n                                } else {\n                                    // is img with msg, not highlightable\n                                    return new _THCaret.THCaret(endNode, 0, p_bForwardBias);\n                                }\n                            } else {\n                                // treat as non highlightable\n                                return new _THCaret.THCaret(theNode, 0, p_bForwardBias);\n                            }\n                        }\n                    } else {\n                        return new _THCaret.THCaret(tmpNode, 0, p_bForwardBias);\n                    }\n                }\n\n                var nOffset = 0;\n                if (!p_bForwardBias) {\n                    // Looking for caret position just before the p_nPos point so need to be comparing to +1 position\n                    ++nOffset;\n                }\n\n                if (p_nPos > -1) {\n                    // found node, but may have been subsequently split, so need to check passed position\n                    // is inside it\n                    // Ensure doesnt go past parent\n                    if (theNode == null) {\n                        //error\n                        return null;\n                    }\n                    var bMatch = false;\n\n                    var endNode = theNode.parentNode;\n                    var lastSafeNode = theNode;\n                    var tmpTxt;\n\n                    while (!bMatch) {\n                        if (theNode.nodeType == 3) {\n                            tmpTxt = theNode.nodeValue;\n                            //console.log(\"check if in \" + theNode.nodeValue + \"  where offset is \" + nOffset + \" and pos \" + p_nPos);\n                            if (p_nPos < nOffset + tmpTxt.length) {\n                                // found\n                                //console.log(\"yes\");\n                                bMatch = true;\n                                break;\n                            }\n\n                            lastSafeNode = theNode;\n                            nOffset += theNode.nodeValue.length;\n\n                            theNode = domNav.getNextNode(theNode, false, endNode);\n                        } else if (theNode.nodeType == 1) {\n                            // check if special case of node, i.e. element that can be spoken (img with msg)\n                            tmpNode = this.checkForSpecialParent(theNode);\n                            if (tmpNode != null) {\n                                theNode = tmpNode;\n                                // might have found target\n                                // ensure that the offset should not take it on past this\n                                // if p_nPos matches nOffset then match\n                                var nDiff = p_nPos - nOffset;\n\n                                if (nDiff > 0) {\n                                    // need to carry on\n                                    nOffset += 1;\n                                } else {\n                                    bMatch = true;\n                                    break;\n                                }\n\n                                // ignore children so do not include text of special node and also include the +1 here\n                                theNode = domNav.getNextNodeIgnoreChildren(theNode, false, endNode);\n                            } else {\n                                theNode = domNav.getNextNode(theNode, false, endNode);\n                            }\n                        }\n\n                        //console.log(theNode + \" \" + theNode.tagName + \" \" + theNode.nodeValue);\n                        if (theNode == null || theNode == endNode) {\n                            // alert(\" \" + p_strPath + \" <=> \" + p_nPos);\n                            //shouldnt really happen, but dont always have valid data so this catches the dodgy case\n                            // can happen due to offset calculation being wrong, some elements can give unexpected offset,\n                            // as do not know exactly how the different browsers work it out for themselves.\n                            //In this case use last safe offset, most likely work or at least highlight most of word\n                            if (lastSafeNode != null) {\n                                theNode = lastSafeNode;\n                                if (theNode.nodeType == 3) {\n                                    // The value of nOffset set below is purely done to cancel out in\n                                    // calculation further down for new THCaret\n                                    nOffset = p_nPos - theNode.nodeValue.length;\n                                } else {\n                                    // such as img\n                                    nOffset = 0;\n                                }\n\n                                if (!p_bForwardBias) {\n                                    ++nOffset;\n                                }\n                                break;\n                            } else {\n                                return null;\n                            }\n                        }\n                    }\n\n                    //console.log(\"theNode \" + theNode + \"   \" + theNode.nodeValue + \"  from \" + p_strPath);\n                    if (p_bForwardBias) {\n                        return new _THCaret.THCaret(theNode, p_nPos - nOffset, p_bForwardBias);\n                    } else {\n                        // remember to remove the extra part added on to stop going to next node.\n                        return new _THCaret.THCaret(theNode, p_nPos - (nOffset - 1), p_bForwardBias);\n                    }\n                } else {\n                    return new _THCaret.THCaret(theNode, p_nPos, p_bForwardBias);\n                }\n            } catch (err) {\n                // Likely that path is no longer valid\n                // console.log(\"getCaretFromDomPosition error: \" + err);\n\n                return null;\n            }\n        }\n    }, {\n        key: 'getNodesOverRange',\n\n\n        /**\n         * Get all valid nodes over a range (inclusive).  This will skip invalid and ignored nodes.\n         * It will go over range regardless of sentence breaks.\n         *\n         * If no valid nodes list is empty.\n         * @param p_startNode\n         * @param p_endNode\n         * @returns {Array}\n         */\n        value: function getNodesOverRange(p_startNode, p_endNode) {\n            var domNav = new _DomNavigation.DomNavigation();\n            var resultList = [];\n\n            if (p_startNode == null || p_endNode == null) {\n                return resultList;\n            }\n\n            var curNode = p_startNode;\n\n            while (curNode) {\n                if (this.isInvalidNode(curNode)) {\n                    curNode = domNav.getActualNextNodeIgnoreChildren(curNode, p_endNode);\n                } else {\n                    if (!this.isIgnored(curNode)) {\n                        resultList.push(curNode);\n                    }\n                    curNode = domNav.getActualNextNode(curNode, p_endNode);\n                }\n            }\n\n            return resultList;\n        }\n    }, {\n        key: 'getWindow',\n\n\n        //get window from node\n        value: function getWindow(p_node) {\n            try {\n                if (p_node == null) {\n                    return window;\n                }\n\n                if (top.frames.length === 0) {\n                    return window;\n                } else {\n                    // check frames\n                    var curBody = p_node.ownerDocument.body;\n                    var activeBody = window.document.body;\n                    if (curBody === activeBody) {\n                        // Same window that has the toolbar.\n                        return window;\n                    }\n\n                    //                if(!g_bIgnoreFrames) todo is this needed\n                    {\n                        var i;var nLen = top.frames.length;\n                        for (i = 0; i < nLen; i++) {\n                            // this could error due to cross domain issues.\n                            try {\n                                var tmpBod = top.frames[i].document.body;\n                                if (tmpBod === curBody) {\n                                    return top.frames[i];\n                                }\n                            } catch (e) {\n                                // frames exist with different domain so cannot access.\n                            }\n                        }\n                    }\n                }\n            } catch (err) {}\n            // console.log(\"Error getWindow: \" + err);\n\n\n            //no match default to main window rather than null;\n            return window;\n        }\n    }, {\n        key: 'rw_getTextRangeAsTHRange',\n        value: function rw_getTextRangeAsTHRange(p_body, p_textRange) {\n            var tmpRange = p_textRange.duplicate();\n            tmpRange.collapse(true);\n            var startRefPt = rw_getTextRangeAsRefPtIE(p_body, tmpRange);\n\n            tmpRange = p_textRange.duplicate();\n            tmpRange.collapse(false);\n            var endRefPt = rw_getTextRangeAsRefPtIE(p_body, tmpRange);\n\n            return new _THRange.THRange(p_body, startRefPt, endRefPt);\n        }\n\n        //get as ie textrange object\n\n    }, {\n        key: 'rw_getAsTextRange',\n        value: function rw_getAsTextRange(p_body, p_strLeftPath, p_nLeftOffset, p_strRightPath, p_nRightOffset) {\n            var range = this.getRangeObject(p_body);\n\n            var caretRange = new _THCaretRange.THCaretRange(p_body, p_strLeftPath, -1, p_strRightPath, -1);\n            var leftCaret = caretRange.leftCaret;\n            var rightCaret = caretRange.rightCaret;\n\n            if (leftCaret != null && leftCaret.node != null && rightCaret != null && rightCaret.node != null) {\n                var lNode = leftCaret.node;\n                if (lNode.nodeType == 3) {\n                    var nOffset = this.rw_getNodeOffset(lNode);\n\n                    lNode = lNode.parentNode;\n                    p_nLeftOffset += nOffset;\n                }\n\n                var rNode = rightCaret.node;\n                if (rNode.nodeType == 3) {\n                    var nOffset = this.rw_getNodeOffset(rNode);\n                    rNode = rNode.parentNode;\n                    p_nRightOffset += nOffset;\n                }\n\n                range.moveToElementText(lNode);\n                range.collapse();\n                rw_moveEnd(range, p_nLeftOffset);\n                range.collapse(false);\n                range.select();\n\n                var range2 = this.getRangeObject(p_body);\n                range2.moveToElementText(rNode);\n                range2.collapse();\n                rw_moveEnd(range2, p_nRightOffset);\n                range2.collapse(false);\n\n                range.setEndPoint(\"EndToEnd\", range2);\n            } else {\n                range = null;\n                // console.log(\"Error with rw_getAsTextRange.\");\n            }\n            return range;\n        }\n\n        /*Remove the current selection in the page.*/\n\n    }, {\n        key: 'rw_collapseSelection',\n        value: function rw_collapseSelection() {\n            var sel = this.getSelectionObject();\n            if (sel == null) {\n                return;\n            }\n            if (sel.collapseToStart) {\n                sel.collapseToStart();\n            } else if (sel.execCommand) {\n                sel.execCommand(\"UnSelect\", false, null);\n            }\n        }\n\n        /*This gets the selection object in the page, null if no selection.*/\n\n    }, {\n        key: 'getSelectionObject',\n        value: function getSelectionObject() {\n            var theRange = null;\n            var g_ipadSelectionRange = false;\n            if (window.getSelection) {\n                /*fire fox and safari  ie9*/\n                if (g_ipadSelectionRange != null) {\n                    // workaround for ipad IOS5 bug, loses selection on any action.\n                    //g_ipadSelectionWindow.getSelection().addRange(g_ipadSelectionRange);\n\n                    // additional workaround for ios5 brokeness\n                    return null; // ***  If usage of SSDOM.getSelectionObject changes this might not be suitable, hack based on current toolbar and ios5 brokeness.\n                }\n\n                var tmpSel = window.getSelection();\n                var foundSel = null;\n                if (!tmpSel.isCollapsed) {\n                    foundSel = tmpSel;\n                } else {\n                    tmpSel = this.getFrameSelectionSFF(window);\n                    if (tmpSel.foundSel) {\n                        foundSel = tmpSel.foundSel;\n                    }\n                }\n                if (foundSel == null) {\n                    return null;\n                }\n\n                theRange = foundSel;\n            } else if (document.selection) {\n                /*ie*/\n                var range = document.selection.createRange();\n\n                // check if selection inside a frame\n                if (range.text.length > 0) {\n                    theWindow = window;\n                    theRange = range;\n                } else {\n                    var tmp = this.getFrameSelectionOldIE(window);\n                    if (tmp.theRange) {\n                        theRange = tmp.theRange;\n                    }\n                }\n            }\n\n            return theRange;\n        }\n    }, {\n        key: 'getFrameSelectionOldIE',\n\n\n        // get selection from subframes from start point, not going to top and top might not be accessible or above\n        // toolbar start point.\n        value: function getFrameSelectionOldIE(p_frame) {\n\n            var res = {};\n            var range;\n            var g_bIgnoreFrames = false;\n            // check if selection inside a frame\n            if (!g_bIgnoreFrames && p_frame.frames && p_frame.length > 0) {\n                var i;var nLen = p_frame.length;\n                for (i = 0; i < nLen; i++) {\n                    try {\n                        var tmpFrame = p_frame[i];\n                        range = tmpFrame.document.selection.createRange();\n                        if (range != null && range.text != null && range.text.length > 0) {\n                            res.theWindow = tmpFrame;\n                            res.theRange = range;\n                            break;\n                        } else {\n                            if (tmpFrame.length > 0) {\n                                var tmpRes = this.getFrameSelectionOldIE(tmpFrame);\n                                if (tmpRes.theRange) {\n                                    res = tmpRes;\n                                    break;\n                                }\n                            }\n                        }\n                    } catch (e) {\n                        // frames exist with different domain so cannot access.\n                    }\n                }\n            }\n            return res;\n        }\n    }, {\n        key: 'getFrameSelectionSFF',\n\n\n        // get selection from subframes from start point, not going to top and top might not be accessible or above\n        // toolbar start point.\n        value: function getFrameSelectionSFF(p_frame) {\n            var res = {};\n\n            var tmp = this.getFrameSelection(p_frame);\n            if (tmp != null) {\n                res.theWindow = tmp;\n                res.foundSel = tmp.getSelection();\n            }\n            return res;\n        }\n    }, {\n        key: 'getFrameSelection',\n\n\n        // get selection from subframes from start point, not going to top and top might not be accessible or above\n        // toolbar start point.\n        value: function getFrameSelection(p_frame) {\n            // check if selection inside a frame\n            if (!g_bIgnoreFrames && p_frame.frames && p_frame.length > 0) {\n                var i;var nLen = p_frame.length;\n                for (i = 0; i < nLen; i++) {\n                    try {\n                        // use tmp object as get selection could return null\n                        var tmpObj = p_frame[i].getSelection();\n                        if (tmpObj != null && !tmpObj.isCollapsed) {\n                            return p_frame[i];\n                        } else {\n                            if (p_frame[i].length > 0) {\n                                var tmpRes = this.getFrameSelection(p_frame[i]);\n                                if (tmpRes) {\n                                    return tmpRes;\n                                }\n                            }\n                        }\n                    } catch (e) {\n                        // frames exist with different domain so cannot access.\n                    }\n                }\n            }\n            return null;\n        }\n    }]);\n\n    return SSDOM;\n}();\n\n},{\"src/Constants/Constants\":1,\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/DomNavigation\":3,\"src/SpeechStream/DOM/DomSentences\":4,\"src/SpeechStream/MathJax/MathSpeak\":16,\"src/SpeechStream/THCaret\":27,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/THDomRefPt\":30,\"src/SpeechStream/THRange\":31,\"src/SpeechStream/Utilities/Utilities\":34}],6:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevinml on 26/05/2016.\n */\n\nvar instance = null;\n\nvar EventBus = exports.EventBus = function () {\n    function EventBus() {\n        _classCallCheck(this, EventBus);\n\n        if (!instance) {\n            instance = this;\n        }\n        this.events = new Array();\n\n        return instance;\n    }\n\n    _createClass(EventBus, [{\n        key: \"unSubscribe\",\n        value: function unSubscribe(event, callback) {\n            for (var i = 0; i < this.events.length; i++) {\n                if (this.events[i].event == event && this.events[i].callback == callback) {\n                    this.events.splice(i, 1);\n                }\n            }\n        }\n    }, {\n        key: \"subscribe\",\n        value: function subscribe(event, callback) {\n            this.events.push({ \"event\": event, \"callback\": callback });\n        }\n    }, {\n        key: \"publish\",\n        value: function publish(event, data) {\n\n            for (var i = 0; i < this.events.length; i++) {\n                if (this.events[i].event == event) {\n                    this.events[i].callback(data);\n                }\n            }\n        }\n    }]);\n\n    return EventBus;\n}();\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.HighlightBaseController = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevinml on 03/05/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _THReturnObject = require('src/SpeechStream/THReturnObject');\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _DomNavigation = require('src/SpeechStream/DOM/DomNavigation');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nvar _Constants = require('src/Constants/Constants');\n\nvar Constants = _interopRequireWildcard(_Constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar HighlightBaseController = exports.HighlightBaseController = function () {\n    function HighlightBaseController() {\n        _classCallCheck(this, HighlightBaseController);\n    }\n\n    _createClass(HighlightBaseController, [{\n        key: 'highlightRange',\n        value: function highlightRange() {}\n    }, {\n        key: 'unHighlightRange',\n        value: function unHighlightRange() {}\n\n        /*\n         target node, a text node to give highlight to.\n         p_nStartPt, the offset to start highlight at\n         p_nEndPt, the offset to end highlight at\n         p_state, either ss-study skills sp-speech highglight csp-current word speech highlight.\n         returns object with {Node, offset}*/\n\n    }, {\n        key: 'rw_setNodeBackground',\n        value: function rw_setNodeBackground(p_textNode, p_nStartPt, p_nEndPt, p_state, p_strCol) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            var domNav = new _DomNavigation.DomNavigation();\n            //alert(p_textNode.nodeValue + \" |\" + p_nStartPt + \" | \" + p_nEndPt + \"  | \" + p_state +\" | \" + p_strCol);\n            var res = new _THReturnObject.THReturnObject();\n            res.node = p_textNode;\n            res.offset = p_nStartPt;\n            if (p_textNode.nodeType != 3) {\n                // Check if is special element that can be highlighted\n                if (p_textNode.nodeType == 1 && ssdom.isSpecialCaseHighlightable(p_textNode)) {\n                    if (p_textNode.tagName.toLowerCase() == \"math\") {\n                        var parNode = p_textNode.parentNode;\n                        res = rw_setNodeBackgroundImpl(parNode, p_textNode, p_nStartPt, p_nEndPt, p_state, \"\");\n                    } else if (p_textNode.isMathJax) {\n                        var parNode = p_textNode.parentNode;\n                        res = rw_setNodeBackgroundImpl(parNode, p_textNode, p_nStartPt, p_nEndPt, p_state, \"\");\n                    } else {\n                        //allow.  May contain multiple highlightable text items.\n                        var startTextNode = domNav.getFirstChildTextNode(p_textNode, false);\n                        var endTextNode = domNav.getLastChildTextNode(p_textNode, false);\n\n                        // ensure that this gets valid items.\n                        // Note that if special case Highlightable node contains a special case Highlightable node\n                        //  it will cause error on the page.\n                        if (startTextNode != null && startTextNode.nodeType == 3 && endTextNode != null && endTextNode.nodeType == 3) {\n                            this.rw_setSpeechRangeImpl(startTextNode, 0, endTextNode, endTextNode.nodeValue.length, p_state);\n                            res.node = startTextNode;\n                            res.offset = 0;\n                        } else {// got invalid text from special case so do not highlight.\n                        }\n                    }\n                    return res;\n                } else {\n                    // fail not highlightable\n                    return res;\n                }\n            }\n\n            // check if should highlight\n            // if is text node with only white space and is in a table between <td> elements, do not want to add highlighing.\n            if (p_textNode.nodeType == 3) {\n                var txt = p_textNode.nodeValue;\n                var utilities = new _Utilities.Utilities();\n                txt = utilities.trim(txt);\n                if (txt.length == 0) {\n                    // At some point would want to check for unnecessary white space at any point (though rules of what is actually displayed not clear as not based on a standard but browser dependant),\n                    // but to avoid changing behaviour too much I'm limiting this to tables\n                    var tmpPar = p_textNode.parentNode;\n                    if (tmpPar != null) {\n                        var tmpTxt = utilities.trim(tmpPar.tagName).toLowerCase();\n                        if (tmpTxt == \"tr\" || tmpTxt == \"table\") {\n                            // don't highlight.  (Added for FLVS but issue for any table in FF Safari Chrome)\n                            return res;\n                        }\n                    }\n                }\n            }\n\n            var parNode = p_textNode.parentNode;\n            var parentState = null;\n            if (parNode.tagName.toLowerCase() == Constants.HIGHLIGHT_TAG) {\n                parentState = attribute.rw_getAttribute(parNode, \"rwstate\");\n            }\n\n            // logic based on state type\n            if (p_state == \"spell\") {\n                if (parentState == null || parentState == \"\") {\n                    // add new node to parentNode containing textnode in it\n                    res = this.rw_setNodeBackgroundImpl(parNode, p_textNode, p_nStartPt, p_nEndPt, p_state, p_strCol);\n                } else {\n                    //error, likely inside speech, leave as is\n                    return res;\n                }\n            } else if (p_state == \"hom\") {\n                if (parentState == null || parentState == \"\") {\n                    // add new node to parentNode containing textnode in it\n                    res = this.rw_setNodeBackgroundImpl(parNode, p_textNode, p_nStartPt, p_nEndPt, p_state, p_strCol);\n                } else {\n                    //error, likely inside speech, leave as is\n                    return res;\n                }\n            } else if (p_state == \"grammar\") {\n                if (parentState == null || parentState == \"\") {\n                    // add new node to parentNode containing textnode in it\n                    res = this.rw_setNodeBackgroundImpl(parNode, p_textNode, p_nStartPt, p_nEndPt, p_state, p_strCol);\n                } else {\n                    //error, likely inside speech, leave as is\n                    return res;\n                }\n            } else if (p_state == \"ss\") {\n                if (parentState == null || parentState == \"\") {\n                    // add new node to parentNode containing textnode in it\n                    res = this.rw_setNodeBackgroundImpl(parNode, p_textNode, p_nStartPt, p_nEndPt, p_state, p_strCol);\n                } else if (parentState == \"ss\") {\n                    // currently dont replace or split parent node, just leave as is\n                    return res;\n                } else {\n                    //error, likely inside speech, leave as is\n                    return res;\n                }\n            } else if (p_state == \"sp\") {\n                if (parentState == \"csp\") {\n                    // This should not happen, invalid highlighting\n                    // console.log(\"fail in rw_setNodeBackground setting sp to csp\");\n                    return res;\n                }\n\n                if (parentState == \"sp\") {\n                    // This should not happen, invalid highlighting\n                    // console.log(\"fail in rw_setNodeBackground setting sp to sp\");\n                    return res;\n                }\n\n                // whatever parent is at this point\n                // add new node to parent node containing textnode in it\n                res = this.rw_setNodeBackgroundImpl(parNode, p_textNode, p_nStartPt, p_nEndPt, p_state, \"\");\n            } else if (p_state == \"csp\") {\n                //console.log(\"is csp parentstate\" + parentState + \"  parenttype=\" + parNode.tagName);\n                if (parentState == \"csp\") {\n                    // This should not happen, invalid highlighting\n                    // console.log(\"fail parent is csp for csp\");\n                    return res;\n                }\n\n                if (parentState == \"sp\") {\n                    // add new node to parent node containing textnode in it\n                    res = this.rw_setNodeBackgroundImpl(parNode, p_textNode, p_nStartPt, p_nEndPt, p_state, \"\");\n                } else {//fail\n                }\n            } else {// fail\n                }\n            return res;\n        }\n\n        /*assistance to rw_setNodeBackground\n         this will modify a parent to add appropriate highlighting.   <p>\n         returns {Node, offset}*/\n\n    }, {\n        key: 'rw_setNodeBackgroundImpl',\n        value: function rw_setNodeBackgroundImpl(p_parentNode, p_textNode, p_nStartPt, p_nEndPt, p_state, p_strCol) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            var bSpeech = p_state === \"sp\" || p_state === \"csp\";\n\n            /*if p_nStart and p_nEnd = -1 then act on full node, otherwise need to split to text node text\n             */\n            var tagName = \"\";\n\n            if (p_textNode.nodeType == 1) {\n                tagName = p_textNode.tagName.toLowerCase();\n            }\n\n            if (p_textNode.nodeType == 3 && (p_nEndPt == -1 || p_nEndPt > p_nStartPt) || tagName == \"math\" || p_textNode.isMathJax) {\n                // only act if end after start\n\n                var strCol;\n                if (p_state == \"ss\") {\n                    if (p_strCol == \"strikethrough\") {\n                        strCol = \"text-decoration:line-through\";\n                    } else {\n                        strCol = \"background:\" + p_strCol;\n                    }\n                } else if (p_state == \"sp\") {\n                    strCol = Constants.SPEECH_RANGE_COLOUR;\n                } else if (p_state == \"csp\") {\n                    strCol = Constants.SPEECH_WORD_COLOUR;\n                } else if (p_state == \"spell\") {\n                    // changed to wavey line\n                    // only applies to tiny mce and needs line .thspell {background:url(\"img/wline.gif\") repeat-x bottom left; cursor:default;}\n                    // added to the content.css at \\resources\\files\\tiny_mce\\themes\\advances\\skins\\default\n                    // then wline.gif to the img subfolder\n\n                    // CHANGED FOR TINYMCE V4\n                    // only applies to tiny mce and needs line .thspell {background:url(\"img/wline.gif\") repeat-x bottom left; cursor:default;}\n                    // added to the content.css at \\tiny_mce\\skins\\lightgray\n                    // then wline.gif to the img subfolder\n\n                    strCol = \"\";\n                } else if (p_state == \"hom\") {\n                    // changed to wavey line\n                    strCol = \"\";\n                } else if (p_state == \"grammar\") {\n                    // changed to wavey line\n                    strCol = \"\";\n                } else {\n                    strCol = \"color:#ff000; background:#00ff00\";\n                }\n\n                if (tagName == \"math\" || p_textNode.isMathJax) {\n                    // Not text node, handled separately.\n                    // dont support \"ss\" yet\n                    if (bSpeech) {\n                        this.rw_highlightMathElement(p_textNode, p_state, strCol, true);\n                    }\n                } else {\n                    var nLen = p_textNode.nodeValue.length;\n\n                    //IE9 bug workaround  in IE9 node with just \\n will be removed if given background colour.\n                    if (nLen == 1 && (p_textNode.nodeValue == \"\\n\" || p_textNode.nodeValue == \"\\r\") || nLen == 2 && p_textNode.nodeValue == \"\\r\\n\") {\n                        // return without changing\n                        var res = new _THReturnObject.THReturnObject();\n                        res.node = p_textNode;\n                        if (p_nStartPt < 0) {\n                            res.offset = 0;\n                        } else {\n                            res.offset = p_nStartPt;\n                        }\n                        return res;\n                    }\n\n                    var doc = p_parentNode.ownerDocument;\n                    // Use all to determine if all of the node needs to be highlighted or if it is to be split.\n                    var bAll = false;\n\n                    if (p_nStartPt == -1 && p_nEndPt == -1) {\n                        bAll = true;\n                    } else if (p_nEndPt == -1) {\n                        p_nEndPt = nLen;\n                    }\n\n                    if (p_nStartPt == 0 && p_nEndPt >= nLen) {\n                        bAll = true;\n                    }\n\n                    var tmpEl = doc.createElement(Constants.HIGHLIGHT_TAG);\n\n                    if (p_state == \"spell\") {\n                        rw_setAttribute(tmpEl, \"spellnum\", p_strCol);\n                        if (false /*SSHL.dat.browser.bIE*/) {\n                                tmpEl.setAttribute(\"className\", \"thspell\");\n                                // IE bug.  IE cannot change classes dynamically.  It stores the classname set, but does not\n                                // actually update the page to the styles of the new class.  So pointless and broken class logic\n                                // means extra code needed again to workaround IE flaws.  (Means need to hard code url!)\n                                strCol = \"background:url(\\\"\" + rw_getSwaFileLocation() + \"wline.gif\\\")  repeat-x bottom left\";\n                            } else {\n                            tmpEl.className = \"thspell\";\n                        }\n                    }\n\n                    if (p_state == \"hom\") {\n                        //                   todo var strClass = SpeechStream.highlighter.getHomClass();\n                        //                    rw_setAttribute(tmpEl, \"homnum\", p_strCol);\n                        //                    if (SSHL.dat.browser.bIE) {\n                        //                        tmpEl.setAttribute(\"className\", strClass);\n                        //                        // IE bug.  IE cannot change classes dynamically.  It stores the classname set, but does not\n                        //                        // actually update the page to the styles of the new class.  So pointless and broken class logic\n                        //                        // means extra code needed again to workaround IE flaws.  (Means need to hard code url!)\n                        //                        strCol = \"background:url(\\\"\" + rw_getSwaFileLocation() + \"wlineblue.gif\\\")  repeat-x bottom left\";\n                        //                    }\n                        //                    else {\n                        //                        tmpEl.className = strClass;\n                        //                    }\n                    }\n\n                    if (p_state == \"grammar\") {\n                        var strClass = \"thgrammar\";\n                        rw_setAttribute(tmpEl, \"grammarnum\", p_strCol);\n                        if (false /*SSHL.dat.browser.bIE*/) {\n                                tmpEl.setAttribute(\"className\", \"thgrammar\");\n                                // IE bug.  IE cannot change classes dynamically.  It stores the classname set, but does not\n                                // actually update the page to the styles of the new class.  So pointless and broken class logic\n                                // means extra code needed again to workaround IE flaws.  (Means need to hard code url!)\n                                strCol = \"background:url(\\\"\" + rw_getSwaFileLocation() + \"wlinegreen.gif\\\")  repeat-x bottom left\";\n                            } else {\n                            tmpEl.className = strClass;\n                        }\n                    }\n\n                    if (bAll) {\n                        //                    if(SSHL.dat.browser.bIEOld)\n                        //                    {   //workaround for IE bug of setAttribute not working for style\n                        //                        tmpEl.style.setAttribute(\"cssText\", strCol, 0);          // AS for old browsers only pre html5 not making html5 data- change to this.\n                        //                    }\n                        //                    else\n                        {\n                            tmpEl.setAttribute(\"style\", strCol);\n                        }\n                        attribute.rw_setAttribute(tmpEl, \"rwstate\", p_state);\n                        if (bSpeech) {\n                            attribute.rw_setAttribute(tmpEl, \"started\", \"1\");\n                        }\n\n                        // incase normal browsealoud (mac) used on page at same time\n                        p_parentNode.replaceChild(tmpEl, p_textNode);\n                        tmpEl.appendChild(p_textNode);\n                    } else {\n                        var txt = p_textNode.nodeValue;\n                        var txtLeft;\n                        var txtMid;\n                        var txtRight;\n                        if (p_parentNode.tagName.toLowerCase() == \"span\" && attribute.rw_getAttribute(p_parentNode, \"pron\") != null) {\n                            txtLeft = \"\";\n                            txtMid = txt;\n                            txtRight = \"\";\n                        } else {\n                            txtLeft = txt.substring(0, p_nStartPt);\n                            txtMid = txt.substring(p_nStartPt, p_nEndPt);\n                            txtRight = txt.substring(p_nEndPt);\n                        }\n                        //                    if(SSHL.dat.browser.bIEOld)\n                        //                    {   //workaround for IE bug of setAttribute not working for style\n                        //                        tmpEl.style.setAttribute(\"cssText\", strCol, 0);\n                        //                    }\n                        //                    else\n                        {\n                            tmpEl.setAttribute(\"style\", strCol);\n                        }\n                        attribute.rw_setAttribute(tmpEl, \"rwstate\", p_state);\n                        if (bSpeech) {\n                            attribute.rw_setAttribute(tmpEl, \"started\", \"1\");\n                        }\n\n                        var txtNodeLeft = null;\n                        var txtNode;\n                        var txtNodeRight = null;\n\n                        if (txtLeft.length > 0) {\n                            txtNodeLeft = doc.createTextNode(txtLeft);\n                        }\n                        txtNode = doc.createTextNode(txtMid);\n                        if (txtRight.length > 0) {\n                            txtNodeRight = doc.createTextNode(txtRight);\n                        }\n                        tmpEl.appendChild(txtNode);\n\n                        p_parentNode.replaceChild(tmpEl, p_textNode);\n                        if (txtNodeLeft != null) {\n                            p_parentNode.insertBefore(txtNodeLeft, tmpEl);\n                        }\n                        if (txtNodeRight != null) {\n                            if (tmpEl.nextSibling == null) {\n                                p_parentNode.insertBefore(txtNodeRight, null);\n                                // use null in insertBefore to insert at end\n                            } else {\n                                p_parentNode.insertBefore(txtNodeRight, tmpEl.nextSibling);\n                            }\n                        }\n\n                        p_textNode = txtNode;\n                    }\n                }\n            }\n\n            var res = new _THReturnObject.THReturnObject();\n            res.node = p_textNode;\n            if (p_nStartPt < 0) {\n                res.offset = 0;\n            } else {\n                res.offset = p_nStartPt;\n            }\n\n            return res;\n        }\n\n        /**\n         *  If want to add or remove speech highlighting to math element call this.\n         * Doesnt handle ss yet.\n         *\n         * @param p_mathNode Must be math element\n         * @param p_rwstate\n         * @param p_strStyle\n         * @param p_bStarted true if adding speech , false to remove\n         */\n\n    }, {\n        key: 'rw_highlightMathElement',\n        value: function rw_highlightMathElement(p_mathNode, p_rwstate, p_strStyle, p_bStarted) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            if (p_mathNode == null) {\n                return;\n            }\n\n            var strTag = Constants.HIGHLIGHT_TAG;\n\n            // As per eckin usual need to do something completely different for IE, cause it doesn't support setting\n            // style data into the math ml object.\n            // (Also note for f firefox, if the mathml uses display:block it doesn't inherit background style, so firefox bugged as well)\n            var bIE = false;\n            if (bIE) {\n                // if parent is font/span with style\n                var parNode = p_mathNode.parentNode;\n                if (parNode == null) {\n                    return;\n                }\n\n                if (parNode.tagName.toLowerCase() == strTag && rw_getAttribute(parNode, \"started\") != null) {\n                    // use or remove existing\n                    if (p_bStarted) {\n                        parNode.style.setAttribute(\"cssText\", p_strStyle, 0);\n                        rw_setAttribute(parNode, \"rwstate\", p_rwstate);\n                    } else {\n                        // remove it\n                        var grandparNode = parNode.parentNode;\n                        if (grandparNode == null) {\n                            return;\n                        }\n                        grandparNode.replaceChild(p_mathNode, parNode);\n                    }\n                } else {\n                    // need to add font/span\n                    if (p_bStarted) {\n                        var elFont = document.createElement(strTag);\n                        elFont.style.setAttribute(\"cssText\", p_strStyle, 0);\n                        rw_setAttribute(elFont, \"started\", \"1\");\n                        rw_setAttribute(elFont, \"rwstate\", p_rwstate);\n                        parNode.replaceChild(elFont, p_mathNode);\n                        elFont.appendChild(p_mathNode);\n                    }\n                    // else no need to remove if not there\n                }\n            } else {\n                var tmpEl = p_mathNode.firstChild;\n\n                while (tmpEl != null) {\n                    if (tmpEl.nodeType == 1) {\n                        // could be mrow or msup or mstyle (as might be more just assume any element is valid.\n\n                        if (p_bStarted) {\n                            // adding speech highlighing\n\n                            // if has started then can change style\n                            // if has no style then add it\n                            // otherwise leave so as to not destroy page set value\n                            if (attribute.rw_getAttribute(tmpEl, \"started\") != null) {\n                                tmpEl.setAttribute(\"style\", p_strStyle);\n                                attribute.rw_setAttribute(tmpEl, \"rwstate\", p_rwstate);\n                            } else {\n                                if (attribute.rw_getAttribute(tmpEl, \"style\") == null) {\n                                    tmpEl.setAttribute(\"style\", p_strStyle);\n                                    attribute.rw_setAttribute(tmpEl, \"rwstate\", p_rwstate);\n                                    attribute.rw_setAttribute(tmpEl, \"started\", \"1\");\n                                }\n                            }\n                            //else leave well alone\n                        } else {\n                            //remove speech highlight\n                            if (attribute.rw_getAttribute(tmpEl, \"started\") != null) {\n                                tmpEl.removeAttribute(\"style\");\n                                attribute.rw_removeAttribute(tmpEl, \"started\");\n                                attribute.rw_removeAttribute(tmpEl, \"rwstate\");\n                            }\n                        }\n                    }\n\n                    tmpEl = tmpEl.nextSibling;\n                }\n            }\n        }\n\n        /*Returns all the text nodes in the range inclusive.\n         Only includes text nodes, not img elements with speakable text.\n          This is currently only used for removing highlighting!.\n          Has code to handle case of hidden elements as even if hidden after highlighted still want to remove highlighting.\n          If ever use this for adding highlighting need to pass variable to specify difference.\n          p_startCaret the start point\n         p_endCaret the end point\n         */\n\n    }, {\n        key: 'getListOfHighlightableNodes',\n        value: function getListOfHighlightableNodes(p_startCaret, p_endCaret) {\n            //special case, there is chance that area highlighted has been hidden by code in page so would\n            // fail the invalid node test and not unhighlight.  Add code here to counter this\n            var tmpIgnoreFlag = false; //g_bIgnoreHidden;\n            //g_bIgnoreHidden = false;\n\n            // continues before for loop and after catch.\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            var arr = new Array();\n            try {\n\n                var startNode = p_startCaret.node;\n                var endNode = p_endCaret.node;\n\n                if (startNode.nodeType != 3) {\n                    if (startNode.nodeType == 1 && startNode.tagName.toLowerCase() == \"math\") {\n                        arr.push(startNode);\n\n                        if (startNode == endNode) {\n                            return arr;\n                        } else {\n                            startNode = domNav.getNextTextNode(startNode, false, endNode);\n                        }\n                    } else if (g_bIE && startNode.nodeType == 1 && startNode.firstChild != null && startNode.firstChild.nodeType == 1 && startNode.firstChild.tagName.toLowerCase() == \"math\") {\n                        arr.push(startNode.firstChild);\n\n                        if (startNode == endNode) {\n                            return arr;\n                        } else {\n                            startNode = startNode.firstChild;\n                            startNode = domNav.getNextTextNode(startNode, false, endNode);\n                        }\n                    } else if (startNode.nodeType == 1 && startNode.isMathJax) {\n                        arr.push(startNode);\n\n                        if (startNode == endNode) {\n                            return arr;\n                        } else {\n                            startNode = domNav.getNextTextNode(startNode, false, endNode);\n                        }\n                    } else if (g_bIE && startNode.nodeType == 1 && startNode.firstChild != null && startNode.firstChild.isMathJax) {\n                        arr.push(startNode.firstChild);\n\n                        if (startNode == endNode) {\n                            return arr;\n                        } else {\n                            startNode = startNode.firstChild;\n                            startNode = domNav.getNextTextNode(startNode, false, endNode);\n                        }\n                    } else {\n                        startNode = domNav.getFirstChildTextNode(startNode, false);\n                        if (startNode == null) {\n                            return arr;\n                        }\n                    }\n                }\n\n                if (startNode == endNode) {\n                    if (startNode.nodeType == 3) {\n                        var txt = startNode.nodeValue;\n                        if (txt.length > 0 && p_startCaret.offset < txt.length && p_endCaret.offset > 0 && p_endCaret.offset > p_startCaret.offset) {\n                            arr.push(startNode);\n                        }\n                    }\n                } else {\n                    // check first node\n                    if (startNode.nodeType == 3) {\n                        var txt = startNode.nodeValue;\n                        if (txt.length > 0 && p_startCaret.offset < txt.length) {\n                            arr.push(startNode);\n                        }\n                    } else {\n                        if (startNode.nodeType == 1 && startNode.tagName.toLowerCase() == \"math\") {\n                            arr.push(startNode);\n                        }\n                        //                    else if(g_bIE && startNode.nodeType == 1 && startNode.firstChild != null &&\n                        //                        startNode.firstChild.nodeType == 1 &&\n                        //                        startNode.firstChild.tagName.toLowerCase() ==\"math\")\n                        //                    {\n                        //                        startNode = startNode.firstChild;\n                        //                        arr.push(startNode);\n                        //                    }\n                        else if (startNode.nodeType == 1 && startNode.isMathJax) {\n                                arr.push(startNode);\n                            }\n                        //                    else if(g_bIE && startNode.nodeType == 1 && startNode.firstChild != null &&\n                        //                        startNode.firstChild.isMathJax)\n                        //                    {\n                        //                        startNode = startNode.firstChild;\n                        //                        arr.push(startNode);\n                        //                    }\n                    }\n\n                    var tmpNode = domNav.getNextTextNodeNoImg(startNode, false, endNode, true);\n\n                    while (tmpNode != null) {\n                        if (tmpNode == endNode) {\n                            // check if include it\n                            if (endNode.nodeType == 3) {\n                                var txt = endNode.nodeValue;\n                                if (txt.length > 0 && p_endCaret.offset > 0) {\n                                    arr.push(endNode);\n                                }\n                            } else {\n                                if (tmpNode.nodeType == 1 && tmpNode.tagName.toLowerCase() == \"math\") {\n                                    arr.push(tmpNode);\n                                }\n                                //                            else if(g_bIE && tmpNode.nodeType == 1 && tmpNode.firstChild != null &&\n                                //                                tmpNode.firstChild.nodeType == 1 &&\n                                //                                tmpNode.firstChild.tagName.toLowerCase() == \"math\")\n                                //                            {\n                                //                                arr.push(tmpNode.firstChild);\n                                //                            }\n                                else if (tmpNode.nodeType == 1 && tmpNode.isMathJax) {\n                                        arr.push(tmpNode);\n                                    }\n                                //                            else if(g_bIE && tmpNode.nodeType == 1 && tmpNode.firstChild != null &&\n                                //                                tmpNode.firstChild.isMathJax)\n                                //                            {\n                                //                                arr.push(tmpNode.firstChild);\n                                //                            }\n                            }\n                            break;\n                        } else {\n                            arr.push(tmpNode);\n                        }\n\n                        tmpNode = domNav.getNextTextNodeNoImg(tmpNode, false, endNode, true);\n                    }\n                }\n            } catch (err) {} /*console.log(\"getListOfHighlightableNodes error:\" + err.message);*/\n\n            // part of special case above\n            //        g_bIgnoreHidden = tmpIgnoreFlag;\n\n            return arr;\n        }\n    }]);\n\n    return HighlightBaseController;\n}();\n\n},{\"src/Constants/Constants\":1,\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/DomNavigation\":3,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/THReturnObject\":32,\"src/SpeechStream/Utilities/Utilities\":34}],8:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MathJaxHighlightController = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevinml on 25/04/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _MathJaxHighlighter = require(\"src/SpeechStream/MathJax/MathJaxHighlighter\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MathJaxHighlightController = exports.MathJaxHighlightController = function () {\n    function MathJaxHighlightController(sentence) {\n        _classCallCheck(this, MathJaxHighlightController);\n\n        this.m_setupHash = {};\n\n        this.m_defaultContextBg = { \"r\": 255, \"g\": 255, \"b\": 0 };\n        this.m_defaultContextFg = { \"r\": 0, \"g\": 0, \"b\": 0 };\n        this.m_defaultWordBg = { \"r\": 0, \"g\": 0, \"b\": 255 };\n        this.m_defaultWordFg = { \"r\": 255, \"g\": 255, \"b\": 255 };\n        this.m_contextBg = { \"r\": 255, \"g\": 255, \"b\": 0 };\n        this.m_contextFg = { \"r\": 0, \"g\": 0, \"b\": 0 };\n        this.m_wordBg = { \"r\": 0, \"g\": 0, \"b\": 255 };\n        this.m_wordFg = { \"r\": 255, \"g\": 255, \"b\": 255 };\n        this.m_strContextStyle = \"highlight\"; //highlight (fg bg) outline underline\n        this.m_strWordStyle = \"highlight\";\n        this.sentence = sentence;\n        this.lastMathId = null;\n    }\n\n    _createClass(MathJaxHighlightController, [{\n        key: \"highlight\",\n        value: function highlight(p_id) {\n            try {\n                var elem = document.getElementById(p_id);\n                var jax = this.getJaxFor(elem);\n                this.h = new _MathJaxHighlighter.MathJaxHighlighter(jax);\n\n                if (this.m_strContextStyle === \"highlight\") {\n                    this.h.setHighlightStyle(\"context\", \"bg\", this.m_contextBg.r, this.m_contextBg.g, this.m_contextBg.b);\n                    this.h.setHighlightStyle(\"context\", \"fg\", this.m_contextFg.r, this.m_contextFg.g, this.m_contextFg.b);\n                } else if (this.m_strContextStyle === \"outline\") {\n                    this.h.setHighlightStyle(\"context\", \"outline\", this.m_contextFg.r, this.m_contextFg.g, this.m_contextFg.b);\n                } else if (this.m_strContextStyle === \"underline\") {\n                    this.h.setHighlightStyle(\"context\", \"underline\", this.m_contextFg.r, this.m_contextFg.g, this.m_contextFg.b);\n                }\n\n                if (this.m_strWordStyle === \"highlight\") {\n                    this.h.setHighlightStyle(\"word\", \"bg\", this.m_wordBg.r, this.m_wordBg.g, this.m_wordBg.b);\n                    this.h.setHighlightStyle(\"word\", \"fg\", this.m_wordFg.r, this.m_wordFg.g, this.m_wordFg.b);\n                } else if (this.m_strWordStyle === \"outline\") {\n                    this.h.setHighlightStyle(\"word\", \"outline\", this.m_wordFg.r, this.m_wordFg.g, this.m_wordFg.b);\n                } else if (this.m_strWordStyle === \"underline\") {\n                    this.h.setHighlightStyle(\"word\", \"underline\", this.m_wordFg.r, this.m_wordFg.g, this.m_wordFg.b);\n                }\n            } catch (err) {\n                // console.logE(err);\n            }\n        }\n    }, {\n        key: \"highlightRange\",\n        value: function highlightRange() {\n            var id = this.sentence.getSpanId();\n            try {\n                if (this.lastMathId) {\n                    this.clearHighlights();\n                }\n\n                this.lastMathId = id;\n                if (!this.m_setupHash[id]) {\n                    this.highlight(id);\n                    this.m_setupHash[id] = true;\n                }\n\n                var elem = document.getElementById(id);\n                var jax = this.getJaxFor(elem);\n                var jaxSpanid = jax.root.spanID ? jax.root.spanID : jax.root.CHTMLnodeID;\n                jaxSpanid = jaxSpanid != null && jaxSpanid != undefined ? jaxSpanid : jax.root.PHTMLspanID;\n                this.h.highlightNodes(\"context\", jaxSpanid);\n            } catch (err) {\n                // console.logE(err);\n            }\n        }\n    }, {\n        key: \"unHighlightRange\",\n        value: function unHighlightRange() {\n            try {\n                var p_id = this.sentence.getSpanId();\n                var elem = document.getElementById(p_id);\n                var jax = this.getJaxFor(elem);\n                this.h.clearHighlights();\n            } catch (err) {\n                // console.logE(err);\n            }\n        }\n    }, {\n        key: \"highlightWord\",\n        value: function highlightWord(wordNo) {\n            var p_id = this.sentence.getSpanId(wordNo);\n            var p_spanId = this.sentence.getWordRange(wordNo);\n            try {\n                if (!this.m_setupHash[p_id]) {\n                    this.highlight(p_id);\n                    this.m_setupHash[p_id] = true;\n                }\n\n                var elem = document.getElementById(p_id);\n                var jax = this.getJaxFor(elem);\n                this.h.highlightNodes(\"word\", p_spanId);\n            } catch (err) {\n                // console.logE(err);\n            }\n        }\n\n        /**\n         *\n         * @param p_strStyle highlight, outline or underline\n         * @param p_strType context or word  (optional, assumes word if not given.\n         * @param p_rgbFg r g b value  {\"r\":0,\"g\":100,\"b\":255} (optional, assume toolbar defaults if not given\n         * @param p_rgbBg r g b value  {\"r\":0,\"g\":100,\"b\":255} (optional, assume toolbar defaults if not given\n         */\n\n    }, {\n        key: \"setHighlightStyle\",\n        value: function setHighlightStyle(p_strStyle, p_strType, p_rgbFg, p_rgbBg) {\n            // if change the style, then the stored history of set up items is no longer valid.\n            this.m_setupHash = [];\n\n            if (typeof p_strStyle === \"string\") {\n                if (typeof p_strType == \"undefined\") {\n                    p_strType = \"word\";\n                }\n\n                var bDefault = typeof p_rgb == \"undefined\";\n\n                if (p_strType === \"context\") {\n                    this.m_strContextStyle = p_strStyle;\n\n                    if (p_strStyle === \"highlight\") {\n                        this.m_contextBg = bDefault ? this.m_defaultContextBg : p_rgbBg;\n                        this.m_contextFg = bDefault ? this.m_defaultContextFg : p_rgbFg;\n                    } else if (p_strStyle === \"outline\" || p_strStyle === \"underline\") {\n                        this.m_contextFg = bDefault ? this.m_defaultContextBg : p_rgbFg;\n                    }\n                } else if (p_strType === \"word\") {\n                    this.m_strWordStyle = p_strStyle;\n\n                    if (this.m_strWordStyle === \"highlight\") {\n                        this.m_wordBg = bDefault ? this.m_defaultWordBg : p_rgbBg;\n                        this.m_wordFg = bDefault ? this.m_defaultWordFg : p_rgbFg;\n                    } else if (p_strStyle === \"outline\" || p_strStyle === \"underline\") {\n                        this.m_wordFg = bDefault ? this.m_defaultWordBg : p_rgbFg;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"getJaxFor\",\n\n\n        /**\n         *\n         * @param p_elem a DOM element\n         * @returns {*}\n         */\n        value: function getJaxFor(p_elem) {\n            var jax = null;\n            var g_bIE = false;\n            var g_bIE11 = false;\n            if (!g_bIE || g_bIE11) {\n                jax = MathJax.Hub.getJaxFor(p_elem);\n            } else {\n                // IE doesn't work as mathjax assumes a structure that does not necessarily exist with <=IE10\n                if (p_elem && p_elem.isMathJax) {\n                    while (p_elem && !p_elem.jaxID) {\n                        p_elem = p_elem.parentNode;\n                    }\n\n                    if (p_elem) {\n                        var tmpStr = p_elem.id;\n                        if (tmpStr.indexOf(\"-Frame\") > -1) {\n                            tmpStr = tmpStr.substr(0, tmpStr.indexOf(\"-Frame\"));\n                            var tmpElem = document.getElementById(tmpStr);\n                            jax = MathJax.Hub.getJaxFor(tmpElem);\n                        }\n                    }\n                }\n            }\n            return jax;\n        }\n    }, {\n        key: \"checkText\",\n\n\n        /**\n         * Check for issues in the mathml.  If contains mtext with empty content, remove this.\n         * @param p_strMathMl\n         */\n        value: function checkText(p_strMathMl) {\n            // look for mathml mtext with no content.\n            var nPos = p_strMathMl.indexOf(\"<mtext>\");\n            var nPos2;\n            var strTmp;\n\n            while (nPos > -1) {\n                nPos2 = p_strMathMl.indexOf(\"</mtext>\", nPos);\n                if (nPos2 > nPos) {\n                    strTmp = p_strMathMl.substring(nPos + 7, nPos2);\n                    strTmp = strTmp.trimTH();\n                    if (strTmp.length == 0) {\n                        // remove the item\n                        p_strMathMl = p_strMathMl.substr(0, nPos) + p_strMathMl.substr(nPos2 + 8);\n                        nPos = p_strMathMl.indexOf(\"<mtext>\", nPos);\n                    } else {\n                        nPos = p_strMathMl.indexOf(\"<mtext>\", nPos2 + 8);\n                    }\n                } else {\n                    break;\n                }\n            }\n\n            // look for mathml mn with no content.\n            nPos = p_strMathMl.indexOf(\"<mn>\");\n\n            while (nPos > -1) {\n                nPos2 = p_strMathMl.indexOf(\"</mn>\", nPos);\n                if (nPos2 > nPos) {\n                    strTmp = p_strMathMl.substring(nPos + 4, nPos2);\n                    strTmp = strTmp.trimTH();\n                    if (strTmp.length == 0) {\n                        // remove the item\n                        p_strMathMl = p_strMathMl.substr(0, nPos) + p_strMathMl.substr(nPos2 + 5);\n                        nPos = p_strMathMl.indexOf(\"<mn>\", nPos);\n                    } else {\n                        nPos = p_strMathMl.indexOf(\"<mn>\", nPos2 + 5);\n                    }\n                } else {\n                    break;\n                }\n            }\n\n            // look for mathml mover with no content.\n            var nPos = p_strMathMl.indexOf(\"<mover>\");\n            var nPos2;\n            var strTmp;\n\n            while (nPos > -1) {\n                nPos2 = p_strMathMl.indexOf(\"</mover>\", nPos);\n                if (nPos2 > nPos) {\n                    strTmp = p_strMathMl.substring(nPos + 7, nPos2);\n                    strTmp = strTmp.trimTH();\n                    if (strTmp.length == 0) {\n                        // remove the item\n                        p_strMathMl = p_strMathMl.substr(0, nPos) + p_strMathMl.substr(nPos2 + 8);\n                        nPos = p_strMathMl.indexOf(\"<mover>\", nPos);\n                    } else {\n                        nPos = p_strMathMl.indexOf(\"<mover>\", nPos2 + 8);\n                    }\n                } else {\n                    break;\n                }\n            }\n\n            return p_strMathMl;\n        }\n    }]);\n\n    return MathJaxHighlightController;\n}();\n\n},{\"src/SpeechStream/MathJax/MathJaxHighlighter\":15}],9:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SpeechHighlightController = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nvar _THReturnObject = require('src/SpeechStream/THReturnObject');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _SentenceObject = require('src/SpeechStream/Sentence/SentenceObject');\n\nvar _SpeechObject = require('src/SpeechStream/SpeechObject');\n\nvar _ScrollInToView = require('src/SpeechStream/ScrollInToView');\n\nvar _HighlightBaseController = require('src/SpeechStream/Highlighting/HighlightBaseController');\n\nvar _DomNavigation = require('src/SpeechStream/DOM/DomNavigation');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nvar _Constants = require('src/Constants/Constants');\n\nvar Constants = _interopRequireWildcard(_Constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by kevin on 30/03/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar SpeechHighlightController = exports.SpeechHighlightController = function (_HighlightBaseControl) {\n    _inherits(SpeechHighlightController, _HighlightBaseControl);\n\n    function SpeechHighlightController(sentence) {\n        _classCallCheck(this, SpeechHighlightController);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SpeechHighlightController).call(this));\n\n        _this.sentence = sentence;\n        return _this;\n    }\n\n    _createClass(SpeechHighlightController, [{\n        key: 'highlightRange',\n        value: function highlightRange() {\n            var range = this.sentence.getRange();\n\n            var ssdom = new _SSDOM.SSDOM();\n            try {\n                // only highlight if has a range\n                if (range != null) {\n\n                    var caretRange = new _THCaretRange.THCaretRange(range.body, range.startRef.path, range.startRef.offset, range.endRef.path, range.endRef.offset);\n                    var leftCaret = caretRange.leftCaret;\n                    var rightCaret = caretRange.rightCaret;\n\n                    if (leftCaret != null && rightCaret != null) {\n                        this.rw_setSpeechRangeImpl(leftCaret.node, leftCaret.offset, rightCaret.node, rightCaret.offset, \"sp\");\n                    } else {\n                        // Cannot determine range to highlight so do nothing here\n                    }\n                }\n            } catch (err) {\n                // console.log(\"Error in THHoverTargetClass:highlightRange: \" + err.message);\n            }\n        }\n    }, {\n        key: 'unHighlightRange',\n        value: function unHighlightRange() {\n            var range = this.sentence.getRange();\n            var ssdom = new _SSDOM.SSDOM();\n            try {\n                if (range != null) {\n                    var caretRange = new _THCaretRange.THCaretRange(range.body, range.startRef.path, range.startRef.offset, range.endRef.path, range.endRef.offset);\n                    var leftCaret = caretRange.leftCaret;\n                    var rightCaret = caretRange.rightCaret;\n\n                    if (leftCaret != null && rightCaret != null) {\n                        this.rw_removeSpeechHighlight(this.getListOfHighlightableNodes(leftCaret, rightCaret), false);\n                    } else {\n                        // if cannot determine left and right caret here would not have been able to do\n                        // so at highlight stage either so likely nothing to remove.\n                    }\n                }\n            } catch (err) {\n                // console.log(\"Error in THHoverTarget:unhighlightRange: \"+err.message);\n            }\n        }\n    }, {\n        key: 'highlightWord',\n        value: function highlightWord(wordNo) {\n            if (wordNo < this.sentence.getWords().length) {\n                var ssdom = new _SSDOM.SSDOM();\n                if (wordNo > 0) {\n                    var thRange = this.sentence.getWordRange(wordNo - 1);\n                    if (thRange != null) {\n                        var caretRange = new _THCaretRange.THCaretRange(thRange.body, thRange.startRef.path, thRange.startRef.offset, thRange.endRef.path, thRange.endRef.offset);\n                        var leftCaret = caretRange.leftCaret;\n                        var rightCaret = caretRange.rightCaret;\n\n                        if (leftCaret != null && rightCaret != null) {\n                            this.rw_removeSpeechHighlight(this.getListOfHighlightableNodes(leftCaret, rightCaret), true);\n                        }\n                    }\n                }\n\n                var range = this.sentence.getWordRange(wordNo);\n\n                if (range != null) {\n                    var caretRange = new _THCaretRange.THCaretRange(range.body, range.startRef.path, range.startRef.offset, range.endRef.path, range.endRef.offset);\n                    var leftCaret = caretRange.leftCaret;\n                    var rightCaret = caretRange.rightCaret;\n                    var scrollInToView = new _ScrollInToView.ScrollInToView();\n\n                    if (leftCaret != null && rightCaret != null) {\n                        var result = this.rw_setSpeechRangeImpl(leftCaret.node, leftCaret.offset, rightCaret.node, rightCaret.offset, \"csp\");\n\n                        if (result != null && result.node != null) {\n                            scrollInToView.rw_scrollToObject(result.node);\n                        } else {\n                            scrollInToView.rw_scrollToObject(leftCaret.node);\n                        }\n                    }\n                }\n            }\n        }\n\n        /*Remove highlighting .\n         p_bWord is true when only looking to remove current word highlighting\n         */\n\n    }, {\n        key: 'rw_removeSpeechHighlight',\n        value: function rw_removeSpeechHighlight(p_arr, p_bWord) {\n            var ssdom = new _SSDOM.SSDOM();\n            try {\n                if (typeof p_bWord == \"undefined\") {\n                    p_bWord = false;\n                }\n                if (p_arr == null || !(p_arr instanceof Array) || p_arr.length == 0) {\n                    return;\n                }\n\n                for (var i = 0; i < p_arr.length; i++) {\n                    var tmp = p_arr[i];\n                    if (this.rw_checkNodeIsSpeechText(tmp, p_bWord)) {\n                        var parNode = tmp.parentNode;\n                        if (tmp.nextSibling != null || tmp.previousSibling != null) {\n                            // need to merge or text could be lost\n                            var txt = ssdom.allTextFromNodeTH(parNode);\n                            var doc = parNode.ownerDocument;\n                            tmp = doc.createTextNode(txt);\n                        }\n\n                        var higherParentNode = parNode.parentNode;\n                        higherParentNode.replaceChild(tmp, parNode);\n\n                        //                if(!SSHL.dat.browser.bIE6)\n                        //                {   // apparantly IE6 can randomly crash with call below.\n                        //                    higherParentNode.normalize();\n                        //                }\n                        tmp = ssdom.mergeTextNodes(tmp); //tod\n\n                        // put back in incase need to loop again\n                        p_arr[i] = tmp;\n\n                        // this is to check for nested case\n                        // could be removing range and word still exists, need to loop twice to get both out.\n                        if (this.rw_checkNodeIsSpeechText(tmp, p_bWord)) {\n                            --i;\n                        }\n                    } else {\n                        var tagName = \"\";\n\n                        if (tmp.nodeType == 1) {\n                            tagName = tmp.tagName.toLowerCase();\n                        }\n\n                        if (tagName == \"math\") {\n                            this.rw_highlightMathElement(tmp, null, null, false);\n                        }\n\n                        if (tmp.isMathJax) {\n                            this.rw_highlightMathElement(tmp, null, null, false);\n                        }\n                    }\n                }\n            } catch (err) {\n                // console.log(\"rw_removeSpeechHighlight failed error:\" + err.message);\n            }\n        }\n\n        /*Used by rw_removeHighlight to check if valid node to process.\n         p_node is node to check\n         p_bWord is true when only looking to remove current word highlighting*/\n\n    }, {\n        key: 'rw_checkNodeIsSpeechText',\n        value: function rw_checkNodeIsSpeechText(p_node, p_bWord) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            if (p_node.nodeType != 3 || p_node.parentNode == null || p_node.parentNode.parentNode == null) {\n                return false;\n            }\n\n            var parent = p_node.parentNode;\n            var attr = attribute.rw_getAttribute(parent, \"rwstate\");\n\n            if (parent.tagName.toLowerCase() == Constants.HIGHLIGHT_TAG && attr != null) {\n                if (!p_bWord && attr == \"sp\" || attr == \"csp\") {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /*Set the background highlighting for the range to be spoken\n          Return result item specifying what was just highlighted\n         */\n\n    }, {\n        key: 'rw_setSpeechRangeImpl',\n        value: function rw_setSpeechRangeImpl(p_startNode, p_startOffset, p_endNode, p_endOffset, p_strState) {\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            var result = null;\n            try {\n                // If all in one node\n                if (p_endNode == p_startNode) {\n                    result = this.rw_setNodeBackground(p_startNode, p_startOffset, p_endOffset, p_strState, \"\");\n                    return result;\n                }\n\n                // do first node\n                if (p_startOffset > 0) {\n                    result = this.rw_setNodeBackground(p_startNode, p_startOffset, p_startNode.nodeValue.length, p_strState, \"\");\n                } else {\n                    result = this.rw_setNodeBackground(p_startNode, -1, -1, p_strState, \"\");\n                }\n\n                // loop following nodes\n                var tmpNode = domNav.getNextTextNodeNoImg(result.node, false, p_endNode, true);\n                while (tmpNode != null) {\n                    if (tmpNode == p_endNode) {\n                        result = this.rw_setNodeBackground(tmpNode, 0, p_endOffset, p_strState, \"\");\n                        tmpNode = result.node;\n                        break;\n                    } else {\n                        result = this.rw_setNodeBackground(tmpNode, -1, -1, p_strState, \"\");\n                        tmpNode = result.node;\n                    }\n\n                    // if tmpNode is end node (from setting from result) will get null here and break\n                    tmpNode = domNav.getNextTextNodeNoImg(tmpNode, false, p_endNode, true);\n                }\n            } catch (err) {\n                // console.log(\"rw_setSpeechRangeImpl error:\"+ err.message);\n            }\n            return result;\n        }\n    }]);\n\n    return SpeechHighlightController;\n}(_HighlightBaseController.HighlightBaseController);\n\n},{\"src/Constants/Constants\":1,\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/DomNavigation\":3,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/Highlighting/HighlightBaseController\":7,\"src/SpeechStream/ScrollInToView\":18,\"src/SpeechStream/Sentence/SentenceObject\":24,\"src/SpeechStream/SpeechObject\":26,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/THReturnObject\":32,\"src/SpeechStream/Utilities/Utilities\":34}],10:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SpeechHighlightManager = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevinml on 25/04/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _SpeechHighlightController = require('src/SpeechStream/Highlighting/SpeechHighlightController');\n\nvar _MathJaxHighlightController = require('src/SpeechStream/Highlighting/MathJaxHighlightController');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SpeechHighlightManager = exports.SpeechHighlightManager = function () {\n    function SpeechHighlightManager(sentence) {\n        _classCallCheck(this, SpeechHighlightManager);\n\n        if (sentence.isMathML()) {\n            this.highlightController = new _MathJaxHighlightController.MathJaxHighlightController(sentence);\n        } else {\n            this.highlightController = new _SpeechHighlightController.SpeechHighlightController(sentence);\n        }\n    }\n\n    _createClass(SpeechHighlightManager, [{\n        key: 'highlightRange',\n        value: function highlightRange() {\n            this.highlightController.highlightRange();\n        }\n    }, {\n        key: 'unHighlightRange',\n        value: function unHighlightRange() {\n            this.highlightController.unHighlightRange();\n        }\n    }, {\n        key: 'highlightWord',\n        value: function highlightWord(wordNo) {\n            this.highlightController.highlightWord(wordNo);\n        }\n    }]);\n\n    return SpeechHighlightManager;\n}();\n\n},{\"src/SpeechStream/Highlighting/MathJaxHighlightController\":8,\"src/SpeechStream/Highlighting/SpeechHighlightController\":9}],11:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.StudySkillsHighlighting = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _THDomRange = require('src/SpeechStream/THDomRange');\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nvar _THReturnObject = require('src/SpeechStream/THReturnObject');\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _HighlightBaseController = require('src/SpeechStream/Highlighting/HighlightBaseController');\n\nvar _DomNavigation = require('src/SpeechStream/DOM/DomNavigation');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nvar _Constants = require('src/Constants/Constants');\n\nvar Constants = _interopRequireWildcard(_Constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by kevinml on 02/05/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar StudySkillsHighlighting = exports.StudySkillsHighlighting = function (_HighlightBaseControl) {\n    _inherits(StudySkillsHighlighting, _HighlightBaseControl);\n\n    function StudySkillsHighlighting() {\n        _classCallCheck(this, StudySkillsHighlighting);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(StudySkillsHighlighting).call(this));\n\n        _this.g_aTextRange = new Array();\n        _this.g_aHighlightColour = new Array();\n        return _this;\n    }\n\n    // Returns list of words to lookup in Array\n\n\n    _createClass(StudySkillsHighlighting, [{\n        key: 'fetchWords',\n        value: function fetchWords() {\n            var g_bIEOld = false;\n            var wordList = new Array();\n\n            var tmpArr = new Array();\n            var nLen = this.g_aTextRange.length;\n            for (var i = 0; i < nLen; i++) {\n                var strWord;\n\n                if (g_bIEOld) {\n                    //IE\n                    strWord = g_aTextRange.slice(i, i + 1).pop().text;\n                } else {\n                    //SFF\n                    strWord = this.g_aTextRange[i].toString();\n                }\n\n                // if single word\n                if (strWord.trimTH().indexOf(\" \") == -1) {\n                    // no internal spaces\n                    tmpArr.push(this.g_aTextRange.slice(i, i + 1).pop());\n\n                    //                if (tmpArr.length >= g_nVocabLimit && g_nVocabLimit != -1) {\n                    //                    break;\n                    //                }\n                } else {\n                    this.m_bSentenceSelection = true;\n                }\n            }\n\n            if (g_bIEOld) {\n                //IE\n                // if want to show by order in page leave in next line, if want by order selected remove next line\n                tmpArr.sort(this.sortBy);\n            } else {\n                // SFF\n                tmpArr.sort(this.sortBySFF);\n            }\n\n            var nTmpLen = tmpArr.length;\n            var strTmp;\n\n            var _loop = function _loop() {\n                if (g_bIEOld) {\n                    //IE\n                    strTmp = tmpArr.slice(j, j + 1).pop().text;\n                } else {\n                    //SFF\n                    strTmp = tmpArr[j].toString();\n                }\n\n                strTmp = strTmp.trim();\n                characters = '.,?!';\n\n                function escapeRegex(string) {\n                    return string.replace(/[\\[\\](){}?*+\\^$\\\\.|\\-]/g, \"\\\\$&\");\n                }\n\n                flags = \"g\";\n\n                characters = escapeRegex(characters);\n\n                strTmp = strTmp.replace(new RegExp(\"^[\" + characters + \"]+|[\" + characters + \"]+$\", flags), '');\n\n                wordList.push(strTmp);\n            };\n\n            for (var j = 0; j < nTmpLen; j++) {\n                var characters;\n                var flags;\n\n                _loop();\n            }\n\n            return wordList;\n        }\n    }, {\n        key: 'studySkillsCollateForColour',\n\n\n        // Determine text if any for the given colour\n        value: function studySkillsCollateForColour(p_strColour) {\n            var ssdom = new _SSDOM.SSDOM();\n            // tmpArr contains TextRange for IE and THDomRange for SFF\n            var tmpArr = new Array();\n\n            var nLen = this.g_aTextRange.length;\n            var strFull = \"\";\n            var strForColour = '';\n            var nCount = 0;\n            for (var iSegIndex = 0; iSegIndex < nLen; iSegIndex++) {\n                var strName = this.g_aHighlightColour[iSegIndex];\n\n                if (strName == p_strColour) {\n                    tmpArr.push(this.g_aTextRange.slice(iSegIndex, iSegIndex + 1).pop());\n                }\n            }\n\n            if (g_bIEOld) {\n                //IE\n                // if want to show by order in page leave in next line, if want by order selected remove next line\n                tmpArr.sort(this.sortBy);\n            } else {\n                // SFF\n                tmpArr.sort(this.sortBySFF);\n            }\n\n            var nTmpLen = tmpArr.length;\n            var strTmp;\n            var utilities = new _Utilities.Utilities();\n            var collection = new Array();\n            for (var iSegIndex = 0; iSegIndex < nTmpLen; iSegIndex++) {\n                var caretRange;\n                var g_bIEOld = false;\n                if (g_bIEOld) {\n                    //IE\n                    var tmpTextRange = tmpArr.slice(iSegIndex, iSegIndex + 1).pop();\n                    var tmpTHRange = ssdom.rw_getTextRangeAsTHRange(tmpTextRange.parentElement().ownerDocument.body, tmpTextRange);\n                    caretRange = tmpTHRange.rw_getTHCaretRangeFromTHRange();\n                } else {\n                    //SFF\n                    caretRange = tmpArr[iSegIndex].rw_getTHCaretRangeFromTHDomRange();\n                }\n\n                strTmp = caretRange.getTextOverCaretRange();\n\n                if (strTmp.length > 0) {\n                    // filter for dodgy text  i.e. < and > that will be treated as html rather than displayed.\n\n                    strTmp = utilities.rw_filterForHtml(strTmp);\n                    collection.push({ \"color\": p_strColour, \"text\": strTmp });\n                    //                if(nCount > 0){strForColour += '<br>';}\n                    //                nCount++;\n                    //                strForColour += '' + nCount + ': ' + strTmp + '<br>';\n                }\n            }\n\n            if (nCount > 0) {\n                strFull += '<p></p>';\n                strFull += '<div style=\"background:' + p_strColour + '\">';\n                strFull += strForColour;\n                strFull += '</div><p></p>';\n            }\n            return collection;\n        }\n\n        // Determine text if any for the given colour\n\n    }, {\n        key: 'studySkillsCollateForColour',\n        value: function studySkillsCollateForColour(colors) {\n            // tmpArr contains TextRange for IE and THDomRange for SFF\n            var ssdom = new _SSDOM.SSDOM();\n            var tmpArr = new Array();\n            var tmpColorArr = new Array();\n            var colorTextArray = [];\n\n            var nLen = this.g_aTextRange.length;\n            var strFull = \"\";\n            var strForColour = '';\n            var nCount = 0;\n            for (var iSegIndex = 0; iSegIndex < nLen; iSegIndex++) {\n                var strName = this.g_aHighlightColour[iSegIndex];\n\n                if (colors.indexOf(strName) != -1) {\n                    var range = this.g_aTextRange.slice(iSegIndex, iSegIndex + 1).pop();\n                    range.color = strName;\n                    tmpArr.push(range);\n                    //        tmpColorArr.push(strName);\n                }\n            }\n            var g_bIEOld = false;\n            if (g_bIEOld) {\n                //IE\n                // if want to show by order in page leave in next line, if want by order selected remove next line\n                tmpArr.sort(this.sortBy);\n            } else {\n                // SFF\n                tmpArr.sort(this.sortBySFF);\n            }\n\n            var nTmpLen = tmpArr.length;\n            var strTmp;\n            var utilities = new _Utilities.Utilities();\n            for (var iSegIndex = 0; iSegIndex < nTmpLen; iSegIndex++) {\n                var caretRange;\n                var color = tmpArr[iSegIndex].color;\n\n                if (g_bIEOld) {\n                    //IE\n                    var tmpTextRange = tmpArr.slice(iSegIndex, iSegIndex + 1).pop();\n                    var tmpTHRange = ssdom.rw_getTextRangeAsTHRange(tmpTextRange.parentElement().ownerDocument.body, tmpTextRange);\n                    caretRange = tmpTHRange.rw_getTHCaretRangeFromTHRange();\n                } else {\n                    //SFF\n                    caretRange = tmpArr[iSegIndex].rw_getTHCaretRangeFromTHDomRange();\n                }\n\n                strTmp = caretRange.getTextOverCaretRange();\n\n                if (strTmp.length > 0) {\n                    // filter for dodgy text  i.e. < and > that will be treated as html rather than displayed.\n                    strTmp = utilities.rw_filterForHtml(strTmp);\n\n                    //        if(nCount > 0){strForColour += '<br>';}\n                    nCount++;\n                    // strForColour += '' + nCount + ': ' + strTmp + '<br>';\n\n                    colorTextArray.push({ 'text': strTmp, 'color': color });\n                }\n            }\n\n            /*  if(nCount > 0)\n             {\n             strFull += '<p></p>';\n             strFull += '<div style=\"background:' + p_strColour + '\">';\n             strFull += strForColour;\n             strFull += '</div><p></p>';\n             }           */\n            return colorTextArray;\n        }\n\n        // Sort function for the range objects\n\n    }, {\n        key: 'sortBy',\n        value: function sortBy(a, b) {\n            try {\n                return a.compareEndPoints(\"EndToEnd\", b);\n            } catch (exc) {\n                // console.log(\"sortby \" + exc.message);\n                return 0;\n            }\n        }\n\n        //fix for dodgy characters that cannot be displayed in html without being altered.\n\n\n        /*A Firefox sort algorithm for use with an array of THDomRange objects*/\n        // Sort function for the range objects\n\n    }, {\n        key: 'sortBySFF',\n        value: function sortBySFF(a, b) {\n            try {\n                if (a.equals(b)) {\n                    return 0;\n                }\n\n                a.refresh();\n                b.refresh();\n\n                var aEnd = a.getEndAsRange();\n                var bEnd = b.getEndAsRange();\n\n                return aEnd.compareBoundaryPoints(\"END_TO_END\", bEnd);\n            } catch (exc) {\n                // console.log(\"sortBySFF \" + exc.message);\n                return 0;\n            }\n        }\n\n        /*Highlights the back color of a selection in internet explorer with the color passed in*/\n\n    }, {\n        key: 'studySkillsHTMLHighlightRange',\n        value: function studySkillsHTMLHighlightRange(p_strColour, selObj) {\n            var ssdom = new _SSDOM.SSDOM();\n            try {\n                // get the selection\n                if (selObj == null || selObj.range == null || selObj.range instanceof String) {\n                    return false;\n                }\n\n                //This is either TextRange or THDomRange\n                var selectionRange = selObj.range;\n\n                var g_bIEOld = false;\n                if (g_bIEOld) {\n                    // convert to thRange to test\n                    var bod = selectionRange.parentElement().ownerDocument.body;\n                    var thRange = ssdom.rw_getTextRangeAsTHRange(bod, selectionRange);\n                    if (thRange == null) {\n                        return false;\n                    }\n\n                    var caretRange = new _THCaretRange.THCaretRange(bod, thRange.startRef.path, thRange.startRef.offset, thRange.endRef.path, thRange.endRef.offset);\n                    var startCaret = caretRange.leftCaret;\n                    var endCaret = caretRange.rightCaret;\n\n                    if (startCaret == null || endCaret == null) {\n                        return false;\n                    }\n\n                    var thDomRange = new _THDomRange.THDomRange(startCaret.node, startCaret.offset, endCaret.node, endCaret.offset);\n\n                    if (thDomRange == null) {\n                        return null;\n                    }\n\n                    thDomRange = this.rw_checkTHRangeForValidHighlight(thDomRange);\n\n                    if (thDomRange == null) {\n                        return null;\n                    }\n\n                    selectionRange = ssdom.rw_getAsTextRange(bod, thDomRange.startRef.path, thDomRange.startRef.offset, thDomRange.endRef.path, thDomRange.endRef.offset);\n                } else {\n                    //SFF\n                    selectionRange = this.rw_checkTHRangeForValidHighlight(selectionRange);\n                }\n\n                if (selectionRange == null) {\n                    //rw_alert(\"Failed to do the highlight, possibly due to selection going into a non textual part of the page.\");\n                    return false;\n                }\n\n                //collapse the selection before highlighting due to edge bug.\n                // if double click to select (not drag) the highlighting glitches in edge after highlighting, due to replacing element in DOM that has the highlighting.\n                // has already stored the highlight range first so can remove before study skill highlighting.\n                ssdom.rw_collapseSelection();\n\n                this.studySkillsHTMLHighlightRangeImpl(selectionRange, p_strColour);\n\n                // Report it\n                var reporter = SpeechStream.analytics;\n                reporter.report(reporter.categories.HIGHLIGHT, p_strColour);\n\n                //It is important that this is only called from the user called highlighting and not\n                //the computer generated calls, as would break data when restoring by calling db while retrieving from it.\n                //  todo add in later          if(g_bPersistAnnotations && g_bPersistHighlights &&\n                //                typeof(rw_storeHighlightData) != \"undefined\")      //check that the fucntion exists\n                //            {   // call if pkt with student id given and not a teacher  (or for generic storage)\n                //                rw_storeHighlightData();\n                //            }\n\n                return true;\n            } catch (exc) {\n                //alert(\"Error in method: \" + exc.name + \" \" + exc.message + \" \" + exc.description + \" \" + exc.toString());\n                return false;\n            }\n        }\n\n        // abstract out part so can highlight based on selection in page and\n        // programmatically in code\n        // p_range This is either TextRange or THDomRange\n\n    }, {\n        key: 'studySkillsHTMLHighlightRangeImpl',\n        value: function studySkillsHTMLHighlightRangeImpl(p_range, p_strColour) {\n            try {\n                var ssdom = new _SSDOM.SSDOM();\n                var bDisplayIssueMatch = false;\n                var tmpNode = null;\n                var storedDisplayValue = null;\n\n                var strSelectText = null;\n                var blnAddNewRange = true;\n\n                // get the selection\n                if (p_range == null || p_range instanceof String) {\n                    return;\n                }\n\n                // NOTE, if an existing range is edited, such as overlapping first, the g_aTextRange is remade\n                // and might have a different order, so if a change is made, need to reset and start again from the start.\n                // Add in a simple check to prevent accidental infinite loop (where there is an overlap but is not changed for some reason.)\n                var nInfiniteCount = 0;\n                var bChangeMade = false;\n\n                // Need to do browser detection rather than object detection, as object exists in IE 8 and IE 9 but different\n                // behaviour required. Object detection fails when object exists in both places but implemented differently.\n                var g_bIEOld = false;\n                if (g_bIEOld) {\n                    //IE\n                    //get the text property of the selection range\n                    strSelectText = p_range.rw_getTextFromRange();\n\n                    //if null there is no selection\n                    if (strSelectText.length == 0) {\n                        return;\n                    }\n\n                    try {\n                        // check for parent set to display none\n                        tmpNode = p_range.parentElement();\n                        var theStyle = _SSDOM.SSDOM.getComputedStyle(tmpNode);\n                        if (theStyle != null && theStyle.display == \"none\") {\n                            bDisplayIssueMatch = true;\n                        } else {\n                            var bod = tmpNode.ownerDocument.body;\n                            while (tmpNode != bod) {\n                                tmpNode = tmpNode.parentNode;\n                                if (_SSDOM.SSDOM.getComputedStyle(tmpNode).display == \"none\") {\n                                    bDisplayIssueMatch = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (bDisplayIssueMatch) {\n                            // need to make displayed\n                            storedDisplayValue = tmpNode.style.display;\n                            tmpNode.style.display = \"inline\";\n                        }\n                    } catch (e) {/***/}\n\n                    studySkillsHTMLRefreshRanges();\n\n                    //enumerate the structure to see if we are overwriting a current text range first\n                    //before adding a new range\n\n                    for (var iRangeIndex = 0; iRangeIndex < this.g_aTextRange.length; iRangeIndex++) {\n                        //check that our text ranges from the stored to the selection do not conflict\n\n                        var storedRange = this.g_aTextRange[iRangeIndex];\n                        //check that we are not using text from different frames in the same page\n\n                        var dupCurrentTextRange = p_range.duplicate();\n                        dupCurrentTextRange.collapse(true);\n                        var bStart = storedRange.inRange(dupCurrentTextRange);\n\n                        dupCurrentTextRange = p_range.duplicate();\n                        dupCurrentTextRange.collapse(false);\n                        var bEnd = storedRange.inRange(dupCurrentTextRange);\n\n                        bChangeMade = false;\n\n                        if (bStart && bEnd) {\n                            // new selection entirely inside an existing range\n                            //check if new selection is same colour as existing\n                            if (this.g_aHighlightColour[iRangeIndex] == p_strColour) {\n                                // Its the same colour as existing selection, no need to replace anything\n                                blnAddNewRange = false;\n                            } else {\n                                case1IE(iRangeIndex, p_range);\n\n                                // change made\n                                bChangeMade = true;\n                            }\n                        } else if (!bStart && bEnd) {\n                            // new selection before and ends in an existing range\n                            case2IE(iRangeIndex, p_range);\n\n                            // change made\n                            bChangeMade = true;\n                        } else if (bStart && !bEnd) {\n                            // new selection starts in and ends after an existing range\n                            case3IE(iRangeIndex, p_range);\n\n                            // change made\n                            bChangeMade = true;\n                        } else if (p_range.inRange(storedRange)) {\n                            // new selection contains an exinsting range entirely\n                            this.g_aTextRange.splice(iRangeIndex, 1);\n                            this.g_aHighlightColour.splice(iRangeIndex, 1);\n\n                            iRangeIndex--;\n\n                            // change made\n                            bChangeMade = true;\n                        }\n\n                        if (bChangeMade) {\n                            // Reset to 0 in range to check all again as change could have\n                            // reorganised the order of items in this.g_aTextRange.\n\n                            // a just in case check\n                            ++nInfiniteCount;\n\n                            if (nInfiniteCount < 100) {\n                                // next loop back to 0\n                                iRangeIndex = -1;\n                            }\n                            // else just carry on, worst case is just highlights not updated correctly, better than infinite loop.\n                            // allow index changes in if checks to stand\n                        }\n                    }\n                } else if (p_range.toString) {\n                    // safari Firefox\n                    if (p_range == null || p_range.toString() == null || p_range.toString() == \"\") {\n                        return;\n                    }\n                    // p_range is a THDomRange\n\n                    //\tstudySkillsHTMLRefreshRanges();\n                    //enumerate the structure to see if we are overwriting a current text range first\n                    //before adding a new range\n                    for (var iRangeIndex = 0; iRangeIndex < this.g_aTextRange.length; iRangeIndex++) {\n                        //check that our text ranges from the stored to the selection do not conflict\n                        var tmpDomRange = this.g_aTextRange[iRangeIndex];\n\n                        //check that we are not working with text from different frames with one page\n                        if (p_range.body.ownerDocument == tmpDomRange.body.ownerDocument) {\n                            var nResult = p_range.compareRange(tmpDomRange);\n                            //noinspection FallthroughInSwitchStatementJS\n                            switch (nResult) {\n                                case Constants.THDomRange_ERROR:\n                                    window.status = \"Error occurred when trying to add a highlight.\";\n                                    break;\n                                case Constants.THDomRange_TARGET_SAME:\n                                // if exactly the same and same colour do nothing, otherwise fall through to target inside\n                                // //todo   if(this.g_aHighlightColour[iRangeIndex] == p_strColour)\n                                //   {\n                                //       // Its the same colour as existing selection, no need to replace anything\n                                //       blnAddNewRange = false;\n                                //       break;\n                                //   }\n                                case Constants.THDomRange_TARGET_INSIDE:\n                                    // new selection contains an existing range entirely, remove existing\n\n                                    tmpDomRange.refresh();\n                                    this.rw_removeHighlight(this.getListOfHighlightableNodes(tmpDomRange.startCaret, tmpDomRange.endCaret));\n\n                                    this.g_aTextRange.splice(iRangeIndex, 1);\n                                    this.g_aHighlightColour.splice(iRangeIndex, 1);\n\n                                    --iRangeIndex;\n\n                                    p_range.refresh();\n\n                                    // change made\n                                    bChangeMade = true;\n\n                                    break;\n                                case Constants.THDomRange_TARGET_INCLUDES_THIS:\n                                case Constants.THDomRange_TARGET_INCLUDES_THIS_AT_START:\n                                case Constants.THDomRange_TARGET_INCLUDES_THIS_AT_END:\n                                    // new selection entirely inside an existing range\n                                    //check if new selection is same colour as existing\n                                    if (this.g_aHighlightColour[iRangeIndex] == p_strColour) {\n                                        // Its the same colour as existing selection, no need to replace anything\n                                        blnAddNewRange = false;\n                                    } else {\n                                        this.case1SFF(iRangeIndex, p_range, nResult);\n                                        ++iRangeIndex;\n\n                                        // change made\n                                        bChangeMade = true;\n                                    }\n                                    break;\n                                case Constants.THDomRange_OVERLAPS_START_OF_TARGET:\n                                    // new selection before and ends in an existing range\n                                    this.case2SFF(iRangeIndex, p_range);\n\n                                    // change made\n                                    bChangeMade = true;\n                                    break;\n                                case Constants.THDomRange_OVERLAPS_END_OF_TARGET:\n                                    // new selection starts in and ends after an existing range\n                                    this.case3SFF(iRangeIndex, p_range);\n\n                                    // change made\n                                    bChangeMade = true;\n                                    break;\n\n                                case Constants.THDomRange_AFTER_TARGET:\n                                    break;\n                                case Constants.THDomRange_BEFORE_TARGET:\n                                    break;\n                                default: //do nothing\n                            }\n                        }\n\n                        if (bChangeMade) {\n                            // Reset to 0 in range to check all again as change could have\n                            // reorganised the order of items in this.g_aTextRange.\n\n                            // a just in case check\n                            ++nInfiniteCount;\n\n                            if (nInfiniteCount < 100) {\n                                // next loop back to 0\n                                iRangeIndex = -1;\n                            }\n                            // else just carry on, worst case is just highlights not updated correctly, better than infinite loop.\n                            // allow index changes in cases to stand\n                        }\n                    }\n                } else {\n                    return;\n                }\n\n                var g_bIENew = false;\n                if (g_bIENew) {\n                    //IE9 needs it cleared before or otherwise selects the whole sentence\n\n                    //collapse the selection\n                    ssdom.rw_collapseSelection();\n                }\n\n                // Do the add if still needed\n                if (blnAddNewRange) {\n                    // when checking for position later need to ignore font elements and elements with rwstate\n                    // attributes as these can relate to temporary highlights so no use for permanent position strings.\n                    if (p_range.execCommand) {\n                        //IE\n                        this.studySkillsClearRangeIE(p_range);\n                        this.rw_ieSpecificCallToSetHighlight(p_range, p_strColour);\n                    } else {\n                        // SFF\n                        var startCaret = p_range.startCaret;\n                        var endCaret = p_range.endCaret;\n                        var result = this.rw_setHighlight(startCaret.node, startCaret.offset, endCaret.node, endCaret.offset, p_strColour);\n                    }\n                    this.g_aTextRange.push(p_range);\n                    this.g_aHighlightColour.push(p_strColour);\n                }\n\n                //collapse the selection after the highlight\n                ssdom.rw_collapseSelection();\n\n                if (bDisplayIssueMatch) {\n                    //for IE hack\n                    tmpNode.style.display = storedDisplayValue;\n                }\n\n                return true;\n            } catch (exc) {\n                //alert(\"Error in method: \" + exc.name + \" \" + exc.message + \" \" + exc.description + \" \" + exc.toString());\n                return false;\n            }\n        }\n\n        /*Do highlighting for study skills*/\n\n    }, {\n        key: 'rw_setHighlight',\n        value: function rw_setHighlight(p_startNode, p_startOffset, p_endNode, p_endOffset, p_strColour) {\n            // For safari and FireFox\n            var resStart = p_startNode;\n            var resEnd = p_endNode;\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            try {\n                // if(p_startNode.nodeType != 3) alert(\"bad node sent to rw_setHighlight!\");\n                //if(p_endNode.nodeType != 3) alert(\"bad node sent to rw_setHighlight!\");\n                // If all in one node\n                var result = null;\n                if (p_endNode == p_startNode) {\n                    result = this.rw_setNodeBackground(p_startNode, p_startOffset, p_endOffset, \"ss\", p_strColour);\n                    //noinspection JSUnusedAssignment\n                    resStart = result.node;\n                    resEnd = result.node;\n                } else {\n                    // do first node\n                    if (p_startOffset > 0) {\n                        result = this.rw_setNodeBackground(p_startNode, p_startOffset, p_startNode.nodeValue.length, \"ss\", p_strColour);\n                    } else {\n                        result = this.rw_setNodeBackground(p_startNode, -1, -1, \"ss\", p_strColour);\n                    }\n                    resStart = result.node;\n\n                    // loop following nodes\n                    var tmpNode = domNav.getNextTextNodeNoImg(result.node, false, p_endNode, true);\n                    while (tmpNode != null) {\n                        if (tmpNode == p_endNode) {\n                            result = this.rw_setNodeBackground(tmpNode, 0, p_endOffset, \"ss\", p_strColour);\n                            tmpNode = result.node;\n                            resEnd = tmpNode;\n                            break;\n                        } else {\n                            result = this.rw_setNodeBackground(tmpNode, -1, -1, \"ss\", p_strColour);\n                            tmpNode = result.node;\n                        }\n                        resEnd = tmpNode;\n                        // set res here in case misses hit on end node and get null on following call\n                        // so at least gets last node used in return object\n                        tmpNode = domNav.getNextTextNodeNoImg(tmpNode, false, p_endNode, true);\n                    }\n                }\n            } catch (err) {/*console.log(\"rw_setHighlight error:\" + err.message);*/}\n            return { start: resStart, end: resEnd };\n        }\n\n        // cases to handle for Internet Explorer\n\n    }, {\n        key: 'rw_ieSpecificCallToSetHighlight',\n        value: function rw_ieSpecificCallToSetHighlight(p_range, p_strColour) {\n            if (p_strColour == \"strikethrough\") {\n                p_range.execCommand(\"strikethrough\", false, null);\n            } else {\n                p_range.execCommand(\"backcolor\", false, p_strColour);\n            }\n        }\n    }, {\n        key: 'studySkillsClearRangeIE',\n        value: function studySkillsClearRangeIE(p_range) {\n            p_range.execCommand(\"backcolor\", false, \"clear\");\n            if ((g_nIcons & strike_icon) == strike_icon) {\n                // Only do this is strike icon is specifically asked for as doing full removeformat every time could cause issues\n                p_range.execCommand(\"RemoveFormat\", false, null);\n            }\n        }\n\n        /*Remove highlighting for study skills.\n         // Not supporting MathML here.\n         */\n\n    }, {\n        key: 'rw_removeHighlight',\n        value: function rw_removeHighlight(p_arr) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            try {\n                if (p_arr == null || !(p_arr instanceof Array) || p_arr.length == 0) {\n                    return;\n                }\n\n                for (var i = 0; i < p_arr.length; i++) {\n                    var tmp = p_arr[i];\n                    if (this.rw_checkNodeIsHighlightedText(tmp)) {\n                        var parNode = tmp.parentNode;\n\n                        if (tmp.nextSibling != null || tmp.previousSibling != null) {\n                            // need to merge or text could be lost\n                            var txt = ssdom.allTextFromNodeTH(parNode);\n                            var doc = parNode.ownerDocument;\n                            tmp = doc.createTextNode(txt);\n                        }\n\n                        var higherParentNode = parNode.parentNode;\n                        higherParentNode.replaceChild(tmp, parNode);\n                        //higherParentNode.normalize();\n                        tmp = ssdom.mergeTextNodes(tmp);\n\n                        // put back in incase used for speech removal\n                        p_arr[i] = tmp;\n                    } else {\n                        var tmpFont = this.rw_getNestedNodeForHighlightedText(tmp);\n                        if (tmpFont != null) {\n                            attribute.rw_removeAttribute(tmpFont, \"rwstate\");\n                            tmpFont.removeAttribute(\"style\");\n                        }\n                    }\n                }\n\n                // if not speaking, check same range for speech highlighting\n                // for rare case of highlighting not being removed, this gives means to remove it\n                //            todo is this needed if(!SSDAT.controlData.bSpeakingFlag)\n                //            {\n                //                rw_removeSpeechHighlight(p_arr, false);\n                //            }\n            } catch (err) {/*console.log(\"Error in rw_setHighlight: \" + err.message);*/}\n        }\n\n        /*Used by rw_removeHighlight to check if valid node to process.*/\n\n    }, {\n        key: 'rw_getNestedNodeForHighlightedText',\n        value: function rw_getNestedNodeForHighlightedText(p_node) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            if (p_node.nodeType != 3 || p_node.parentNode == null || p_node.parentNode.parentNode == null) {\n                return null;\n            }\n\n            var strTag = Constants.HIGHLIGHT_TAG;\n\n            var parent = p_node.parentNode;\n            var attr = attribute.rw_getAttribute(parent, \"rwstate\");\n\n            if (parent.tagName.toLowerCase() != strTag || attr == null || attr != \"ss\") {\n                // check if node added inside a highlight\n                if (attribute.rw_getAttribute(parent, \"rwthgen\") != null) {\n                    // may be in nested element\n                    var tmpElem = parent;\n                    attr = \"1\";\n\n                    while (attr != null) {\n                        tmpElem = tmpElem.parentNode;\n\n                        if (attribute.rw_getAttribute(tmpElem, \"rwState\") == \"ss\" && tmpElem.tagName.toLowerCase() == strTag) {\n                            return tmpElem;\n                        }\n\n                        attr = attribute.rw_getAttribute(tmpElem, \"rwthgen\");\n                    }\n                }\n\n                return null;\n            }\n\n            return parent;\n        }\n\n        /*Used by rw_removeHighlight to check if valid node to process.\n         * Allow to check type 1 and 3, as with tinymce could have highlight span then &lt;b&gt; then text.  */\n\n    }, {\n        key: 'rw_checkNodeIsHighlightedText',\n        value: function rw_checkNodeIsHighlightedText(p_node) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            if (p_node.parentNode == null || p_node.parentNode.parentNode == null) {\n                return false;\n            }\n\n            var parent = p_node.parentNode;\n            var attr = attribute.rw_getAttribute(parent, \"rwstate\");\n\n            //noinspection RedundantIfStatementJS\n            //todo fix\n            if (parent.tagName.toLowerCase() != Constants.HIGHLIGHT_TAG || attr == null || attr == \"csp\" || attr == \"sp\") {\n                return parent.className == \"thspell\" || parent.className == \"thhom\" /*SpeechStream.highlighter.getHomClass()*/ || parent.className == \"thgrammar\";\n            }\n\n            return true;\n        }\n\n        /*Check that a THDomRange is a valid highlight range*/\n\n    }, {\n        key: 'rw_checkTHRangeForValidHighlight',\n        value: function rw_checkTHRangeForValidHighlight(p_range) {\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            var startCaret = p_range.startCaret;\n            var endCaret = p_range.endCaret;\n\n            var bChanged = false;\n\n            if (ssdom.isInvalidNode(startCaret.node)) {\n                // cannot highlight in invalid area.  Not worth effort to make it move start to non invalid area.\n                if (startCaret.node != endCaret.node) {\n                    var tmpNode = domNav.getNextTextNodeNoImg(startCaret.node, false, endCaret.node, false);\n                    if (tmpNode != null && !ssdom.isInvalidNode(tmpNode)) {\n                        startCaret.node = tmpNode;\n                        startCaret.offset = 0;\n                        bChanged = true;\n                    } else {\n                        // Not worth effort to make it move start to non invalid area.\n                        return;\n                    }\n                } else {\n                    return;\n                }\n            }\n\n            var bFail = startCaret.node.nodeType != 3 || startCaret.node.nodeType == 3 && startCaret.node.nodeValue.trimTH().length == 0;\n\n            if (bFail) {\n                bChanged = true;\n                while (bFail) {\n                    if (startCaret.node == endCaret.node) {\n                        // no point moving start point as would move beyond end so no valid highlight\n                        return null;\n                    }\n\n                    startCaret.node = domNav.getNextTextNodeNoBlank(startCaret.node, false, endCaret.node);\n\n                    if (startCaret.node == null) {\n                        return null;\n                    }\n\n                    bFail = startCaret.node.nodeType != 3 || startCaret.node.nodeType == 3 && startCaret.node.nodeValue.trimTH().length == 0;\n                }\n\n                startCaret.offset = 0;\n            }\n\n            if (ssdom.isInvalidNode(endCaret.node)) {\n                // cannot highlight in invalid area.\n                if (startCaret.node != endCaret.node) {\n                    var tmpNode = domNav.getPreviousTextNodeNoImg(endCaret.node, false, startCaret.node, false);\n                    if (tmpNode != null && !ssdom.isInvalidNode(tmpNode)) {\n                        endCaret.node = tmpNode;\n                        endCaret.offset = tmpNode.nodeValue.length;\n                        bChanged = true;\n                    } else {\n                        // Not worth effort to make it move start to non invalid area.\n                        return;\n                    }\n                } else {\n                    return;\n                }\n            }\n\n            bFail = endCaret.node.nodeType != 3 || endCaret.node.nodeType == 3 && endCaret.node.nodeValue.trimTH().length == 0;\n\n            if (bFail) {\n                bChanged = true;\n                while (bFail) {\n                    if (startCaret.node == endCaret.node) {\n                        // no point moving end point as would move before start so no valid highlight\n                        return null;\n                    }\n\n                    endCaret.node = domNav.getPreviousTextNodeNoImg(endCaret.node, false, startCaret.node, false);\n\n                    if (endCaret.node == null) {\n                        return null;\n                    }\n\n                    bFail = endCaret.node.nodeType != 3 || endCaret.node.nodeType == 3 && endCaret.node.nodeValue.trimTH().length == 0;\n                }\n\n                if (endCaret.node.nodeType == 3) {\n                    endCaret.offset = endCaret.node.nodeValue.length;\n                }\n            }\n\n            if (startCaret.node == null || endCaret.node == null) {\n                return null;\n            }\n\n            if (bChanged) {\n                p_range = new _THDomRange.THDomRange(startCaret.node, startCaret.offset, endCaret.node, endCaret.offset);\n            }\n            return p_range;\n        }\n\n        //*!\n        /*Clears the selection of highlights added by the study skills\n         * param p_bForceClear - if true clear all as if had no selection and no alert.*/\n\n    }, {\n        key: 'studySkillsClearHighlights',\n        value: function studySkillsClearHighlights(p_bForceClear, selObj) {\n            try {\n                var selectionRange = null;\n                var selWindow = null;\n                if (selObj != null && selObj.range != null) {\n                    selectionRange = selObj.range;\n                    selWindow = selObj.frame;\n                }\n                if (selectionRange != null && selectionRange instanceof String) {\n                    // selection in a text field, wont be highlighted and dont necessarily\n                    // want to remove all from here so return;\n                    // First remove the selection so subsequent press will clear all\n                    var g_lastInputSelectSFF = false;\n                    if (g_lastInputSelectSFF != null) {\n                        g_lastInputSelectSFF.selectionStart = 0;\n                        g_lastInputSelectSFF.selectionEnd = 0;\n                    }\n                    g_lastInputSelectSFF = null;\n\n                    if (p_bForceClear) {\n                        // don't return continue to clear all the page\n                        selectionRange = null;\n                    } else {\n                        return;\n                    }\n                }\n\n                var strTmp = \"Remove all highlights?\";\n\n                // Need to do browser detection rather than object detection, as object exists in IE 8 and IE 9 but different\n                // behaviour required.\n                var g_bIEOld = false;\n                if (g_bIEOld) {\n                    // IE\n                    if (selectionRange == null || selectionRange.length == 0 || selectionRange.text.length == 0 || p_bForceClear) {\n                        // no selection remove all\n                        if (!p_bForceClear) {\n                            var agree = false; //confirm(strTmp);\n                            if (!agree) {\n                                return;\n                            }\n                        }\n\n                        //                    todo if(g_bPersistAnnotations)\n                        //                    {   // added as if persisting but want to clear highlights to refresh turn persistence off\n                        //                        // this allows this data to not be lost as well as not sending bad data.\n                        //                        g_strStoredHighlightData = null;\n                        //                        g_strStoredHighlightUnprocessedData = null;\n                        //                    }\n\n                        var nLen = this.g_aTextRange.length;\n                        // bit of belts and braces approach\n                        for (var iRangeIndex = 0; iRangeIndex < nLen; iRangeIndex++) {\n                            var range = this.g_aTextRange[iRangeIndex];\n                            this.studySkillsClearRangeIE(range);\n\n                            this.g_aTextRange[iRangeIndex] = null;\n                            this.g_aHighlightColour[iRangeIndex] = null;\n                        }\n\n                        this.g_aTextRange = new Array();\n                        this.g_aHighlightColour = new Array();\n\n                        if (!document.compatMode.equalsTH(\"CSS1Compat\")) {\n                            // this does not work in non strict mode, is just an extra safe catch all remove\n                            // so not essential, if site wants to force a less stable mode, it will be less stable\n                            // nothing we can do about it\n\n                            // check if selection inside a frame\n                            var g_bIgnoreFrames = false;\n                            if (!g_bIgnoreFrames && top.frames.length > 0) {\n                                var i = 0;\n                                var nLenFrames = top.frames.length;\n                                for (i = 0; i < nLenFrames; i++) {\n                                    try {\n                                        var tmpFrame = top.frames[i];\n                                        selectionRange = tmpFrame.document.selection.createRange();\n                                        selectionRange.expand(\"textedit\");\n                                        this.studySkillsClearRangeIE(selectionRange);\n                                    } catch (e) {\n                                        // frames exist with different domain so cannot access.\n                                    }\n                                }\n                            } else {\n                                selectionRange = document.selection.createRange();\n                                selectionRange.expand(\"textedit\");\n                                this.studySkillsClearRangeIE(selectionRange);\n                            }\n                        }\n\n                        //                    todo if(g_bPersistAnnotations && g_bPersistHighlights &&\n                        //                        typeof(rw_storeHighlightData) != \"undefined\")\n                        //                    {   // call if pkt with student id given and not a teacher\n                        //                        rw_storeHighlightData();\n                        //                    }\n\n                        return;\n                    }\n                    this.studySkillsClearRangeIE(selectionRange);\n                    this.studySkillsHTMLRefreshRanges();\n\n                    // go through each item, if start or end of it is in range then remove it\n\n                    var nLen = this.g_aTextRange.length;\n                    var iRangeIndex = 0;\n                    var tmpRange = null;\n                    var dupRange = null;\n                    for (iRangeIndex = 0; iRangeIndex < nLen; iRangeIndex++) {\n                        tmpRange = this.g_aTextRange[iRangeIndex];\n\n                        if (tmpRange != null) {\n                            // check for full range in selection\n                            if (selectionRange.inRange(tmpRange)) {\n                                tmpRange = null;\n\n                                this.g_aTextRange.splice(iRangeIndex, 1);\n                                this.g_aHighlightColour.splice(iRangeIndex, 1);\n\n                                iRangeIndex--;\n                                continue;\n                            }\n\n                            // check for start in selection\n                            dupRange = tmpRange.duplicate();\n                            dupRange.collapse(true);\n                            if (selectionRange.inRange(dupRange)) {\n                                var storedRangePost = tmpRange.duplicate();\n                                storedRangePost.collapse(false);\n                                while (storedRangePost.compareEndPoints(\"StartToEnd\", selectionRange) > 0) {\n                                    storedRangePost.moveStart(\"character\", -1);\n                                }\n                                this.studySkillsClearRangeIE(this.g_aTextRange[iRangeIndex]);\n                                this.g_aTextRange[iRangeIndex] = storedRangePost;\n                                this.rw_ieSpecificCallToSetHighlight(this.g_aTextRange[iRangeIndex], this.g_aHighlightColour[iRangeIndex]);\n                            } else {\n                                // check for end in selection\n                                dupRange = tmpRange.duplicate();\n                                dupRange.collapse(false);\n                                if (selectionRange.inRange(dupRange)) {\n                                    var storedRangePre = tmpRange.duplicate();\n                                    storedRangePre.collapse(true);\n\n                                    while (storedRangePre.compareEndPoints(\"EndToStart\", selectionRange) < 0) {\n                                        storedRangePre.moveEnd(\"character\", 1);\n                                    }\n                                    this.studySkillsClearRangeIE(this.g_aTextRange[iRangeIndex]);\n                                    this.g_aTextRange[iRangeIndex] = storedRangePre;\n                                    this.rw_ieSpecificCallToSetHighlight(this.g_aTextRange[iRangeIndex], this.g_aHighlightColour[iRangeIndex]);\n                                }\n                            }\n\n                            // is selection in range\n                            if (tmpRange.inRange(selectionRange)) {\n                                studySkillsClearRangeIE(tmpRange);\n                                var storedRangePre = tmpRange.duplicate();\n                                var storedRangePost = tmpRange.duplicate();\n                                storedRangePre.collapse(true);\n                                storedRangePost.collapse(false);\n\n                                while (storedRangePre.compareEndPoints(\"EndToStart\", selectionRange) < 0) {\n                                    storedRangePre.moveEnd(\"character\", 1);\n                                }\n\n                                while (storedRangePost.compareEndPoints(\"StartToEnd\", selectionRange) > 0) {\n                                    storedRangePost.moveStart(\"character\", -1);\n                                }\n\n                                this.studySkillsClearRangeIE(this.g_aTextRange[iRangeIndex]);\n                                this.g_aTextRange[iRangeIndex] = storedRangePre;\n\n                                this.g_aTextRange.push(storedRangePost);\n                                this.g_aHighlightColour.push(this.g_aHighlightColour[iRangeIndex]);\n\n                                this.rw_ieSpecificCallToSetHighlight(storedRangePre, this.g_aHighlightColour[iRangeIndex]);\n                                this.rw_ieSpecificCallToSetHighlight(storedRangePost, this.g_aHighlightColour[iRangeIndex]);\n                            }\n                        }\n                    }\n\n                    selectionRange.execCommand(\"UnSelect\", false, null);\n                } else {\n                    // safari firefox\n                    if (selectionRange == null || p_bForceClear) {\n                        // remove all highlighting\n                        if (!p_bForceClear) {\n                            var agree = false; //confirm(strTmp);\n                            if (!agree) {\n                                return;\n                            }\n                        }\n\n                        //                    todo if(g_bPersistAnnotations)\n                        //                    {   // added as if persisting but want to clear highlights to refresh turn persistence off\n                        //                        // this allows this data to not be lost as well as not sending bad data.\n                        //                        g_strStoredHighlightData = null;\n                        //                        g_strStoredHighlightUnprocessedData = null;\n                        //                    }\n\n                        var itemsToRemove = this.g_aTextRange;\n                        this.g_aTextRange = new Array();\n                        this.g_aHighlightColour = new Array();\n                        var ssdom = new _SSDOM.SSDOM();\n                        for (var i = 0; i < itemsToRemove.length; i++) {\n                            var tmpRange = itemsToRemove[i];\n                            tmpRange.refresh();\n                            //todo move getListOfHighlightableNodes\n                            this.rw_removeHighlight(this.getListOfHighlightableNodes(tmpRange.startCaret, tmpRange.endCaret));\n                        }\n                    } else {\n                        //selectionRange is a THDomRange, refresh before use\n                        selectionRange.refresh();\n                        for (var iRangeIndex = 0; iRangeIndex < this.g_aTextRange.length; iRangeIndex++) {\n                            //check that our text ranges from the stored to the selection do not conflict\n                            // check that they relate to the same body (in case of iframes)\n                            var tmpDomRange = this.g_aTextRange[iRangeIndex];\n\n                            if (selectionRange.body != tmpDomRange.body) {\n                                // cannot overlap.\n                                continue;\n                            }\n\n                            var nResult = selectionRange.compareRange(tmpDomRange);\n                            //noinspection FallthroughInSwitchStatementJS\n                            switch (nResult) {\n                                case Constants.THDomRange_ERROR:\n                                    window.status = \"Error occurred when trying to remove a highlight.\";\n                                    break;\n                                case Constants.THDomRange_TARGET_SAME:\n                                case Constants.THDomRange_TARGET_INSIDE:\n                                    // new selection contains an existing range entirely, remove existing\n\n                                    tmpDomRange.refresh();\n                                    this.rw_removeHighlight(this.getListOfHighlightableNodes(tmpDomRange.startCaret, tmpDomRange.endCaret));\n\n                                    this.g_aTextRange.splice(iRangeIndex, 1);\n                                    this.g_aHighlightColour.splice(iRangeIndex, 1);\n\n                                    --iRangeIndex;\n\n                                    selectionRange.refresh();\n                                    break;\n\n                                case Constants.THDomRange_TARGET_INCLUDES_THIS:\n                                case Constants.THDomRange_TARGET_INCLUDES_THIS_AT_START:\n                                case Constants.THDomRange_TARGET_INCLUDES_THIS_AT_END:\n                                    // new selection entirely inside an existing range\n                                    this.case1SFF(iRangeIndex, selectionRange, nResult);\n                                    ++iRangeIndex;\n                                    break;\n                                case Constants.THDomRange_OVERLAPS_START_OF_TARGET:\n                                    // new selection before and ends in an existing range\n                                    this.case2SFF(iRangeIndex, selectionRange);\n                                    break;\n                                case Constants.THDomRange_OVERLAPS_END_OF_TARGET:\n                                    // new selection starts in and ends after an existing range\n                                    this.case3SFF(iRangeIndex, selectionRange);\n                                    break;\n\n                                case Constants.THDomRange_AFTER_TARGET:\n                                    break;\n                                case Constants.THDomRange_BEFORE_TARGET:\n                                    break;\n                                default: //do nothing\n                            }\n                        }\n                    }\n\n                    ssdom.rw_collapseSelection();\n                }\n\n                //            todo if(g_bPersistAnnotations && g_bPersistHighlights &&\n                //                typeof(rw_storeHighlightData) != \"undefined\")\n                //            {   // call if pkt with student id given and not a teacher\n                //                rw_storeHighlightData();\n                //            }\n\n                // just in case have collect screen open as this would continue to show highlights.\n                //            if(g_abVisible[POPUP_COLLECT])\n                //            {\n                //                $rw_divPress(POPUP_COLLECT);\n                //            }\n            } catch (exc) {\n                //console.log(\"Error in method: \" + exc.name + \" \" + exc.message + \" \" + exc.description + \" \" + exc.toString());\n            }\n        }\n\n        //*!\n        /* refresh all the text ranges stored in order to keep only those\n         that still apply\n         need to refresh the stored text ranges if a navigation\n         occurs or the internet explorer window closes\n         Returns true if an item has been removed\n         */\n\n    }, {\n        key: 'studySkillsHTMLRefreshRanges',\n        value: function studySkillsHTMLRefreshRanges() {\n            try {\n                var tempTextRange = null;\n                var blnItemRemoved = false;\n                var iRangeIndex = 0;\n\n                //enumerate the structure to see if there are any dead references\n                for (iRangeIndex = 0; iRangeIndex < this.g_aTextRange.length; iRangeIndex++) {\n                    tempTextRange = this.g_aTextRange[iRangeIndex];\n\n                    try {\n                        if (tempTextRange.text == null || tempTextRange.text == \"\") {\n                            //no range\n                            tempTextRange = null;\n                        }\n                    } catch (exe) {\n                        // console.logE(exe);\n                        //textrange has been lost\n                        tempTextRange = null;\n                    }\n\n                    if (tempTextRange == null) {\n                        //textrange dead so remove it\n                        this.g_aTextRange.splice(iRangeIndex, 1);\n                        this.g_aHighlightColour.splice(iRangeIndex, 1);\n\n                        blnItemRemoved = true;\n\n                        //take step back and following items moved down a number\n                        iRangeIndex--;\n                    }\n                }\n\n                return blnItemRemoved;\n            } catch (exc) {\n                // console.log(\"Error in method studySkillsHTMLRefreshRanges: \" + exc.toString());\n                return false;\n            }\n        }\n\n        // selection entirely inside range\n        // nPos the point in the g_aTextRange array that conflicts\n        // selectionRange the new selection being made, THDomRange\n\n    }, {\n        key: 'case1SFF',\n        value: function case1SFF(p_nPos, p_selectionRange, p_thDomRangeType) {\n            // remove entirely\n            // add new items (original before, original after)  selection added by caller\n            var ssdom = new _SSDOM.SSDOM();\n            // store positions before changing dom\n            var strOrigColour = this.g_aHighlightColour[p_nPos];\n            var origDomRange = this.g_aTextRange[p_nPos];\n            origDomRange.refresh();\n            var startLeftRefPt = origDomRange.startRef;\n            var endLeftRefPt = p_selectionRange.startRef;\n            var startRightRefPt = p_selectionRange.endRef;\n            var endRightRefPt = origDomRange.endRef;\n\n            // remove highlighting\n            this.rw_removeHighlight(this.getListOfHighlightableNodes(origDomRange.startCaret, origDomRange.endCaret));\n            this.g_aTextRange.splice(p_nPos, 1);\n            this.g_aHighlightColour.splice(p_nPos, 1);\n\n            //  add the split highlights\n            // Check if boundary match in which case only re-add one\n\n            var startCaret;\n            var endCaret;\n            var result;\n            var tmpDomRange;\n\n            // if selection is at the start then nothing to add to the left\n            if (p_thDomRangeType != Constants.THDomRange_TARGET_INCLUDES_THIS_AT_START) {\n                // add left\n                var caretRange = new _THCaretRange.THCaretRange(p_selectionRange.body, startLeftRefPt.path, startLeftRefPt.offset, endLeftRefPt.path, endLeftRefPt.offset);\n                startCaret = caretRange.leftCaret;\n                endCaret = caretRange.rightCaret;\n\n                result = this.rw_setHighlight(startCaret.node, startCaret.offset, endCaret.node, endCaret.offset, strOrigColour);\n\n                tmpDomRange = new _THDomRange.THDomRange(result.start, 0, result.end, result.end.nodeValue.length);\n                this.g_aTextRange.push(tmpDomRange);\n                this.g_aHighlightColour.push(strOrigColour);\n            }\n\n            // if selection is at the end then nothing to add to the right\n            if (p_thDomRangeType != Constants.THDomRange_TARGET_INCLUDES_THIS_AT_END) {\n                // add right\n                caretRange = new _THCaretRange.THCaretRange(p_selectionRange.body, startRightRefPt.path, startRightRefPt.offset, endRightRefPt.path, endRightRefPt.offset);\n                startCaret = caretRange.leftCaret;\n                endCaret = caretRange.rightCaret;\n\n                result = this.rw_setHighlight(startCaret.node, startCaret.offset, endCaret.node, endCaret.offset, strOrigColour);\n\n                tmpDomRange = new _THDomRange.THDomRange(result.start, 0, result.end, result.end.nodeValue.length);\n                this.g_aTextRange.push(tmpDomRange);\n                this.g_aHighlightColour.push(strOrigColour);\n            }\n            p_selectionRange.refresh();\n            // the middle gets added by caller.\n        }\n\n        // selection ends in range\n\n    }, {\n        key: 'case2SFF',\n        value: function case2SFF(nPos, selectionRange) {\n            // remove entirely\n            // add new item (original after)  selection added by caller\n            var ssdom = new _SSDOM.SSDOM();\n            // store positions before changing dom\n            var strOrigColour = this.g_aHighlightColour[nPos];\n            var origDomRange = this.g_aTextRange[nPos];\n            origDomRange.refresh();\n            var startRightRefPt = selectionRange.endRef;\n            var endRightRefPt = origDomRange.endRef;\n\n            // remove highlighting\n            this.rw_removeHighlight(this.getListOfHighlightableNodes(origDomRange.startCaret, origDomRange.endCaret));\n            this.g_aTextRange.splice(nPos, 1);\n            this.g_aHighlightColour.splice(nPos, 1);\n\n            //  add the split highlights\n            // add right\n            var caretRange = new _THCaretRange.THCaretRange(selectionRange.body, startRightRefPt.path, startRightRefPt.offset, endRightRefPt.path, endRightRefPt.offset);\n            var startCaret = caretRange.leftCaret;\n            var endCaret = caretRange.rightCaret;\n\n            var result = this.rw_setHighlight(startCaret.node, startCaret.offset, endCaret.node, endCaret.offset, strOrigColour);\n\n            var tmpDomRange = new _THDomRange.THDomRange(result.start, 0, result.end, result.end.nodeValue.length);\n            this.g_aTextRange.push(tmpDomRange);\n            this.g_aHighlightColour.push(strOrigColour);\n\n            selectionRange.refresh();\n            // the middle gets added by caller.\n        }\n\n        // selection starts in range\n\n    }, {\n        key: 'case3SFF',\n        value: function case3SFF(nPos, selectionRange) {\n            // remove entirely\n            // add new item (original before)  selection added by caller\n            var ssdom = new _SSDOM.SSDOM();\n            // store positions before changing dom\n            var strOrigColour = this.g_aHighlightColour[nPos];\n            var origDomRange = this.g_aTextRange[nPos];\n            origDomRange.refresh();\n            var startLeftRefPt = origDomRange.startRef;\n            var endLeftRefPt = selectionRange.startRef;\n\n            // remove highlighting\n            this.rw_removeHighlight(this.getListOfHighlightableNodes(origDomRange.startCaret, origDomRange.endCaret));\n            this.g_aTextRange.splice(nPos, 1);\n            this.g_aHighlightColour.splice(nPos, 1);\n\n            //  add the split highlights\n            // add left\n            var caretRange = new _THCaretRange.THCaretRange(selectionRange.body, startLeftRefPt.path, startLeftRefPt.offset, endLeftRefPt.path, endLeftRefPt.offset);\n\n            var startCaret = caretRange.leftCaret;\n            var endCaret = caretRange.rightCaret;\n\n            var result = this.rw_setHighlight(startCaret.node, startCaret.offset, endCaret.node, endCaret.offset, strOrigColour);\n\n            var tmpDomRange = new _THDomRange.THDomRange(result.start, 0, result.end, result.end.nodeValue.length);\n            this.g_aTextRange.push(tmpDomRange);\n            this.g_aHighlightColour.push(strOrigColour);\n\n            selectionRange.refresh();\n            // the middle gets added by caller.\n        }\n    }]);\n\n    return StudySkillsHighlighting;\n}(_HighlightBaseController.HighlightBaseController);\n\n},{\"src/Constants/Constants\":1,\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/DomNavigation\":3,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/Highlighting/HighlightBaseController\":7,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/THDomRange\":29,\"src/SpeechStream/THReturnObject\":32,\"src/SpeechStream/Utilities/Utilities\":34}],12:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ElementHelper = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevinml on 25/04/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _LoopState = require(\"src/SpeechStream/MathJax/LoopState\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ElementHelper = exports.ElementHelper = function () {\n    function ElementHelper() {\n        _classCallCheck(this, ElementHelper);\n    }\n\n    /**\n     * Check if is leaf character that shouldn't be treated as element to loop in to.\n     * @param p_strType\n     */\n\n\n    _createClass(ElementHelper, [{\n        key: \"isTokenType\",\n        value: function isTokenType(p_strType) {\n            return p_strType == \"entity\" || p_strType == \"char\" || p_strType == \"entities\" || p_strType == \"chars\";\n        }\n\n        // Recursive loop through the dom.\n        // Adds elements in given range to the list\n        // Returns true when gone as far as it needs to go.\n\n    }, {\n        key: \"looper\",\n        value: function looper(dataElem, spanId, state) {\n            // check for <mfenced open= close= mathml case with section closed by these throwing count off\n            if (dataElem != null) {\n                var jaxSpanid = dataElem.spanID ? dataElem.spanID : dataElem.CHTMLnodeID;\n                jaxSpanid = jaxSpanid != null && jaxSpanid != undefined ? jaxSpanid : dataElem.PHTMLspanID;\n\n                // if (jaxSpanid!=null){\n                if (jaxSpanid != null && jaxSpanid == spanId) {\n                    state.pushToList(dataElem);\n                    ++state.count;\n                    return true;\n                } else {\n                    if (dataElem.data != null) {\n                        for (var i = 0; i < dataElem.data.length; i++) {\n                            var found = this.looper(dataElem.data[i], spanId, state);\n                            if (found) {\n\n                                return found;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return false;\n        }\n    }, {\n        key: \"getList\",\n        value: function getList(root, spanId) {\n            var state = new _LoopState.LoopState();\n            this.looper(root, spanId, state);\n\n            return state.getList();\n        }\n    }]);\n\n    return ElementHelper;\n}();\n\n},{\"src/SpeechStream/MathJax/LoopState\":14}],13:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevinml on 25/04/2016.\n */\n\nvar HighlightData = exports.HighlightData = function HighlightData() {\n    _classCallCheck(this, HighlightData);\n\n    this.style = null;\n    this.fg = null;\n    this.bg = null;\n    this.lastSpanId = 0;\n};\n\n},{}],14:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevinml on 25/04/2016.\n */\n\nvar LoopState = exports.LoopState = function () {\n    function LoopState() {\n        _classCallCheck(this, LoopState);\n\n        this.count = 1; // When loop starts already at the second element\n        this.list = [];\n    }\n\n    _createClass(LoopState, [{\n        key: \"pushToList\",\n        value: function pushToList(obj) {\n            this.list.push(obj);\n        }\n    }, {\n        key: \"getList\",\n        value: function getList() {\n            return this.list;\n        }\n    }]);\n\n    return LoopState;\n}();\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MathJaxHighlighter = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevinml on 25/04/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _HighlightData = require('src/SpeechStream/MathJax/HighlightData');\n\nvar _ElementHelper = require('src/SpeechStream/MathJax/ElementHelper');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MathJaxHighlighter = exports.MathJaxHighlighter = function () {\n    function MathJaxHighlighter(jax) {\n        _classCallCheck(this, MathJaxHighlighter);\n\n        this.highlightDataStore = {}; // stores highlight data for given type.\n        this.highlightJaxRoot = jax.root;\n        this.highlightClearLast = true;\n        this.elementHelper = new _ElementHelper.ElementHelper();\n    }\n\n    // Set whether or not the previous highlight should be cleared when adding new one.\n    // If set to false and highlights added the old highlights are not stored and adding a new highlight\n    // does not clear the old one.  Calling clearHighlights() will not remove them.  Setting this to true\n    // will only affect highlights added after it is set true.\n    // The caller needs to keep its own record of highlights added while this is false.\n\n\n    _createClass(MathJaxHighlighter, [{\n        key: 'setClearLastHighlight',\n        value: function setClearLastHighlight(b) {\n            this.highlightClearLast = b;\n        }\n    }, {\n        key: 'setHighlightStyle',\n\n\n        // type \"context\" or \"word\" or custom value matched to highlightNodes call.\n        // style  \"outline\", \"underline\", \"fg\", \"bg\", or \"none\" (\"\" or null count as none)\n        // r g b value 0-255\n        // returns true if style updated, false otherwise\n        value: function setHighlightStyle(type, style, r, g, b) {\n            if (typeof type !== \"string\") {\n                return false;\n            }\n\n            // need to check if there is currently highlighting for this type, if so need to remove this\n            // prior to changing or removing the style for this type.\n            if (this.highlightDataStore[type] && this.highlightDataStore.hasOwnProperty(type)) {\n                var tmpData = this.highlightDataStore[type];\n                if (tmpData && tmpData.lastSpanId > 0) {\n                    this.clearHighlightNodesImpl(type, tmpData.style, tmpData.lastSpanId);\n                }\n            }\n\n            if (style === null) {\n                delete this.highlightDataStore[type];\n                return true;\n            }\n\n            if (typeof style === \"string\") {\n                style = style.toLowerCase();\n            } else {\n                return false;\n            }\n\n            if (style === \"\" || style === \"none\") {\n                delete this.highlightDataStore[type];\n                return true;\n            }\n\n            var nR, nG, nB;\n            try {\n                nR = this.parseColor(r);\n                nG = this.parseColor(g);\n                nB = this.parseColor(b);\n            } catch (err) {\n                // invalid values passed in\n                return false;\n            }\n\n            var data;\n\n            if (this.highlightDataStore[type] && this.highlightDataStore.hasOwnProperty(type)) {\n                data = this.highlightDataStore[type];\n                // If is already highlight and adding highlight might want existing fg or bg kept.\n                // if existing style is not highlight, always want to clear values.\n                if (data.style !== \"highlight\") {\n                    data.fg = null;\n                    data.bg = null;\n                }\n            } else {\n                data = new _HighlightData.HighlightData();\n            }\n\n            if (style === \"fg\") {\n                data.style = \"highlight\";\n                data.fg = \"rgb(\" + nR + \",\" + nG + \",\" + nB + \")\";\n            } else if (style === \"bg\") {\n                data.style = \"highlight\";\n                data.bg = \"rgb(\" + nR + \",\" + nG + \",\" + nB + \")\";\n            } else if (style === \"outline\") {\n                data.style = style;\n                data.fg = \"rgb(\" + nR + \",\" + nG + \",\" + nB + \")\";\n                data.bg = null;\n            } else if (style === \"underline\") {\n                data.style = style;\n                data.fg = \"rgb(\" + nR + \",\" + nG + \",\" + nB + \")\";\n                data.bg = null;\n            }\n\n            this.highlightDataStore[type] = data;\n            return true;\n        }\n    }, {\n        key: 'highlightNodes',\n\n\n        // Add highlighting to elements from given range\n        // type is used to select the style set for that type with setHighlightStyle (i.e. \"context\" or \"word\")\n        // start and end give the inclusive range to highlight.\n        value: function highlightNodes(type, spanId) {\n            var data;\n            if (this.highlightDataStore[type] && this.highlightDataStore.hasOwnProperty(type)) {\n                data = this.highlightDataStore[type];\n            } else {\n                return;\n            }\n            if (data.style === null) {\n                return;\n            }\n\n            if (data.lastSpanId > 0 && this.highlightClearLast) {\n                this.clearHighlightNodesImpl(type, data.style, data.lastSpanId);\n            }\n\n            data.lastSpanId = spanId;\n            //                data.lastEnd = end;\n\n            // Pass root, then count for position of element for the start and end point to fetch, inclusive.\n            var list = this.elementHelper.getList(this.highlightJaxRoot, spanId);\n\n            //console.log(\"Highlight start \" + start + \"   end   \" + end);\n\n            this.highlightImpl(list, type, data.style, data.fg, data.bg);\n        }\n    }, {\n        key: 'clearHighlights',\n\n\n        // clear all highlights\n        value: function clearHighlights() {\n            for (var type in this.highlightDataStore) {\n                if (this.highlightDataStore.hasOwnProperty(type)) {\n                    var data = this.highlightDataStore[type];\n\n                    this.clearHighlightNodesImpl(type, \"\", data.lastSpanId);\n                    data.lastSpanId = 0;\n                }\n            }\n        }\n    }, {\n        key: 'clearHighlightNodes',\n        value: function clearHighlightNodes(type, spanId) {\n            this.clearHighlightNodesImpl(type, \"\", spanId);\n        }\n    }, {\n        key: 'parseColor',\n        value: function parseColor(val) {\n            var tmpVal;\n            if (typeof val === \"string\") {\n                tmpVal = parseInt(val, 10);\n            } else if (typeof val === \"number\") {\n                tmpVal = val;\n            } else {\n                throw \"invalid\";\n            }\n            if (tmpVal < 0 || tmpVal > 255) {\n                throw \"invalid\";\n            }\n\n            return tmpVal;\n        }\n    }, {\n        key: 'clearHighlightNodesImpl',\n        value: function clearHighlightNodesImpl(type, style, spanID) {\n            var list = this.elementHelper.getList(this.highlightJaxRoot, spanID);\n\n            for (var i = 0, nLen = list.length; i < nLen; i++) {\n                var item = list[i];\n                {\n                    if (style === \"\" || style === \"outline\") {\n                        delete item.mathoutline;\n                    }\n\n                    if (style === \"\" || style === \"underline\") {\n                        if (item.previousline) {\n                            this.removeFromPrevious(item.previousline, type);\n                            // set to what is left as last in list\n                            var len = item.previousline.length;\n                            if (len > 0) {\n                                item.mathunderline = item.previousline[len - 1].val;\n                            } else {\n                                item.mathunderline = \"\";\n                            }\n                        } else {\n                            item.mathunderline = \"\";\n                        }\n                    }\n\n                    if (style === \"\" || style === \"highlight\") {\n                        if (item.previouscolor) {\n                            this.removeFromPrevious(item.previouscolor, type);\n                            // set color to what is left as last in list\n                            var len = item.previouscolor.length;\n                            if (len > 0) {\n                                item.mathcolor = item.previouscolor[len - 1].val;\n                            } else {\n                                item.mathcolor = \"\"; // space rather than \"\" due to bug in mathjax where will ignore \"\"\n                            }\n                        } else {\n                            item.mathcolor = \" \"; // space rather than \"\" due to bug in mathjax where will ignore \"\"\n                        }\n                        delete item.mathbackground;\n                    }\n\n                    var spanElem = null;\n                    try {\n                        spanElem = item.HTMLspanElement();\n                    } catch (e) {}\n                    if (spanElem == null) {\n                        try {\n                            spanElem = item.CHTMLnodeElement();\n                        } catch (e) {}\n                    }\n                    if (spanElem == null) {\n                        return;\n                    }\n\n                    var bSuccess = true;\n                    if (item.HTMLremoveColor != undefined) {\n                        bSuccess = this.setupPostFix(spanElem, type, true);\n                    }\n\n                    if (bSuccess) {\n                        try {\n                            item.HTMLhandleColor(spanElem);\n                        } catch (err) {\n                            item.PHTMLhandleColor(spanElem);\n                        }\n                    }\n                    this.setdownPostFix();\n\n                    // remove the background\n                    var bSuccess = true;\n                    if (item.HTMLremoveColor != undefined) {\n                        bSuccess = this.setupPostFix(spanElem, type, false);\n                    }\n                    if (bSuccess) {\n                        if (item.HTMLremoveColor != undefined) {\n                            item.HTMLremoveColor();\n                        } else {\n                            var sp;\n                            try {\n                                sp = item.HTMLspanElement();\n                            } catch (e) {\n                                sp = item.CHTMLnodeElement();\n                            }\n                            if (sp != null) {\n                                sp.style.background = \"\";\n                                sp.style.color = \"\";\n                            }\n                        }\n                    }\n                    this.setdownPostFix();\n                    if (item.HTMLremoveColor != undefined) {\n                        var sp;\n                        try {\n                            sp = item.HTMLspanElement();\n                        } catch (e) {\n                            sp = item.CHTMLnodeElement();\n                        }\n                        if (sp != null) {\n                            sp.style.background = \"\";\n                            sp.style.color = \"\";\n                        }\n                    }\n\n                    //console.log(\"done\");\n                }\n            }\n        }\n    }, {\n        key: 'highlightImpl',\n        value: function highlightImpl(list, type, style, fg, bg) {\n            for (var i = 0, nLen = list.length; i < nLen; i++) {\n                var item = list[i];\n                var colorHandle = item.HTMLhandleColor ? item.HTMLhandleColor : item.CHTMLhandleColor;\n                if (typeof colorHandle == \"function\") {\n                    var spanElem = null;\n\n                    try {\n                        spanElem = item.CHTMLnodeElement();\n                    } catch (err) {}\n                    if (spanElem == null) {\n                        try {\n                            spanElem = item.HTMLspanElement();\n                        } catch (err) {}\n                    }\n\n                    if (spanElem == null) {\n                        return;\n                    }\n\n                    if (style === \"highlight\") {\n                        if (bg != null) {\n                            item.mathbackground = bg;\n                        }\n\n                        if (fg != null) {\n                            if (!item.previouscolor) {\n                                item.previouscolor = [];\n                                if (item.mathcolor) {\n                                    // this pushes the current color if set.  If this exists without the\n                                    // array existing, then it is set by source other than the toolbar.\n                                    item.previouscolor.push({ \"key\": \"\", \"val\": item.mathcolor });\n                                } else {\n                                    // note this due to but in mathjax relating to setting mathcolor to \"\" (you can't)\n                                    // until you can you need to do this.\n                                    var ssdom = new _SSDOM.SSDOM();\n                                    var tmp = ssdom.getComputedStyle(spanElem);\n                                    var col = tmp.color;\n                                    //                                if(col)\n                                    //                                {\n                                    //                                    item.previouscolor.push({\"key\":\"\", \"val\":col});\n                                    //                                }\n                                    //                                else\n                                    //                                {\n                                    //                                    item.previouscolor.push({\"key\":\"\", \"val\":\"rgb(0,0,0)\"});\n                                    //                                }\n                                }\n                            } else {\n                                // This just removes any in previous list that matches the type about to be added\n                                // so is only in list once.\n                                this.removeFromPrevious(item.previouscolor, type);\n                            }\n\n                            item.previouscolor.push({ \"key\": type, \"val\": fg });\n                            item.mathcolor = fg;\n                        }\n                    } else if (style === \"outline\") {\n                        item.mathoutline = fg + \"thin solid\";\n                    } else if (style === \"underline\") {\n                        if (!item.previousline) {\n                            item.previousline = [];\n                            if (item.textDecoration) {\n                                item.previousline.push({ \"key\": \"\", \"val\": item.textDecoration });\n                            }\n                        } else {\n                            this.removeFromPrevious(item.previousline, type);\n                        }\n                        item.previousline.push({ \"key\": type, \"val\": \"underline\" });\n\n                        item.mathunderline = \"underline\";\n                        // Currently cannot set text-decoration color so color ignored for this\n                    }\n\n                    //console.log(\"Highlight \" + type + \"  \" + item.toString() + \"   \"+ i);\n\n\n                    // need to add something to make id unique, so can be sure it is removed.\n                    // This is specific to implementation in mathjax, but with request to work by calling in\n                    // rather than plugin inside mathjax, this is needed.\n\n                    var bSuccess = this.setupPostFix(spanElem, type, true);\n                    if (bSuccess) {\n                        try {\n                            item.HTMLhandleColor(spanElem);\n                        } catch (err) {\n                            item.PHTMLhandleColor(spanElem);\n                        }\n                    }\n                    this.setdownPostFix();\n\n                    //  console.log(\"Highlight Done\");\n                }\n            }\n        }\n    }, {\n        key: 'removeFromPrevious',\n        value: function removeFromPrevious(arr, type) {\n            for (var i = 0; i < arr.length; i++) {\n                if (arr[i].key === type) {\n                    arr.splice(i, 1);\n                    return;\n                }\n            }\n        }\n\n        /**\n         * Returns true if things work.\n         *\n         * @param p_span\n         * @param p_strType\n         * @param p_bAdding  true if adding the colour so span should not already exist\n         */\n\n    }, {\n        key: 'setupPostFix',\n        value: function setupPostFix(p_span, p_strType, p_bAdding) {\n            try {\n                var HTMLCSS = MathJax.OutputJax[\"HTML-CSS\"] ? MathJax.OutputJax[\"HTML-CSS\"] : MathJax.OutputJax[\"CommonHTML\"];\n                var strTypeAsAdded = \"-\" + p_strType;\n\n                if (p_bAdding) {\n                    // check if element like this already exists\n                    var strSpanID = p_span.id + HTMLCSS.idPostfix + strTypeAsAdded;\n                    if (document.getElementById(strSpanID) != null) {\n                        // already exists, don't add highlight as will add to bad state.\n                        return false;\n                    }\n                }\n\n                if (typeof HTMLCSS.idPostfix == \"string\") {\n                    this.m_strTmpPostFix = HTMLCSS.idPostfix;\n                    HTMLCSS.idPostfix += strTypeAsAdded;\n                } else {\n                    this.m_strTmpPostFix = \"\";\n                    HTMLCSS.idPostfix = strTypeAsAdded;\n                }\n            } catch (err) {\n                //console.logE(err);\n                // In case their internal logic changes, this will probably stop highlighting working properly\n                // but will stop toolbar breaking completely.\n                return false;\n            }\n            return true;\n        }\n\n        /**\n         * Return idPostFix to previous state, based on stored m_strTmpPostFix.\n         * If it is null, then idPostFix hasn't been altered,\n         * If it is null, then idPostFix was altered and no previous value.\n         * If it is string, then idPostFix was altered and need to return.\n         */\n\n    }, {\n        key: 'setdownPostFix',\n        value: function setdownPostFix() {\n            try {\n                var HTMLCSS = MathJax.OutputJax[\"HTML-CSS\"] ? MathJax.OutputJax[\"HTML-CSS\"] : MathJax.OutputJax[\"CommonHTML\"];\n\n                if (this.m_strTmpPostFix == \"\") {\n                    HTMLCSS.idPostfix = null;\n                    delete HTMLCSS.idPostfix;\n                }\n                if (this.m_strTmpPostFix != null) {\n                    HTMLCSS.idPostfix = this.m_strTmpPostFix;\n                    this.m_strTmpPostFix = null;\n                }\n                // else null and nothing to do\n            } catch (err) {\n                // console.logE(err);\n                // In case their internal logic changes, this will probably stop highlighting working properly\n                // but will stop toolbar breaking completely.\n            }\n        }\n    }]);\n\n    return MathJaxHighlighter;\n}();\n\n},{\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/MathJax/ElementHelper\":12,\"src/SpeechStream/MathJax/HighlightData\":13}],16:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevinml on 21/04/2016.\n */\n\nvar MathSpeak = exports.MathSpeak = function () {\n    function MathSpeak() {\n        _classCallCheck(this, MathSpeak);\n\n        sre.System.getInstance().setupEngine({ semantics: false, domain: 'mathspeak', style: 'default' });\n        this.instance = sre.System.getInstance();\n    }\n    /**\n     *\n     * @param p_node should be mathJax node\n     */\n\n\n    _createClass(MathSpeak, [{\n        key: 'getTextFromMathJax',\n        value: function getTextFromMathJax(p_node) {\n            if (p_node.isMathJax) {\n                var tmpNode = p_node;\n                while (tmpNode != null && tmpNode.isMathJax && !tmpNode.id) {\n                    tmpNode = tmpNode.parentNode;\n                }\n                var strMathCode;\n                if (tmpNode && tmpNode.id) {\n                    strMathCode = \"math:\" + tmpNode.id + \";\";\n                } else {\n                    strMathCode = \"math:none;\";\n                }\n            }\n\n            var jax = MathJax.Hub.getJaxFor(p_node);\n            if (jax != null) {\n                var mml = null;\n                try {\n                    mml = jax.root.toMathML(\"\");\n                    if (mml != null || mml.length > 0) {\n                        return strMathCode + mml;\n                    }\n                } catch (err) {\n                    // console.log(err);\n                }\n                return \"\";\n            } else {\n                return \"\";\n            }\n        }\n    }, {\n        key: 'getSpeech',\n        value: function getSpeech(elementID) {\n            if (typeof elementID == 'string') {\n                var element = document.getElementById(elementID);\n                if (element != null && element.isMathJax == true) {\n                    var mathJaxText = this.getMathMLText(elementID);\n                    var mathJaxObject = this.getMathMLObject(elementID);\n                    mathJaxText = mathJaxText.replace(/<\\/([^>]+)/g, \"</mathml:$1>\");\n                    mathJaxText = mathJaxText.replace(/<([^>]+)/g, \"<mathml:$1>\");\n                    return this.instance.processExpression(this.getMathMLWithBookmarks(mathJaxObject, mathJaxText, false));\n                }\n            }\n            return \"\";\n        }\n    }, {\n        key: 'getSpeechWithBookmarks',\n        value: function getSpeechWithBookmarks(elementID) {\n            if (typeof elementID == 'string') {\n                var element = document.getElementById(elementID);\n                if (element != null && element.isMathJax == true) {\n                    var element = document.getElementById(elementID);\n                    var mathJaxText = this.getMathMLText(elementID);\n                    var mathJaxObject = this.getMathMLObject(elementID);\n                    return this.instance.processExpression(this.getMathMLWithBookmarks(mathJaxObject, mathJaxText, true));\n                }\n            }\n            return \"\";\n        }\n    }, {\n        key: 'getSpeechWithBookmarksFromElement',\n        value: function getSpeechWithBookmarksFromElement(element) {\n            if (element != null && element.isMathJax == true) {\n                var text = \"\";\n                try {\n                    var mathJaxText = this.getMathMLText(element);\n                    var mathJaxObject = this.getMathMLObject(element);\n\n                    var math = this.getMathMLWithBookmarks(mathJaxObject, mathJaxText, true);\n                    if (math != \"\") {\n                        text = this.instance.processExpression(math);\n                    }\n                } catch (err) {\n                    // console.log(err);\n                }\n                return text;\n            }\n            return \"\";\n        }\n    }, {\n        key: 'getMathMLOriginalText',\n        value: function getMathMLOriginalText(elementID) {\n            if (typeof elementID == 'string') {\n                var element = document.getElementById(elementID);\n                if (element != null && element.isMathJax == true) {\n\n                    var element = document.getElementById(elementID);\n                    return MathJax.Hub.getJaxFor(element).originalText;\n                }\n            }\n            return \"\";\n        }\n    }, {\n        key: 'getMathMLText',\n        value: function getMathMLText(element) {\n            if (element != null && element.isMathJax == true) {\n                var mathJaxText = MathJax.Hub.getJaxFor(element).root.toMathML();\n                var oParser = new DOMParser();\n                var oDOM = oParser.parseFromString(mathJaxText, \"text/xml\");\n                if (oDOM.documentElement.nodeName == \"parsererror\" || oDOM.documentElement.firstChild.nodeName == \"parsererror\") {\n                    console.error(\"Mathml is invalid, Please contact page provider\");\n                    throw \"Mathml is invalid, Please contact page provider\";\n                    mathJaxText = \"\";\n                }\n                return mathJaxText;\n            }\n            return \"\";\n        }\n    }, {\n        key: 'getMathMLObject',\n        value: function getMathMLObject(element) {\n            if (element != null && element.isMathJax == true) {\n                return MathJax.Hub.getJaxFor(element).root;\n            }\n\n            return \"\";\n        }\n    }, {\n        key: 'isMathML',\n        value: function isMathML(elementID) {\n            if (typeof elementID == 'string') {\n                var element = document.getElementById(elementID);\n                if (element != null && element.isMathJax == true) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'getMathMLWithBookmarks',\n        value: function getMathMLWithBookmarks(mathsObject, mathsText, includeBookmarks) {\n\n            if (mathsText != null) {\n                mathsText = mathsText.replace(/<mathml:math.*>/, '<math xmlns=\"http://www.w3.org/1998/Math/MathML\">');\n            }\n            if (mathsObject.data != undefined) {\n                for (var i = 0; i < mathsObject.data.length; i++) {\n                    if (mathsObject.data[i] != null) {\n                        var jaxSpanid = mathsObject.data[i].spanID ? mathsObject.data[i].spanID : mathsObject.data[i].CHTMLnodeID;\n                        jaxSpanid = jaxSpanid != null && jaxSpanid != undefined ? jaxSpanid : mathsObject.data[i].PHTMLspanID;\n\n                        if (mathsObject.data[i].toMathML && mathsObject.data[i].toMathML() && jaxSpanid != undefined && mathsObject.data[i].data[0] != undefined && mathsObject.data[i].data[0].data[0] != undefined && mathsObject.data[i].data[0].data[0].toMathML == undefined) {\n\n                            var span = mathsObject.data[i].toMathML();\n                            if (mathsText.indexOf(span) == -1) {\n                                span = span.replace(/>.*</, \">\" + mathsObject.data[i].data[0].data[0] + \"<\");\n                            }\n                            if (includeBookmarks) {\n                                var repl = span.replace('>', ' bookmark =\"' + jaxSpanid + '\">');\n                            } else {\n                                var repl = span.replace('>', ' nobookmark =\"\">');\n                            }\n                            mathsText = mathsText.replace(span, repl);\n                        }\n                        mathsText = this.getMathMLWithBookmarks(mathsObject.data[i], mathsText, includeBookmarks);\n                    }\n                }\n            }\n            return mathsText;\n        }\n    }, {\n        key: 'getMathMLTextWithBookmarks',\n        value: function getMathMLTextWithBookmarks(elementID) {\n            if (typeof elementID == 'string') {\n                var element = document.getElementById(elementID);\n                if (element != null && element.isMathJax == true) {\n                    var element = document.getElementById(elementID);\n                    var mathJaxText = this.getMathMLText(elementID);\n                    var mathJaxObject = this.getMathMLObject(elementID);\n\n                    return this.getMathMLWithBookmarks(mathJaxObject, mathJaxText, true);\n                }\n            }\n            return \"\";\n        }\n    }]);\n\n    return MathSpeak;\n}();\n\n;\n\n},{}],17:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevinml on 09/05/2016.\n */\n\nvar Prediction = exports.Prediction = function () {\n    function Prediction() {\n        _classCallCheck(this, Prediction);\n\n        this.curser = 0;\n        // The properties that we copy into a mirrored div.\n        // Note that some browsers, such as Firefox,\n        // do not concatenate properties, i.e. padding-top, bottom etc. -> padding,\n        // so we have to do every single property specifically.\n        this.properties = ['boxSizing', 'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n        'height', 'overflowX', 'overflowY', // copy the scrollbar for IE\n\n        'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',\n\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/font\n        'fontStyle', 'fontVariant', 'fontWeight', 'fontStretch', 'fontSize', 'lineHeight', 'fontFamily', 'textAlign', 'textTransform', 'textIndent', 'textDecoration', // might not make a difference, but better be safe\n\n        'letterSpacing', 'wordSpacing'];\n    }\n\n    _createClass(Prediction, [{\n        key: 'setEditControl',\n        value: function setEditControl(element) {\n            if (element.nodeName == \"TEXTAREA\" || element.nodeName == \"INPUT\" && element.type.toLowerCase() == \"text\") {\n                this.controlEdit = element;\n                this.curser = element.selectionEnd;\n                this.currentChar = this.getCurrentCharacter();\n                element.setSelectionRange(this.curser, this.curser);\n            }\n        }\n    }, {\n        key: 'isEditable',\n        value: function isEditable() {\n            if (typeof this.controlEdit == \"undefined\") {\n                return false;\n            } else {\n                if (this.controlEdit.nodeName == \"TEXTAREA\" || this.controlEdit.nodeName == \"INPUT\" && this.controlEdit.type.toLowerCase() == \"text\") {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'getSentence',\n        value: function getSentence() {\n            try {\n                this.curser = this.controlEdit.selectionEnd;\n            } catch (err) {\n                // console.log(err);\n            }\n            var sel,\n                word = \"\";\n            if (window.getSelection && (sel = window.getSelection()).modify) {\n                var selectedRange = sel.getRangeAt(0);\n\n                sel.collapseToStart();\n\n                if (this.currentChar.charCodeAt(0) == 32 || this.currentChar.charCodeAt(0) == 160) {\n                    sel.modify(\"extend\", \"backward\", \"sentenceboundary\");\n                } else {\n                    sel.modify(\"extend\", \"backward\", \"sentenceboundary\");\n                }\n\n                word = sel.toString();\n\n                // Restore selection\n                sel.removeAllRanges();\n                sel.addRange(selectedRange);\n            } else if ((sel = document.selection) && sel.type != \"Control\") {\n                var range = sel.createRange();\n                range.collapse(true);\n                range.expand(\"sentence\");\n                word = range.text;\n            }\n            // console.log (\"curser \" +this.curser);\n            this.controlEdit.setSelectionRange(this.curser, this.curser);\n            return word;\n        }\n    }, {\n        key: 'getPositionOfPopup',\n        value: function getPositionOfPopup() {\n            var element = this.controlEdit;\n            if (typeof element == \"undefined\") {\n                return { \"top\": -100, \"left\": -100 };\n            }\n            var fontSize = getComputedStyle(element).getPropertyValue('font-size');\n\n            //        var rect = this.placeHolder;\n            //\n            //        rect.style.position = 'absolute';\n\n            if (this.controlEdit.nodeName == \"TEXTAREA\" || this.controlEdit.nodeName == \"INPUT\" && this.controlEdit.type.toLowerCase() == \"text\") {\n\n                //var coordinates = GetScreenCordinates(element);\n\n                var coordinates = this.getCaretCoordinates(element, element.selectionEnd);\n                this.curser = element.selectionEnd;\n\n                var offset = { x: 0, y: 0 };\n                this.GetOffset(element, offset);\n\n                // console.log(\"offset -> \" + offset.y + \" - \" + offset.x);\n\n                // console.log(\"Element Position : \" + coordinates.top + \" / \" + coordinates.left);\n                // console.log(\"Element Scroll : \" + element.scrollTop + \" / \" + element.scrollLeft);\n                // console.log(\"Element offset : \" + element.offsetTop + \" / \" + element.offsetLeft);\n\n\n                var top = offset.y - element.scrollTop + coordinates.top + parseInt(fontSize) + 4 + 'px';\n                var left = offset.x - element.scrollLeft + coordinates.left + 10 + 'px';\n                return { \"top\": top, \"left\": left };\n                /*\n                 rect.style.top = element.offsetTop\n                 - element.scrollTop\n                 + coordinates.top + parseInt(fontSize) + 10\n                 + 'px';\n                  rect.style.left = element.offsetLeft\n                 - element.scrollLeft\n                 + coordinates.left\n                 + 'px';*/\n\n                //   console.log(\"Element Final Position : \" + rect.style.top + \" / \" + rect.style.left);\n            }\n            //        else {\n            //            var coordinates = getSelectionCoords();\n            //\n            //            rect.style.top = coordinates.top + parseInt(fontSize) + 10 + (35)\n            //                + 'px';\n            //            rect.style.left = coordinates.left\n            //                + 'px';\n            //        }\n            return { \"top\": -100, \"left\": -100 };\n        }\n    }, {\n        key: 'GetOffset',\n        value: function GetOffset(object, offset) {\n            if (!object) return;\n            offset.x += object.offsetLeft;\n            offset.y += object.offsetTop;\n\n            this.GetOffset(object.offsetParent, offset);\n        }\n    }, {\n        key: 'getCaretCoordinates',\n        value: function getCaretCoordinates(element, position) {\n            // mirrored div\n            var mirrorDiv = document.getElementById(element.nodeName + '--mirror-div');\n            if (!mirrorDiv) {\n                mirrorDiv = document.createElement('div');\n                mirrorDiv.id = element.nodeName + '--mirror-div';\n                document.body.appendChild(mirrorDiv);\n            }\n\n            var style = mirrorDiv.style;\n            var computed = getComputedStyle(element);\n\n            // default textarea styles\n            style.whiteSpace = 'pre-wrap';\n            if (element.nodeName !== 'INPUT') style.wordWrap = 'break-word'; // only for textarea-s\n\n            // position off-screen\n            style.position = 'absolute'; // required to return coordinates properly\n            style.top = element.offsetTop + parseInt(computed.borderTopWidth) + 'px';\n            style.left = \"400px\";\n            style.visibility = 'hidden';\n\n            // transfer the element's properties to the div\n            this.properties.forEach(function (prop) {\n                style[prop] = computed[prop];\n            });\n            //\n            //        if (isFirefox) {\n            //            style.width = parseInt(computed.width) - 2 + 'px'  // Firefox adds 2 pixels to the padding - https://bugzilla.mozilla.org/show_bug.cgi?id=753662\n            //            // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n            //            if (element.scrollHeight > parseInt(computed.height))\n            //                style.overflowY = 'scroll';\n            //        } else {\n            //            style.overflow = 'hidden';  // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n            //        }\n            style.overflow = 'hidden';\n            mirrorDiv.textContent = element.value.substring(0, position);\n            // the second special handling for input type=\"text\" vs textarea: spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n            if (element.nodeName === 'INPUT') mirrorDiv.textContent = mirrorDiv.textContent.replace(/\\s/g, ' ');\n\n            var span = document.createElement('span');\n            // Wrapping must be replicated *exactly*, including when a long word gets\n            // onto the next line, with whitespace at the end of the line before (#7).\n            // The  *only* reliable way to do that is to copy the *entire* rest of the\n            // textarea's content into the <span> created at the caret position.\n            // for inputs, just '.' would be enough, but why bother?\n            span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all\n            span.style.backgroundColor = \"lightgrey\";\n            mirrorDiv.appendChild(span);\n\n            var coordinates = {\n                top: span.offsetTop + parseInt(computed['borderTopWidth']),\n                left: span.offsetLeft + parseInt(computed['borderLeftWidth'])\n            };\n\n            //alert(coordinates.top + \" \" + coordinates.left);\n            return coordinates;\n        }\n    }, {\n        key: 'setSelectionRange',\n        value: function setSelectionRange(input, selectionStart, selectionEnd) {\n            if (input.setSelectionRange) {\n                input.focus();\n                input.setSelectionRange(selectionStart, selectionEnd);\n            } else if (input.createTextRange) {\n                var range = input.createTextRange();\n                range.collapse(true);\n                range.moveEnd('character', selectionEnd);\n                range.moveStart('character', selectionStart);\n                range.select();\n            } else {\n                input.focus();\n            }\n        }\n    }, {\n        key: 'setCaretPosition',\n        value: function setCaretPosition(elem, caretPos) {\n\n            if (elem != null) {\n                if (elem.createTextRange) {\n                    var range = elem.createTextRange();\n                    range.move('character', caretPos);\n                    range.select();\n                } else {\n                    if (elem.selectionStart) {\n                        elem.focus();\n                        elem.setSelectionRange(caretPos, caretPos);\n                    } else elem.focus();\n                }\n            }\n        }\n    }, {\n        key: 'insertText',\n        value: function insertText(newText) {\n\n            var el = this.controlEdit;\n\n            //var currentPosition = 0;\n\n            if (el.tagName == \"DIV\") {\n\n                el.focus();\n\n                var rwPredictionPositionElement = document.getElementById('rwPredictionPosition');\n                this.setCaretPositionDiv(currentContextControlID);\n                this.setSelectionRange(el, rwPredictionPositionElement.value, rwPredictionPositionElement.value);\n                this.currentChar = this.getCurrentCharacter();\n                this.replaceSelectedText(newText);\n            } else {\n                this.CurrentPosition = el.selectionStart;\n\n                this.setSelectionRange(el, this.CurrentPosition, this.CurrentPosition);\n\n                this.currentChar = this.getCurrentCharacter();\n                this.setSelectionRange(el, this.CurrentPosition, this.CurrentPosition);\n\n                this.replaceSelectedText(newText);\n\n                this.setSelectionRange(el, this.CurrentPosition, this.CurrentPosition);\n\n                this.setCaretPosition(el, this.CurrentPosition);\n            }\n\n            return false;\n        }\n    }, {\n        key: 'getCurrentCharacter',\n        value: function getCurrentCharacter() {\n            var sel,\n                word = \"\";\n            if (window.getSelection && (sel = window.getSelection()).modify) {\n                var selectedRange = sel.getRangeAt(0);\n                sel.collapseToStart();\n                sel.modify(\"move\", \"backward\", \"character\");\n                sel.modify(\"extend\", \"forward\", \"character\");\n                //sel.modify(\"extend\", \"backward\", \"character\");\n\n                word = sel.toString();\n\n                // Restore selection\n                sel.removeAllRanges();\n                sel.addRange(selectedRange);\n            } else if ((sel = document.selection) && sel.type != \"Control\") {\n                var range = sel.createRange();\n                range.collapse(true);\n                range.expand(\"word\");\n                word = range.text;\n            }\n            return word;\n        }\n    }, {\n        key: 'replaceSelectedText',\n        value: function replaceSelectedText(replacementText) {\n            var sel,\n                range,\n                beginningLine = false;\n            replacementText += \" \";\n\n            var moveCount = 0;\n\n            if (window.getSelection) {\n                sel = window.getSelection();\n                var activeElement = document.activeElement;\n                if (activeElement.nodeName == \"TEXTAREA\" || activeElement.nodeName == \"INPUT\" && activeElement.type.toLowerCase() == \"text\") {\n\n                    if (this.curser > 0) {\n\n                        switch (this.currentChar.charCodeAt(0)) {\n                            case 46:\n                            case 33:\n                            case 63:\n                                replacementText = \" \" + replacementText;\n                            case 32:\n                            case 160:\n                                break;\n                            case 38:\n                                // &\n\n                                sel.collapseToStart();\n\n                                //sel.modify(\"move\", \"backward\", \"word\");\n\n                                // check if word has a -, if so we need to go back one more word?\n                                sel.modify(\"move\", \"backward\", \"character\");\n                                sel.modify(\"move\", \"backward\", \"character\");\n\n                                sel.modify(\"extend\", \"forward\", \"character\");\n\n                                var word = sel.toString();\n\n                                if (word == \" \") {\n                                    sel.modify(\"move\", \"forward\", \"character\");\n                                    sel.modify(\"extend\", \"forward\", \"character\");\n                                } else {\n                                    sel.modify(\"move\", \"backward\", \"word\");\n                                    sel.modify(\"extend\", \"forward\", \"word\");\n                                    //sel.modify(\"extend\", \"forward\", \"character\");\n                                }\n\n                                break;\n                            case 45:\n                                sel.collapseToStart();\n\n                                sel.modify(\"move\", \"backward\", \"word\");\n\n                                sel.modify(\"extend\", \"forward\", \"word\");\n                                sel.modify(\"extend\", \"forward\", \"word\");\n\n                                break;\n                            default:\n                                sel.collapseToStart();\n\n                                sel.modify(\"move\", \"backward\", \"word\");\n\n                                // check if word has a -, if so we need to go back one more word?\n                                sel.modify(\"move\", \"backward\", \"character\");\n                                sel.modify(\"extend\", \"forward\", \"character\");\n\n                                var word = sel.toString();\n\n                                if (word == \"-\") {\n                                    // reset the cursor position to the previous point.\n                                    sel.modify(\"extend\", \"backward\", \"character\");\n                                    sel.modify(\"move\", \"forward\", \"character\");\n\n                                    sel.modify(\"move\", \"backward\", \"word\");\n                                    sel.modify(\"extend\", \"forward\", \"word\");\n                                    sel.modify(\"extend\", \"forward\", \"word\");\n                                } else if (word.charCodeAt(0) == 32) {\n                                    // reset the cursor position to the previous point.\n                                    //sel.modify(\"extend\", \"backward\", \"character\");\n                                    sel.modify(\"move\", \"forward\", \"character\");\n                                }\n\n                                sel.modify(\"extend\", \"forward\", \"word\");\n\n                                word = sel.toString();\n\n                                if (word.substr(word.length - 1, 1) == \"-\") {\n                                    sel.modify(\"extend\", \"forward\", \"word\");\n                                }\n\n                                word = sel.toString();\n\n                                if (navigator.appVersion.indexOf(\"Win\") != -1) {\n\n                                    if (word.substr(word.length - 1, 1) == \" \") {\n                                        sel.modify(\"extend\", \"backward\", \"character\");\n\n                                        replacementText = replacementText.trim();\n                                        moveCount++;\n                                    }\n\n                                    word = sel.toString();\n\n                                    var regex = /^[0-9a-zA-Z]+$/;\n\n                                    if (!word.substr(word.length - 1, 1).match(regex)) {\n                                        sel.modify(\"extend\", \"backward\", \"character\");\n                                        replacementText = replacementText.trim();\n                                        // moveCount++;\n                                        moveCount++;\n                                    }\n                                }\n\n                        }\n                    }\n\n                    //\n\n                    var val = activeElement.value,\n                        start = activeElement.selectionStart,\n                        end = activeElement.selectionEnd;\n\n                    if (navigator.appVersion.indexOf(\"Win\") != -1) {\n                        //ignore this for window.\n                        // Might need to add further handling\n\n                    } else {\n                        switch (val.slice(end).substr(0, 1)) {\n                            case \" \":\n                                replacementText = replacementText.trim();\n                                moveCount++;\n\n                                break;\n                            case \";\":\n                            case \":\":\n                            case \"!\":\n                            case \".\":\n\n                                replacementText = replacementText.trim();\n                                moveCount++;\n                                moveCount++;\n                                break;\n\n                        }\n                    }\n\n                    activeElement.value = val.slice(0, start) + replacementText + val.slice(end);\n\n                    this.CurrentPosition = start + replacementText.length + moveCount;\n\n                    //alert(\"in text area\");\n                } else {\n                    var sel = window.getSelection();\n                    this.setCaretPositionDiv(activeElement);\n\n                    if (this.currentChar.charCodeAt(0) == 32 || this.currentChar.charCodeAt(0) == 160) {} else {\n                        sel.modify(\"move\", \"backward\", \"word\");\n\n                        // check if word has a -, if so we need to go back one more word?\n                        sel.modify(\"move\", \"backward\", \"character\");\n                        sel.modify(\"extend\", \"forward\", \"character\");\n\n                        var word = sel.toString();\n\n                        if (word == \"-\") {\n                            // reset the cursor position to the previous point.\n                            sel.modify(\"extend\", \"backward\", \"character\");\n                            sel.modify(\"move\", \"forward\", \"character\");\n\n                            sel.modify(\"move\", \"backward\", \"word\");\n                            sel.modify(\"extend\", \"forward\", \"word\");\n                            sel.modify(\"extend\", \"forward\", \"word\");\n                        } else if (word.charCodeAt(0) == 32) {\n                            // reset the cursor position to the previous point.\n                            //sel.modify(\"extend\", \"backward\", \"character\");\n                            sel.modify(\"move\", \"forward\", \"character\");\n                        }\n\n                        sel.modify(\"extend\", \"forward\", \"word\");\n                    }\n\n                    if (sel.rangeCount) {\n                        range = sel.getRangeAt(0);\n                        range.deleteContents();\n                        range.insertNode(document.createTextNode(replacementText));\n                    } else {\n                        sel.deleteFromDocument();\n                    }\n\n                    var val = activeElement.value,\n                        start = activeElement.selectionStart,\n                        end = activeElement.selectionEnd;\n                    activeElement.value = val.slice(0, start) + replacementText + val.slice(end);\n\n                    setCaretPositionDiv(activeElement, start + replacementText.length);\n                }\n            } else if (document.selection && document.selection.createRange) {\n                range = document.selection.createRange();\n                range.text = replacementText;\n            }\n        }\n    }, {\n        key: 'getSelection',\n        value: function getSelection() {\n            var textComponent = this.controlEdit;\n            var selectedText;\n            // IE version\n            if (document.selection != undefined) {\n                textComponent.focus();\n                var sel = document.selection.createRange();\n                selectedText = sel.text;\n            }\n            // Mozilla version\n            else if (textComponent.selectionStart != undefined) {\n                    var startPos = textComponent.selectionStart;\n                    var endPos = textComponent.selectionEnd;\n                    selectedText = textComponent.value.substring(startPos, endPos);\n                }\n            return selectedText;\n        }\n    }]);\n\n    return Prediction;\n}();\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ScrollInToView = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevinml on 20/04/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _EventBus = require('src/SpeechStream/Events/EventBus');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ScrollInToView = exports.ScrollInToView = function () {\n    function ScrollInToView() {\n        _classCallCheck(this, ScrollInToView);\n    }\n\n    //Scroll browser screen to node.\n    // todo Note that this is making assumption that a div inside a div or div inside a page is smaller than the container\n    // so ensures that the div is in the containers viewable area.\n    // The above has not been put in place yet, as would need lot of testing\n\n    _createClass(ScrollInToView, [{\n        key: 'rw_scrollToObject',\n        value: function rw_scrollToObject(p_node) {\n            var ssdom = new _SSDOM.SSDOM();\n            var $g_bMouseSpeech = false;\n            //        if(typeof(eba_no_scroll) == \"boolean\" && eba_no_scroll)\n            //        {\n            //            return;\n            //        }\n            try {\n                var theWindow = ssdom.getWindow(p_node);\n\n                if (theWindow == null || p_node == null || p_node.parentNode == null) {\n                    return;\n                }\n\n                var x = 0;\n                var y = 0;\n                var obj = p_node;\n                if (obj.nodeType == 3) {\n                    obj = obj.parentNode;\n                }\n\n                // If we move up from a div need to store the offset in the visible part of the div to cover the case\n                // of a scrolling div that is larger than page height, need to both scroll div into view and part of div\n                // needed into view.\n                var divOffsetObj = null;\n\n                //do check to see if inside a scrollable div  or a scrollable form\n                var parentTest = obj;\n                var tmpBody = obj.ownerDocument.body;\n\n                var bScrolledDiv = false;\n                var storedMatchObj = null;\n\n                //\n                // Div checking\n                //\n\n                while (parentTest != null && parentTest != tmpBody) {\n                    if (parentTest.tagName.toLowerCase() == \"div\" || parentTest.tagName.toLowerCase() == \"form\") {\n                        // See if it is scrollable div\n                        if (this.rw_isDivScrollable(parentTest)) {\n                            // IS scrollable\n\n                            bScrolledDiv = true;\n\n                            divOffsetObj = this.rw_scrollToObjectDivCheck(obj, parentTest, divOffsetObj);\n\n                            storedMatchObj = parentTest;\n                            obj = parentTest;\n\n                            // todo check for nested divs of different types to check for case where even for second scrolling div in needs orig object offset rather than div it is in.\n                        }\n                    }\n                    parentTest = parentTest.parentNode;\n                }\n\n                if (storedMatchObj != null) {\n                    obj = storedMatchObj;\n                }\n\n                //\n                // end of div checking\n                //\n\n                //\n                // scrolling in body\n                //\n\n                while (obj != null) {\n                    x += obj.offsetLeft;\n                    y += obj.offsetTop;\n                    obj = obj.offsetParent;\n                }\n\n                if (divOffsetObj != null) {\n                    // scrolled in a div\n                    y += divOffsetObj.y;\n                    x += divOffsetObj.x;\n                }\n\n                var screenLeft;\n                var screenTop;\n                var screenWidth;\n                var screenHeight;\n                var nWidthOffset = 30;\n\n                if (p_node.nodeType == 3) {\n                    // make a guess at width, doesn't need to be too precise. (or rather effort to make precise not worth result)\n                    nWidthOffset = 10 + 5 * p_node.nodeValue.length;\n                    if (nWidthOffset > 60) {\n                        nWidthOffset = 60;\n                    }\n                }\n\n                screenLeft = this.rw_getScreenOffsetLeft(theWindow);\n                screenTop = this.rw_getScreenOffsetTop(theWindow);\n\n                if (typeof theWindow.innerWidth == 'number') {\n                    screenWidth = theWindow.innerWidth;\n                    screenHeight = theWindow.innerHeight;\n                } else if (theWindow.document.documentElement.clientHeight > 0 && theWindow.document.documentElement.clientWidth > 0) {\n                    screenWidth = theWindow.document.documentElement.clientWidth;\n                    screenHeight = theWindow.document.documentElement.clientHeight;\n                } else {\n                    screenWidth = theWindow.document.body.clientWidth;\n                    screenHeight = theWindow.document.body.clientHeight;\n                }\n\n                screenWidth = screenWidth - nWidthOffset;\n                screenHeight = screenHeight - 20;\n\n                var bNeedX;\n                var bNeedY;\n\n                if (bScrolledDiv) {// check that as much of div is inside view as possible.\n                    //not currently worth time involved to do this\n                }\n\n                bNeedX = x < screenLeft || x > screenLeft + screenWidth;\n                bNeedY = y < screenTop || y > screenTop + screenHeight;\n                if (bNeedX || bNeedY && (x != 0 || y != 0)) {\n                    if (x > screenLeft + screenWidth) {\n                        x = (x + screenLeft) / 2;\n                    }\n                    if (y > screenTop + screenHeight) {\n                        y = (y + screenTop) / 2;\n                    }\n                    var bHover = $g_bMouseSpeech;\n                    if ($g_bMouseSpeech) {\n                        $g_bMouseSpeech = false;\n                    }\n                    var event = new _EventBus.EventBus();\n                    event.publish(\"pauseHover\", null);\n\n                    theWindow.scrollTo(bNeedX ? x : screenLeft, bNeedY ? y : screenTop);\n\n                    // for Ipad need to force the scroll event as they decided scroll event not needed on ipad version of safari\n                    var g_bTouchScreen = false;\n                    if (g_bTouchScreen) {\n                        rw_positionToolbar();\n                        rw_positionAllDivBars();\n                    }\n\n                    //                if(bHover)\n                    {}\n                }\n            } catch (ignore) {}\n            // console.log(ignore);\n\n            //        g_bDidScroll = false;\n        }\n\n        /*Distance screen is scrolled to the right*/\n\n    }, {\n        key: 'rw_getScreenOffsetLeft',\n        value: function rw_getScreenOffsetLeft(p_window) {\n            if (typeof p_window == \"undefined\") {\n                p_window = window;\n            }\n\n            // even if not supported these still return 0 rather than undefined, so need to test all for non zero and use that if exists.\n            // even firefox/chrome/safari do not match up on this, not just IE problem.\n\n            if (p_window.pageXOffset && p_window.pageXOffset > 0) {\n                return p_window.pageXOffset;\n            } else if (p_window.document.body.scrollLeft && p_window.document.body.scrollLeft > 0) {\n                return p_window.document.body.scrollLeft;\n            } else if (p_window.document.documentElement.scrollLeft && p_window.document.documentElement.scrollLeft > 0) {\n                return p_window.document.documentElement.scrollLeft;\n            }\n            return 0;\n        }\n\n        /*Distance screen is scrolled down*/\n\n    }, {\n        key: 'rw_getScreenOffsetTop',\n        value: function rw_getScreenOffsetTop(p_window) {\n            if (typeof p_window == \"undefined\") {\n                p_window = window;\n            }\n            // even if not supported these still return 0 rather than undefined, so need to test all for non zero and use that if exists.\n            // even firefox/chrome/safari do not match up on this, not just IE problem.\n\n            if (p_window.pageYOffset && p_window.pageYOffset > 0) {\n                return p_window.pageYOffset;\n            } else if (p_window.document.body.scrollTop && p_window.document.body.scrollTop > 0) {\n                return p_window.document.body.scrollTop;\n            } else if (p_window.document.documentElement.scrollTop && p_window.document.documentElement.scrollTop > 0) {\n                return p_window.document.documentElement.scrollTop;\n            }\n            return 0;\n        }\n\n        // todo more accurate determination of screen scrolling?\n\n    }, {\n        key: 'rw_getScreenOffsetLeftAlt',\n        value: function rw_getScreenOffsetLeftAlt(p_window) {\n            if (typeof p_window == \"undefined\") {\n                p_window = window;\n            }\n            //noinspection JSUnresolvedVariable\n            if (p_window.document.compatMode == \"CSS1Compat\" && p_window.document.body.parentNode && p_window.document.body.parentNode.scrollLeft) {\n                //noinspection JSUnresolvedVariable\n                return p_window.document.body.parentNode.scrollLeft;\n            }\n\n            //noinspection UnnecessaryLocalVariableJS,JSUnresolvedVariable\n            var n = p_window.pageXOffset ? p_window.pageXOffset : p_window.scrollX ? p_window.scrollX : p_window.document.body.scrollLeft ? p_window.document.body.scrollLeft : p_window.document.documentElement.scrollLeft ? p_window.document.documentElement.scrollLeft : 0;\n\n            return n;\n        }\n\n        /**\n         * If inside a div some offset may need to scroll inside the div, then need to scroll outside the div to get the div\n         * itself in view.\n         */\n\n    }, {\n        key: 'rw_scrollToObjectDivCheck',\n        value: function rw_scrollToObjectDivCheck(p_node, p_div, p_prevDivOffsetObj) {\n            var nDivOffsetX;\n            var nDivOffsetY;\n\n            var nObjHeight = p_div.clientHeight;\n            var nObjWidth = p_div.clientWidth;\n\n            var clientRectWidth = p_node.getBoundingClientRect().right - p_node.getBoundingClientRect().left;\n\n            // At this point have scrollable div and node in it\n\n            var nTmpOffsetTop = 0;\n            var nTmpOffsetLeft = 0;\n\n            //Check if the node's offset parent is the div or inside the div\n            var tmpObj = p_node;\n            while (tmpObj != p_div && tmpObj != null) {\n                nTmpOffsetTop += tmpObj.offsetTop;\n                nTmpOffsetLeft += tmpObj.offsetLeft;\n                tmpObj = this.rw_safeOffsetParent(tmpObj, p_div); //so does not skip over containing div.\n            }\n\n            if (tmpObj == null) {\n                // assume here that p_node is definitely inside p_div, so only here if offsetParent higher than p_div\n                // Need to reduce scrolling in div by offset of div\n                nTmpOffsetLeft -= p_div.offsetLeft;\n                nTmpOffsetTop -= p_div.offsetTop;\n\n                // set return object for how to proceed.\n            }\n\n            if (p_prevDivOffsetObj != null) {\n                // if already scrolled a div will get here\n                nTmpOffsetTop += p_prevDivOffsetObj.y;\n                nTmpOffsetLeft += p_prevDivOffsetObj.x;\n            }\n\n            // if not in view area then scroll\n\n            // Scroll Top\n            if (p_div.scrollTop > nTmpOffsetTop || p_div.scrollTop + nObjHeight < nTmpOffsetTop + p_node.offsetHeight) {\n                if (nObjHeight > p_node.offsetHeight * 6) {\n                    // for narrow object, add a bit of space above it.\n                    p_div.scrollTop = nTmpOffsetTop - p_node.offsetHeight;\n                } else {\n                    p_div.scrollTop = nTmpOffsetTop;\n                }\n            }\n\n            // Scroll left\n            if (clientRectWidth < 200 && (p_div.scrollLeft > nTmpOffsetLeft || p_div.scrollLeft + nObjWidth < nTmpOffsetLeft + p_node.offsetWidth)) {\n                p_div.scrollLeft = nTmpOffsetLeft;\n            }\n\n            // set the offset in the visible area of the div (this needed whether scrolls or not)\n            nDivOffsetX = nTmpOffsetLeft - p_div.scrollLeft;\n            nDivOffsetY = nTmpOffsetTop - p_div.scrollTop;\n\n            return { x: nDivOffsetX, y: nDivOffsetY };\n        }\n\n        /**\n         * To allow safe retrieval of offset parent.  This will check that it is not skipped over.\n         * @param p_obj\n         */\n\n    }, {\n        key: 'rw_safeOffsetParent',\n        value: function rw_safeOffsetParent(p_obj, p_endNode) {\n            var startObj = p_obj;\n            var endObj = startObj.offsetParent;\n            if (endObj == null) {\n                return null;\n            }\n\n            if (p_endNode == null) {\n                // no further check needed\n                return endObj;\n            }\n\n            // ensure that end node is not between start and end\n\n            while (startObj != null && startObj != endObj) {\n                if (startObj == p_endNode) {\n                    // no offset parent for this.\n                    return null;\n                }\n                startObj = startObj.parentNode;\n            }\n            return endObj;\n        }\n\n        /**\n         * True false result, is div a scrollable div.\n         * @param p_div\n         */\n\n    }, {\n        key: 'rw_isDivScrollable',\n        value: function rw_isDivScrollable(p_div) {\n            var ssdom = new _SSDOM.SSDOM();\n            /*NB possible issue with inline fixed div in page that also scrolls, may or may not be important issue?*/\n\n            // check the div\n            var nObjHeight = p_div.clientHeight;\n            var nObjWidth = p_div.clientWidth;\n\n            var theStyle = ssdom.getComputedStyle(p_div);\n\n            var bScrollable = false;\n\n            if (theStyle != null && theStyle.overflow != \"visible\" && theStyle.display != \"inline\") // if inline a div, stops being a div as such so no scroll.\n                {\n                    if (p_div.scrollHeight > nObjHeight && theStyle.overflowY != \"visible\") {\n                        // ensure that overflowx is not visible\n                        bScrollable = true;\n                    }\n\n                    if (p_div.scrollWidth > nObjWidth && theStyle.overflowX != \"visible\") {\n                        // ensure that overflowy is not visible\n                        bScrollable = true;\n                    }\n                }\n\n            return bScrollable;\n        }\n    }]);\n\n    return ScrollInToView;\n}();\n\n},{\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/Events/EventBus\":6}],19:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevinml on 03/05/2016.\n */\n\nvar BaseSelection = exports.BaseSelection = function () {\n    function BaseSelection() {\n        _classCallCheck(this, BaseSelection);\n    }\n\n    _createClass(BaseSelection, [{\n        key: \"clearSelection_\",\n        value: function clearSelection_() {\n            this.clearBrowserSelection();\n        }\n\n        /**\n         * Clears the web page selection. This is not the highlights\n         * we add.\n         */\n\n    }, {\n        key: \"clearBrowserSelection\",\n        value: function clearBrowserSelection() {\n            if (window.getSelection) {\n                for (var i = 0; i < window.frames.length; i++) {\n                    try {\n                        if (window.getSelection().empty) {\n                            // Chrome\n                            window.frames[i].getSelection().empty();\n                        } else if (window.getSelection().removeAllRanges) {\n                            // Firefox\n                            window.frames[i].getSelection().removeAllRanges();\n                        }\n                    } catch (e) {}\n                }\n                if (window.getSelection().empty) {\n                    // Chrome\n                    window.getSelection().empty();\n                } else if (window.getSelection().removeAllRanges) {\n                    // Firefox\n                    window.getSelection().removeAllRanges();\n                }\n            } else if (document.selection) {\n                // IE?\n                document.selection.empty();\n            }\n        }\n    }, {\n        key: \"getSelectionRange\",\n        value: function getSelectionRange() {}\n    }, {\n        key: \"hasSelection\",\n        value: function hasSelection() {}\n    }]);\n\n    return BaseSelection;\n}();\n\n},{}],20:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.HoverSpeak = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nvar _THCaret = require('src/SpeechStream/THCaret');\n\nvar _THDomRange = require('src/SpeechStream/THDomRange');\n\nvar _BaseSelection2 = require('src/SpeechStream/Selection/BaseSelection');\n\nvar _EventBus = require('src/SpeechStream/Events/EventBus');\n\nvar _SpeechObject = require('src/SpeechStream/SpeechObject');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by kevinml on 19/04/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar HoverSpeak = exports.HoverSpeak = function (_BaseSelection) {\n    _inherits(HoverSpeak, _BaseSelection);\n\n    function HoverSpeak() {\n        _classCallCheck(this, HoverSpeak);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(HoverSpeak).call(this));\n\n        _this.event = {};\n        _this.timerEvent = null;\n        _this.callback = null;\n        _this.caretRange = null;\n        var event = new _EventBus.EventBus();\n        event.subscribe(\"pauseHover\", _this.clearTimer.bind(_this));\n        _this.sentence;\n        _this.readRange = null;\n        return _this;\n    }\n\n    _createClass(HoverSpeak, [{\n        key: 'mouseMoved',\n        value: function mouseMoved(event, callback) {\n            var _this2 = this;\n\n            clearTimeout(this.timerEvent);\n            this.event = event;\n            this.callback = callback;\n            this.timerEvent = setTimeout(function () {\n                return _this2.startSpeech();\n            }, 500);\n        }\n    }, {\n        key: 'clearTimer',\n        value: function clearTimer() {\n            clearTimeout(this.timerEvent);\n        }\n    }, {\n        key: 'clearHoverSpeak',\n        value: function clearHoverSpeak() {\n            clearTimeout(this.timerEvent);\n            this.sentence == null;\n        }\n    }, {\n        key: 'startSpeech',\n        value: function startSpeech() {\n\n            var range;\n\n            if (this.event.target.tagName.toLowerCase() == \"textarea\") {\n                range = new _THDomRange.THDomRange(this.event.target, 0, this.event.target, 0);\n                this.readRange = range;\n                this.callback();\n            } else {\n                if (document.caretRangeFromPoint) {\n                    var docRange = this.event.target.ownerDocument.caretRangeFromPoint(this.event.clientX, this.event.clientY);\n                    range = new _THDomRange.THDomRange(docRange.startContainer, docRange.startOffset, docRange.endContainer, docRange.endOffset);\n                } else {\n                    var docRange = this.event.target.ownerDocument.caretPositionFromPoint(this.event.clientX, this.event.clientY);\n                    range = new _THDomRange.THDomRange(docRange.offsetNode, docRange.offset, docRange.offsetNode, docRange.offset);\n                }\n\n                var localSpeechObject = new _SpeechObject.SpeechObject();\n                localSpeechObject.processRange(range, true);\n                var newSentence = localSpeechObject.getFirstSentence();\n\n                var oldSentText = \"\";\n                var newSentText = \"\";\n\n                if (this.sentence && this.sentence.getRawText()) {\n                    oldSentText = this.sentence.getRawText();\n                }\n                if (newSentence.getRawText()) {\n                    newSentText = newSentence.getRawText();\n                }\n\n                if (this.event.target == range.startCaret.node.parentElement) {\n                    if (this.sentence == null || oldSentText.indexOf(newSentText) == -1) {\n                        this.sentence = newSentence;\n                        this.readRange = range;\n                        this.callback();\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'getSelectionRange',\n        value: function getSelectionRange() {\n            return this.readRange;\n        }\n    }]);\n\n    return HoverSpeak;\n}(_BaseSelection2.BaseSelection);\n\n},{\"src/SpeechStream/Events/EventBus\":6,\"src/SpeechStream/Selection/BaseSelection\":19,\"src/SpeechStream/SpeechObject\":26,\"src/SpeechStream/THCaret\":27,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/THDomRange\":29}],21:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SelectionController = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nvar _THDomRange = require('src/SpeechStream/THDomRange');\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _BaseSelection2 = require('src/SpeechStream/Selection/BaseSelection');\n\nvar _DomNavigation = require('src/SpeechStream/DOM/DomNavigation');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by kevin on 23/03/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\nvar SelectionController = exports.SelectionController = function (_BaseSelection) {\n    _inherits(SelectionController, _BaseSelection);\n\n    function SelectionController() {\n        _classCallCheck(this, SelectionController);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SelectionController).call(this));\n\n        _this.g_ipadSelectionRange = null;\n        return _this;\n    }\n\n    _createClass(SelectionController, [{\n        key: 'getSelectionRange',\n        value: function getSelectionRange() {\n            var selection = this.getSelection_();\n            if (selection) {\n                return selection.range;\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'getSelectionObject',\n        value: function getSelectionObject() {\n            var selection = this.getSelection_();\n            this.clearBrowserSelection();\n            return selection;\n        }\n    }, {\n        key: 'isMathJax',\n        value: function isMathJax(range) {\n            if (typeof MathJax != \"undefined\") {\n                if (range.startCaret.node.isMathJax) {\n                    return true;\n                }\n                if (range.startCaret.node.parentNode.isMathJax) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * Checks if there are any selections\n         * @return {boolean} true if there are any selections.\n         */\n\n    }, {\n        key: 'hasSelection',\n        value: function hasSelection() {\n            var selection = this.getSelection_();\n            if (selection != null && selection != undefined) {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'getSelectionString',\n        value: function getSelectionString() {\n            var selection = this.getSelection_();\n            var text = selection.range.toString();\n            return text;\n        }\n    }, {\n        key: 'getSelection_',\n        value: function getSelection_() {\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            var theWindow = null;\n            var theRange = null;\n\n            if (this.g_ipadSelectionRange != null) {\n                // workaround for ipad IOS5 bug, loses selection on any action.\n                g_ipadSelectionWindow.getSelection().addRange(this.g_ipadSelectionRange);\n            }\n\n            var tmpSel = window.getSelection();\n\n            var foundSel = null;\n            var utilities = new _Utilities.Utilities();\n            if (!tmpSel.isCollapsed && utilities.trim(tmpSel.toString()).length > 0) {\n                theWindow = window;\n                foundSel = tmpSel;\n            } else {\n                // For SFF check if have selection inside an Input element.\n                // If so g_lastInputSelectSFF will point to an Input element.\n                //                if(g_lastInputSelectSFF && g_lastInputSelectSFF.selectionStart\n                //                    != g_lastInputSelectSFF.selectionEnd)\n                //                {\n                //                    return {frame:window, range:new String(\n                //                        g_lastInputSelectSFF.value.substring(g_lastInputSelectSFF.selectionStart,\n                //                            g_lastInputSelectSFF.selectionEnd)\n                //                    )};\n                //                }\n\n                // check if selection inside a frame\n                //                var res = SSDOM.getFrameSelectionSFF(window);\n                //                if(res.foundSel)\n                //                {\n                //                    theWindow = res.theWindow;\n                //                    foundSel = res.foundSel;\n                //                }\n            }\n\n            if (foundSel == null) {\n                var i = 0;\n                while (foundSel == null && i < window.frames.length) {\n                    try {\n                        tmpSel = window.frames[i].getSelection();\n                        i++;\n                        if (!tmpSel.isCollapsed && utilities.trim(tmpSel.toString()).length > 0) {\n                            theWindow = window;\n                            foundSel = tmpSel;\n                        }\n                    } catch (e) {\n                        foundSel = null;\n                        i++;\n                    }\n                }\n                if (foundSel == null) {\n                    return null;\n                }\n            }\n\n            if (foundSel.focusNode && foundSel.focusNode.id) {\n                if (foundSel.focusNode.id == \"flashcontent\") {\n                    return null;\n                }\n            }\n\n            // check for zero length selection\n            if (foundSel.anchorNode != null && foundSel.anchorNode == foundSel.focusNode && foundSel.anchorOffset == foundSel.focusOffset) {\n                // Cases with flash were collapsed selection not recorded as collapsed.\n                return null;\n            }\n\n            var mozRange = null;\n            if (foundSel.getRangeAt) {\n                // firefox\n                //noinspection JSUnusedAssignment\n                mozRange = foundSel.getRangeAt(0);\n            } else {\n                // safari\n\n                var range = ssdom.getRangeObject();\n                if (range != null) {\n                    // if selection done via double click rather than dragging then the selection object is incorrect, need to guess\n                    if (foundSel.anchorNode == foundSel.focusNode && foundSel.anchorOffset == foundSel.focusOffset) {\n                        // if contains no spaces is just one word, otherwise is sentence selection.\n                        range = ssdom.getRangeFromSelectionPoint(foundSel);\n                        //if need to tell whether word or sentence selected\n                        // use: var tmpStr = foundSel + \"\"; if(tmpStr.indexOf(\" \") > -1)  {  // sentence handling}else{  // word handling}\n                    } else {\n                        range.setStart(foundSel.anchorNode, foundSel.anchorOffset);\n                        range.setEnd(foundSel.focusNode, foundSel.focusOffset);\n\n                        if (range.toString().length == 0) {\n                            // try other way around in case select from right to left\n                            range.setStart(foundSel.focusNode, foundSel.focusOffset);\n                            range.setEnd(foundSel.anchorNode, foundSel.anchorOffset);\n                        }\n                    }\n                    mozRange = range;\n                }\n            }\n            if (mozRange != null) {\n                var startCon = mozRange.startContainer;\n                var startOff = mozRange.startOffset;\n                var endCon = mozRange.endContainer;\n                var endOff = mozRange.endOffset;\n\n                //if container is not a text node it can cause selection error\n                if (startCon.nodeType != 3) {\n                    if (startCon.nodeType != 1) {\n                        // not element or text node, bad selection\n                        return null;\n                    } else {\n                        // might need to use sub element\n                        if (startOff > 0) {\n                            if (startCon.hasChildNodes() && startCon.childNodes.length > startOff) {\n                                startCon = startCon.childNodes[startOff];\n                                if (startCon.nodeType == 3) {\n                                    startOff = 0;\n                                } else {\n                                    startOff = 0;\n                                    //todo look into this more, what to do when selection ends after object\n                                    //todo particularly look at img with msg\n\n\n                                    if (startCon.toString() == \"[object HTMLEmbedElement]\") {\n                                        return null;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                //if container is not a text node it can cause selection error\n                if (endCon.nodeType != 3) {\n                    if (endCon.nodeType != 1) {\n                        // not element or text node, bad selection\n                        return null;\n                    } else {\n                        // might need to use sub element\n                        if (endCon.hasChildNodes()) {\n                            if (endCon.childNodes.length > endOff) {\n                                // move to item sure to be after selection and allow look for previous\n                                endCon = endCon.childNodes[endOff];\n                            } else {\n                                endCon = endCon.childNodes[endOff - 1];\n                                if (endCon.nodeType != 3) {\n                                    // might be parent of the selection, look to last text beneath this point if it exists.\n                                    //noinspection JSDuplicatedDeclaration\n                                    var tmpNode = domNav.getLastChildTextNode(endCon, true);\n                                    if (tmpNode != null) {\n                                        endCon = tmpNode;\n                                    }\n                                }\n                            }\n                        }\n\n                        // check if found yet\n                        if (endCon.nodeType != 3) {\n                            var tmpBlock = domNav.getPreviousNode(startCon, true, null);\n                            //noinspection JSDuplicatedDeclaration\n                            var tmpNode = domNav.getPreviousTextNode(endCon, false, tmpBlock); /// should be false?  so can go back over para to valid text?\n                            if (tmpNode != null) {\n                                endCon = tmpNode;\n                            }\n                        }\n\n                        if (endCon.nodeType == 3) {\n                            endOff = endCon.nodeValue.length;\n                        } else {\n                            endOff = 0;\n                        }\n                    }\n                }\n\n                theRange = new _THDomRange.THDomRange(startCon, startOff, endCon, endOff);\n            } else {\n                return null;\n            }\n\n            if (theWindow != null && theRange != null) {\n                return { frame: theWindow, range: theRange };\n            } else {\n                return null;\n            }\n        }\n    }]);\n\n    return SelectionController;\n}(_BaseSelection2.BaseSelection);\n\n},{\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/DomNavigation\":3,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/Selection/BaseSelection\":19,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/THDomRange\":29,\"src/SpeechStream/Utilities/Utilities\":34}],22:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BaseObject = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevin on 06/04/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n/**\n * Created by IntelliJ IDEA.\n * User: stuart\n * Date: 05/06/15\n * Time: 13:51\n *\n *\n */\n\nvar _THRange = require('src/SpeechStream/THRange');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Set up a base type.\n// All the Speech objects will have a common core that allows each object to have a range set for it and a type.\n/**\n * Base type.\n *\n * API\n * getRange\n * setRange\n * getType\n * isValid\n * setValid\n * getContents\n * setContents\n * addContent\n * isOverridingText\n * getWordCount\n * getWords\n * getSpokenText\n * getFirstNode\n *\n * @param p_type SpeechStream.speechDom.Types\n */\nvar BaseObject = exports.BaseObject = function () {\n    function BaseObject(p_type) {\n        _classCallCheck(this, BaseObject);\n\n        // Need to use this to work with prototype for sub types, but these should be considered private variables.\n        this.m_range = null; // THRange\n        this.m_type = p_type; // SpeechStream.speechDom.Types\n        this.m_bValid = true; // Flag for whether or not the object is valid.\n        this.m_contents = null; // Array of SpeechStream.speechDom.BaseObject  (NB, this must be null so it created new in each instance so it is not shared across them.)\n        this.Types = {\n            WORD: 1, // basic text\n            SENTENCE: 2, // Sentence of word, SSML and Silence objects\n            SSML: 3, // SSML custom objects\n            DOCUMENT: 4, // collection of sentences\n            SILENCE: 5 // element that pauses speech\n        };\n    }\n    // getters / setters\n\n    /**\n     * Get Range.  This returns as THRange object if it exists.\n     * This is the range in the page that the object represents.\n     */\n\n\n    _createClass(BaseObject, [{\n        key: 'getRange',\n        value: function getRange() {\n            return this.m_range;\n        }\n\n        /**\n         * Sets the range, should be a THRange object.\n         * @param p_range\n         */\n\n    }, {\n        key: 'setRange',\n        value: function setRange(p_range) {\n            if (p_range instanceof _THRange.THRange) {\n                this.m_range = p_range;\n            } else {\n                // console.log(\"Error, calling setRange with incorrect type\");\n            }\n        }\n\n        /**\n         * Returns a SpeechStream.speechDom.Types type for this object.\n         */\n\n    }, {\n        key: 'getType',\n        value: function getType() {\n            return this.m_type;\n        }\n        /**\n         * Returns boolean for whether the object is set as valid.  Will default as valid.\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid() {\n            return this.m_bValid;\n        }\n\n        /**\n         * Set valid status.\n         * @Param p_bValid\n         */\n\n    }, {\n        key: 'setValid',\n        value: function setValid(p_bValid) {\n            this.m_bValid = p_bValid;\n        }\n\n        /**\n         * Get the contents.  Returns as an array of BaseObjects.\n         */\n\n    }, {\n        key: 'getContents',\n        value: function getContents() {\n            if (this.m_contents == null) {\n                this.m_contents = [];\n            }\n            return this.m_contents;\n        }\n\n        /**\n         * Set the contents.  Completely replaces current contents.\n         * @param p_contents\n         */\n\n    }, {\n        key: 'setContents',\n        value: function setContents(p_contents) {\n            if (p_contents instanceof Array) {\n                this.m_contents = p_contents;\n            } else //if(p_contents instanceof SpeechStream.speechDom.BaseObject)\n                {\n                    this.m_contents = [p_contents];\n                }\n        }\n\n        /**\n         * Add single item to the contents.\n         * @param p_obj\n         */\n\n    }, {\n        key: 'addContent',\n        value: function addContent(p_obj) {\n            //todo if(p_obj instanceof SpeechStream.speechDom.BaseObject)\n            {\n                if (this.m_contents == null) {\n                    this.m_contents = [];\n                }\n\n                this.m_contents.push(p_obj);\n            }\n        }\n\n        // utility functions\n\n        /**\n         * Check to see if the object is altering the text from what was pased in.\n         * Only applies to some object types, so always false unless sub type overrides this.\n         */\n\n    }, {\n        key: 'isOverridingText',\n        value: function isOverridingText() {\n            return false;\n        }\n    }, {\n        key: 'getWordCount',\n        value: function getWordCount() {\n            // If is single word, or element replacing content so that counts as single word.\n            if (this.m_type == this.Types.WORD || this.isOverridingText()) {\n                return 1;\n            }\n\n            var n = 0;\n            if (this.m_contents == null) {\n                this.m_contents = [];\n            }\n            if (this.m_contents.length > 0) {\n                var nLen = this.m_contents.length;\n                var i;\n                for (i = 0; i < nLen; i++) {\n                    n += this.m_contents[i].getWordCount();\n                }\n            }\n            return n;\n        }\n\n        /**\n         * Returns array of the words to be spoken, grouped as will be bookmarked.  So typically one word per object,\n         * but object could be SSML object.\n         */\n\n    }, {\n        key: 'getWords',\n        value: function getWords() {\n            // If is single word, or element replacing content so that counts as single word.\n            if (this.m_type == this.Types.WORD || this.isOverridingText()) {\n                return [this];\n            }\n\n            var words = [];\n            if (this.m_contents == null) {\n                this.m_contents = [];\n            }\n            if (this.m_contents.length > 0) {\n                var i;\n                var nLen = this.m_contents.length;\n                for (i = 0; i < nLen; i++) {\n                    words = words.concat(this.m_contents[i].getWords());\n                }\n            }\n            return words;\n        }\n\n        // Returns the first node for the element.  Can be the text node or an element surrounding all the text or surrounding the start of the text.\n\n    }, {\n        key: 'getFirstNode',\n        value: function getFirstNode() {\n            var ssdom = new _SSDOM.SSDOM();\n            var range = this.getRange();\n            if (range != null) {\n                var caret = ssdom.rw_getCaretFromRefPt(range.body, range.startRef);\n                if (caret != null && caret.node != null) {\n                    return caret.node;\n                }\n            }\n            return null;\n        }\n\n        // Abstract\n        /**\n         * Returns the text to be spoken.  This will be overriden in each case where it is needed.\n         * Included here just in case, as at times called on array of base objects that\n         * should only include types that override this.  But here to log in case of wrong time being included.\n         */\n\n    }, {\n        key: 'getSpokenText',\n        value: function getSpokenText() {\n            // if(console.log)\n            // {\n            //     console.log(\"Calling getSpokenText on type of SpeechObject that doesn't support it.\");\n            // }\n            return \"\";\n        }\n    }]);\n\n    return BaseObject;\n}();\n\n},{\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/THRange\":31}],23:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.MathWordObject = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BaseObject2 = require('src/SpeechStream/Sentence/BaseObject');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by kevinml on 22/04/2016.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\nvar MathWordObject = exports.MathWordObject = function (_BaseObject) {\n    _inherits(MathWordObject, _BaseObject);\n\n    function MathWordObject(spanId, p_strWord) {\n        _classCallCheck(this, MathWordObject);\n\n        //todo\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MathWordObject).call(this, 1));\n\n        _this.spanID = spanId;\n        _this.m_strWord = p_strWord; // Word for the given object.  Read only.\n        _this.m_strPronunciation = null; // If word is to be changed, it is given a pronunciation to override it.\n        return _this;\n    }\n\n    _createClass(MathWordObject, [{\n        key: 'getRange',\n        value: function getRange() {\n            return this.spanID;\n        }\n    }, {\n        key: 'setRange',\n        value: function setRange(spanId) {\n            this.spanID = spanId;\n        }\n    }, {\n        key: 'getWord',\n        value: function getWord() {\n            return this.m_strWord;\n        }\n    }]);\n\n    return MathWordObject;\n}(_BaseObject2.BaseObject);\n\n},{\"src/SpeechStream/Sentence/BaseObject\":22}],24:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SentenceObject = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _TextOverRangeBeanClass = require('src/SpeechStream/TextOverRangeBeanClass');\n\nvar _BaseObject2 = require('src/SpeechStream/Sentence/BaseObject');\n\nvar _THDomRange = require('src/SpeechStream/THDomRange');\n\nvar _MathSpeak = require('src/SpeechStream/MathJax/MathSpeak');\n\nvar _WordObject = require('src/SpeechStream/Sentence/WordObject');\n\nvar _MathWordObject = require('src/SpeechStream/Sentence/MathWordObject');\n\nvar _THRange = require('src/SpeechStream/THRange');\n\nvar _DomNavigation = require('src/SpeechStream/DOM/DomNavigation');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by kevin on 05/04/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n\n/**\n * Sentence Object\n * This should contain objects that make up the sentence.  SSML or word elements\n *\n *\n * Public API\n * Inherit from Base Object\n *\n * setVoice\n * getVoice\n * setCaretRange\n * getCaretRange\n * getRawText\n * setRawText\n * getMarkedText\n * setMarkedText\n * clone\n *\n * @param p_caretRange\n */\nvar SentenceObject = exports.SentenceObject = function (_BaseObject) {\n    _inherits(SentenceObject, _BaseObject);\n\n    function SentenceObject(p_caretRange) {\n        _classCallCheck(this, SentenceObject);\n\n        //todo\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SentenceObject).call(this, 2));\n\n        var ssdom = new _SSDOM.SSDOM();\n        var m_strVoice = null;\n        if (p_caretRange != null) {\n            _this.m_range = new _THDomRange.THDomRange(p_caretRange.leftCaret.node, p_caretRange.leftCaret.offset, p_caretRange.rightCaret.node, p_caretRange.rightCaret.offset);\n\n            _this.m_caretRange = p_caretRange; // THCaretRange - range using current nodes.  Considered temporary range as not guaranteed to valid after any DOM manipulation.\n            if (p_caretRange.leftCaret.node.isMathJax) {\n                var mathSpeak = new _MathSpeak.MathSpeak();\n                try {\n                    _this.math = true;\n                    _this.m_strRawText = mathSpeak.getSpeechWithBookmarksFromElement(p_caretRange.leftCaret.node);\n                    _this.splitMathIntoWords();\n                    _this.sentenceSpanId = p_caretRange.leftCaret.node.id;\n                } catch (error) {}\n            } else {\n\n                _this.m_strRawText = p_caretRange.getTextOverCaretRange();\n                _this.math = false;\n            }\n            _this.m_strMarkedText;\n        }\n        return _this;\n    }\n\n    // getters setters\n\n\n    _createClass(SentenceObject, [{\n        key: 'setVoice',\n        value: function setVoice(p_strVoice) {\n            this.m_strVoice = p_strVoice;\n        }\n    }, {\n        key: 'getVoice',\n        value: function getVoice() {\n            return this.m_strVoice;\n        }\n    }, {\n        key: 'getSpanId',\n        value: function getSpanId() {\n            return this.sentenceSpanId;\n        }\n    }, {\n        key: 'setCaretRange',\n        value: function setCaretRange(p_caretRange) {\n            this.m_caretRange = p_caretRange;\n            this.m_range = m_caretRange.rw_getTHRangeFromTHCaretRange();\n        }\n    }, {\n        key: 'getCaretRange',\n        value: function getCaretRange() {\n            return this.m_caretRange;\n        }\n    }, {\n        key: 'setWords',\n        value: function setWords(words) {\n            var tmp = new _WordObject.WordObject(null, words);\n            this.setContents(tmp);\n        }\n    }, {\n        key: 'getWords',\n        value: function getWords() {\n            var wordsArray = new Array();\n            var words = this.getContents();\n            for (var i = 0; i < words.length; i++) {\n                wordsArray.push(words[i].getWord());\n            }\n            return wordsArray;\n        }\n    }, {\n        key: 'getWordRange',\n        value: function getWordRange(wordNo) {\n            var words = this.getContents();\n            if (wordNo < words.length) {\n                return words[wordNo].getRange();\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'isMathML',\n        value: function isMathML() {\n            return this.math;\n        }\n\n        /**\n         * Get Text before it was modified.\n         */\n\n    }, {\n        key: 'getRawText',\n        value: function getRawText() {\n            return this.m_strRawText;\n        }\n    }, {\n        key: 'setRawText',\n        value: function setRawText(p_strRawText) {\n            this.m_strRawText = p_strRawText;\n        }\n\n        /**\n         * Get text marked up for speech with filtering changes.\n         */\n\n    }, {\n        key: 'getMarkedText',\n        value: function getMarkedText() {\n            return this.m_strMarkedText;\n        }\n    }, {\n        key: 'setMarkedText',\n        value: function setMarkedText(p_strMarkedText) {\n            this.m_strMarkedText = p_strMarkedText;\n        }\n    }, {\n        key: 'clone',\n        value: function clone() {\n            var tmp = new SentenceObject(m_caretRange);\n            tmp.setContents(this.getContents()); // might want to change this to deep clone, but currently does not matter.\n            tmp.setValid(this.isValid());\n            tmp.setVoice(m_strVoice);\n            tmp.setRawText(m_strRawText);\n            tmp.setMarkedText(m_strMarkedText);\n            return tmp;\n        }\n    }, {\n        key: 'splitMathIntoWords',\n        value: function splitMathIntoWords() {\n            if (this.m_strRawText != \"\") {\n                var bookmarks = this.m_strRawText.toLowerCase().match(/<bookmark mark=\"[0-9]+\"\\/>+/g);\n                var words = this.m_strRawText.toLowerCase().split(/<bookmark mark=\"[0-9]+\"\\/>+/g);\n                var j = 0;\n                //check to see if these is a blank word at the start\n                if (words.length > 0 && words[0] == \"\") {\n                    j = 1;\n                }\n                for (var i = 0; i < bookmarks.length; i++) {\n                    var spanId = bookmarks[i].match(/[0-9]+/g);\n                    var tmp = new _MathWordObject.MathWordObject(spanId[0], words[j]);\n                    this.addContent(tmp);\n                    j++;\n                }\n            }\n        }\n\n        /**\n         * This calculates the objects contained in the range provided.  It will assume it is single sentence,\n         * so if passed text with multiple sentences, will still split to appropriate words but not separate\n         * it up in to separate sentences.\n         *\n         * This entry point does additional check that does occur in each step on impl.  At the top need to check if the\n         * selection is with a higher element that wraps up the text in ssml.\n         *\n         * @param p_sentenceObj\n         */\n\n    }, {\n        key: 'processTextToSpeakInSentenceObject',\n        value: function processTextToSpeakInSentenceObject() {\n            // Once has calculated the components, check if any are nested in higher SSML that was outside the selection\n            // but covers part or all of it.\n            this.processTextToSpeakInSentenceObjectImpl();\n\n            var elems = this.getContents();\n\n            // check if elements are in nested SSML.  Note do not allow change in mid word so only check the\n            // start ref.  Even if somehow set to change mid word, it will continue with instruction to end of the word.\n            for (var i = 0; i < elems.length; i++) {\n                var elem = elems[i];\n                var elemNode = elem.getFirstNode();\n                if (elemNode != null && this.isNestedSsml(elemNode)) {\n                    this.insertInWrappingSsml(elems, i, elemNode);\n                }\n            }\n        }\n    }, {\n        key: 'isNestedSsml',\n\n\n        /**\n         * Check if the node is in an element that SSML or nested SSML.\n         * @param p_node\n         */\n        value: function isNestedSsml(p_node) {\n            var top = p_node.ownerDocument.body;\n            var tmp = p_node;\n\n            while (tmp != top && tmp != null) {\n                if (this.checkForSsmlAttribute(tmp) != null) {\n                    return true;\n                }\n                tmp = tmp.parentNode;\n            }\n            return false;\n        }\n\n        /**\n         * Create new elements if need to nest it.\n         * May need to merge following items\n         *\n         * @param p_elems The full array\n         * @param p_nPos position in array\n         * @param p_node the current node\n         */\n\n    }, {\n        key: 'insertInWrappingSsml',\n        value: function insertInWrappingSsml(p_elems, p_nPos, p_node) {\n            var top = p_node.ownerDocument.body;\n            var tmp = p_node;\n            var ssdom = new _SSDOM.SSDOM();\n\n            while (tmp != top && tmp != null) {\n                tmp = tmp.parentNode;\n                if (this.checkForSsmlAttribute(tmp) != null) {\n                    var wrapElement = this.checkForSsmlAttribute(tmp);\n                    if (wrapElement.canContainContent()) {\n                        // replace with this, and maybe susequent items\n                        var tmpToBeContained = p_elems[p_nPos];\n                        p_elems[p_nPos] = wrapElement;\n                        wrapElement.setContents([tmpToBeContained]);\n\n                        // check subsequent items\n                        for (var j = p_nPos + 1; j < p_elems.length; j++) {\n                            var tmpFollowing = p_elems[j];\n                            var tmpFollowingNode = tmpFollowing.getFirstNode();\n                            if (ssdom.checkIfElementInsideElement(tmpFollowingNode, tmp)) {\n                                // This will also be included in the same one.\n\n                                tmpToBeContained = p_elems[j];\n                                wrapElement.addContent(tmpToBeContained);\n                                p_elems.splice(j, 1);\n                                j--;\n                            } else {\n                                break;\n                            }\n                        }\n                    } else {\n                        // replace with this, and maybe susequent items\n                        p_elems[p_nPos] = wrapElement;\n\n                        // check subsequent items\n                        for (var j = p_nPos + 1; j < p_elems.length; j++) {\n                            var tmpFollowing = p_elems[j];\n                            var tmpFollowingNode = tmpFollowing.getFirstNode();\n                            if (ssdom.checkIfElementInsideElement(tmpFollowingNode, tmp)) {\n                                // This will also be included in the same one.\n                                p_elems.splice(j, 1);\n                                j--;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        /**\n         * This calculates the objects contained in the range provided.  It will assume it is single sentence,\n         * so if passed text with multiple sentences, will still split to appropriate words but not separate\n         * it up in to separate sentences.\n         *\n         * @param p_sentenceObj\n         */\n\n    }, {\n        key: 'processTextToSpeakInSentenceObjectImpl',\n        value: function processTextToSpeakInSentenceObjectImpl() {\n            // iterate over range to get text,\n            // When moving to next, first check with goByStyle,\n            //  if hit non style node then treat that as a sentence break\n            // and add a full stop, then look to next with goByStyle = false, as we do want to go beyond that point\n            // This is to allow <div>a</div>b to be a. b rather than ab\n            var ssdom = new _SSDOM.SSDOM();\n\n            try {\n                var stateData = new _TextOverRangeBeanClass.TextOverRangeBeanClass(this);\n\n                this.setupCheck(stateData);\n\n                stateData.startRefPt = ssdom.rw_getRefPt(stateData.leftNode, stateData.leftOffset);\n                stateData.endRefPt = null;\n                while (stateData.currentNode != null) {\n                    if (this.checkIfTooLong(stateData)) {\n                        return;\n                    }\n\n                    var curNode = stateData.currentNode;\n                    if (ssdom.isSpecialCase(curNode)) {\n                        this.handleSpecialCase(stateData);\n                    } else if (curNode.nodeType == 1) {\n                        this.handleElement(stateData);\n                    } else if (curNode.nodeType == 3) {\n                        this.handleTextNode(stateData);\n                    } else // other node type (ie comment)\n                        {\n                            this.moveToNextNode(stateData);\n                        }\n                }\n            } catch (err) {\n                // console.log(\"err processTextToSpeakInSentenceObjectImpl:\"+ err.message);\n                this.setValid(false);\n            }\n        }\n    }, {\n        key: 'handleTextNode',\n        value: function handleTextNode(p_data) {\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            // Get text for current node.\n            var curNode = p_data.currentNode;\n            var curTxt = domNav.getTextFromNode(curNode);\n            if (curTxt == null) {\n                curTxt = \"\";\n            }\n\n            // Check if start or end text node and not to use the entire text node.\n            var nOffset = 0;\n            if (p_data.rightNode == curNode && p_data.rightOffset > -1) {\n                curTxt = curTxt.substring(0, p_data.rightOffset);\n            }\n            if (p_data.leftNode == curNode && p_data.leftOffset > 0) {\n                curTxt = curTxt.substring(p_data.leftOffset);\n                nOffset = p_data.leftOffset;\n            }\n\n            //process the text\n\n            if (curTxt.length == 0 && p_data.storedText.length == 0) {\n                // no text and no stored text so start not reached yet.\n                p_data.startRefPt = null;\n            } else {\n                if (p_data.startRefPt == null || p_data.storedText.length == 0) {\n                    // reached the start of the text, store this point.\n                    p_data.startRefPt = ssdom.rw_getRefPt(curNode, nOffset);\n                }\n\n                // loop through the text, breaking at each word to store separately.\n                var nPos = ssdom.rw_getBreakInCurrentWord(curTxt);\n                while (nPos > -1) {\n                    // Break in middle of text, add text before break to previous text if it exists.\n\n                    // add text up to break and leave text after break for next loop\n                    var strWordToAdd = p_data.storedText + curTxt.substring(0, nPos + 1);\n                    p_data.storedText = this.filterWordToSpeak(strWordToAdd);\n\n                    if (p_data.endRefPt == null || nPos != 0) {\n                        // If point is at start of the node then can use the pt set at the end of the last node if exists\n                        // If nPos > 0 always need new pt whether exists or not\n                        p_data.endRefPt = ssdom.rw_getRefPt(curNode, nPos + nOffset);\n                    }\n\n                    // Will process it if suitable word stored.\n                    this.moveStoredTextToWordObject(p_data);\n\n                    //speech length check\n                    if (this.checkIfTooLong(p_data)) {\n                        p_data.currentNode = null;\n                        return;\n                    }\n\n                    // get next range started\n                    nOffset += nPos + 1;\n                    curTxt = curTxt.substring(nPos + 1);\n\n                    p_data.startRefPt = ssdom.rw_getRefPt(curNode, nOffset);\n                    p_data.endRefPt = null;\n                    nPos = ssdom.rw_getBreakInCurrentWord(curTxt);\n                }\n\n                if (curTxt.length > 0) {\n                    // text remaining to be processed that does not end with sentence break.  Will continue to next loop.\n                    p_data.storedText += curTxt;\n                    // set end ref pt to end of current node (or less if right most)\n                    p_data.endRefPt = ssdom.rw_getRefPt(curNode, curTxt.length + nOffset);\n                    if (p_data.endRefPt == null) {\n                        // error check, if cannot get end ref cannot speak the stored text, set empty to prevent null exception later.\n                        p_data.storedText = \"\";\n                    }\n                }\n\n                // check if at end\n                if (curNode == p_data.rightNode) {\n                    this.moveStoredTextToWordObject(p_data);\n                    p_data.currentNode = null;\n                    return;\n                }\n            }\n\n            this.moveToNextNode(p_data);\n        }\n\n        /**\n         * Check if the text needs to be altered\n         * @param p_strText\n         */\n\n    }, {\n        key: 'filterWordToSpeak',\n        value: function filterWordToSpeak(p_strText) {\n            var ssdom = new _SSDOM.SSDOM();\n            var utils = new _Utilities.Utilities();\n            if (utils.trim(p_strText) == \"*\") {\n                // special case if use maths and * is included then keep.\n                //          todo  if(! (/*g_bMathsSymbols &&*/ ssdom.rw_mathsSymbolCheck(\"*\")) )\n                //            {   // normal case so remove so does not say \"asterix\".\n                //                p_strText = \"\";\n                //            }\n            }\n\n            return p_strText;\n        }\n\n        /**\n         * This handles non special case elements.\n         *\n         * However this can include SSML element handling.\n         * @param p_data\n         */\n\n    }, {\n        key: 'handleElement',\n        value: function handleElement(p_data) {\n            var curNode = p_data.currentNode;\n\n            // check for SSML\n            var ssmlElem = this.checkForSsmlAttribute(curNode);\n\n            if (ssmlElem != null) //todo\n                {// nest items inside an SSML element.  This is always word break.\n                    //            this.moveStoredTextToWordObject(p_data);\n                    //\n                    //            if(curNode.childNodes.length > 0)\n                    //            {\n                    //                // set contents of the element with everything created by nested call.\n                    //                var newLeftCaret = new THCaret(curNode.firstChild, 0, true);\n                    //                var newRightCaret = new THCaret(curNode.lastChild,\n                    //                    ((curNode.lastChild.nodeType==3)?curNode.lastChild.nodeValue.length:-1),\n                    //                    false);\n                    //                var newSentObj = new SentenceObject(new THCaretRange(newLeftCaret, newRightCaret));\n                    //                this.processTextToSpeakInSentenceObjectImpl(newSentObj);\n                    //                if(newSentObj.isValid())\n                    //                {\n                    //                    ssmlElem.setContents(newSentObj.getContents());\n                    //                    p_data.sentenceObject.addContent(ssmlElem);\n                    //                }\n                    //            }\n                    //            else if(ssmlElem instanceof SpeechStream.speechDom.BreakElement)\n                    //            {\n                    //                p_data.sentenceObject.addContent(ssmlElem);\n                    //            }\n                    //\n                    //            // move to next, as special case never go to child nodes\n                    //            p_data.currentNode = SSDOM.getNextNodeIgnoreChildren(curNode, false, p_data.rightNode);\n                } else {\n                // check if is break element\n                //            if(SpeechStream.pauseHandler.isPauseElement(curNode)) //todo\n                //            {\n                //                moveStoredTextToWordObject(p_data);\n                //\n                //\n                //                var nTime = SpeechStream.pauseHandler.getPauseTimeFromNode(curNode);\n                //                if(!isNaN(nTime))\n                //                {\n                //                    var silenceElem = new SpeechStream.speechDom.SilenceObject(\"\" + nTime);\n                //                    p_data.sentenceObject.addContent(silenceElem);\n                //                }\n                //            }\n\n                this.moveToNextNode(p_data);\n            }\n        }\n    }, {\n        key: 'moveToNextNode',\n        value: function moveToNextNode(p_data) {\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            var curNode = p_data.currentNode;\n\n            // move to next, check for break points (div p etc)\n            var tmpNote = domNav.getNextNode(curNode, true, p_data.rightNode);\n            if (tmpNote == null) {\n                // hit a break point, move any stored text to word object\n                p_data.storedText = this.getTextOverRangeToSpeakAddFullStop(p_data.storedText);\n                this.moveStoredTextToWordObject(p_data);\n\n                p_data.currentNode = domNav.getNextNode(curNode, false, p_data.rightNode);\n            } else {\n                p_data.currentNode = tmpNote;\n            }\n        }\n\n        /**\n         * This adds a full stop to end of the text to make the speech engine treat it as a sentence when speaking it.\n         * This is for niche case where range includes sentence break elements without the first sentence ending in\n         * full stop.  This would lead to 'a b' rather than 'a. b' between sentences so would not pause correctly\n         * when reading.\n         * @param p_storedText\n         */\n\n    }, {\n        key: 'getTextOverRangeToSpeakAddFullStop',\n        value: function getTextOverRangeToSpeakAddFullStop(p_storedText) {\n            var ssdom = new _SSDOM.SSDOM();\n            var tmpLen = p_storedText.length;\n            // check if already ends with '.' or '. '\n            if (tmpLen > 1 && p_storedText.substr(tmpLen - 2, 2) == \". \") {\n                //no need to add to it\n                return p_storedText;\n            } else if (tmpLen > 0 && p_storedText.substr(tmpLen - 1, 1) == \".\") {\n                //just add the space\n                return p_storedText + \" \";\n            } else {\n                // get the last character, only add a full stop after a letter.\n                //(with number may hit speech engine bug and say 'one point' for 1.)\n                var utils = new _Utilities.Utilities();\n                var txt = utils.trimEndTH(p_storedText);\n                var c = txt.charCodeAt(txt.length - 1);\n\n                if (ssdom.rw_isLetter(c) || c > 127) {\n                    // add the '. '\n                    return p_storedText + \". \";\n                } else {\n                    return p_storedText;\n                }\n            }\n        }\n\n        /**\n         * Handle what the toolbar considers special cases (like span pron=...)\n         * @param p_data\n         */\n\n    }, {\n        key: 'handleSpecialCase',\n        value: function handleSpecialCase(p_data) {\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            // Ensure any stored text is processed before handling special case.\n            this.moveStoredTextToWordObject(p_data);\n\n            var curNode = p_data.currentNode;\n\n            //Get text\n            p_data.storedText = domNav.getTextFromNode(curNode);\n\n            //Get ref pts\n            if (ssdom.isSpecialCaseHighlightable(curNode)) {\n                var firstNode = domNav.getFirstChildTextNode(curNode, false);\n                var lastNode = domNav.getLastChildTextNode(curNode, false);\n\n                if (firstNode != null && lastNode != null) {\n                    if (firstNode.nodeType == 3 && lastNode.nodeType == 3) {\n                        p_data.startRefPt = ssdom.rw_getRefPt(firstNode, 0);\n                        p_data.endRefPt = ssdom.rw_getRefPt(lastNode, lastNode.nodeValue.length);\n                    } else {\n                        // should be for tagName is \"math\" for mathml or firstNode.isMathJax\n                        p_data.startRefPt = ssdom.rw_getRefPt(firstNode, -1);\n                        p_data.endRefPt = ssdom.rw_getRefPt(lastNode, -1);\n                    }\n                } else {\n                    p_data.startRefPt = ssdom.rw_getRefPt(curNode, -1);\n                    p_data.endRefPt = p_data.startRefPt;\n                }\n            } else {\n                p_data.startRefPt = ssdom.rw_getRefPt(curNode, -1);\n                p_data.endRefPt = p_data.startRefPt;\n            }\n\n            // store word\n            this.moveStoredTextToWordObject(p_data);\n\n            // move to next, as special case never go to child nodes\n            p_data.currentNode = domNav.getNextNodeIgnoreChildren(curNode, false, p_data.rightNode);\n        }\n\n        /**\n         * Add current stored text to the sentence, as long as is speakable and also if start and end points are\n         * set.\n         * @param p_data\n         */\n\n    }, {\n        key: 'moveStoredTextToWordObject',\n        value: function moveStoredTextToWordObject(p_data) {\n            var ssdom = new _SSDOM.SSDOM();\n            if (ssdom.rw_isWordSpeakable(p_data.storedText) && p_data.startRefPt != null && p_data.endRefPt != null) {\n                var tmp = new _WordObject.WordObject(new _THRange.THRange(p_data.body, p_data.startRefPt, p_data.endRefPt), p_data.storedText);\n                p_data.sentenceObject.addContent(tmp);\n            }\n            this.clearState(p_data);\n        }\n    }, {\n        key: 'clearState',\n        value: function clearState(p_data) {\n            p_data.startRefPt = null;\n            p_data.endRefPt = null;\n            p_data.storedText = \"\";\n        }\n    }, {\n        key: 'checkIfTooLong',\n        value: function checkIfTooLong(p_data) {\n            var MAX_WORDCOUNT_TO_SPEAK = 500; //todo\n            //speech length check\n            if (MAX_WORDCOUNT_TO_SPEAK > 0 && p_data.sentenceObject.getWordCount() > MAX_WORDCOUNT_TO_SPEAK) {\n                // too long\n                //            if(g_bSpeechCacheGenerateFlag)\n                //            {\n                //                throw \"Full selection will not be spoken due to its length.\";\n                //            }\n                //            else\n                //            {\n                //                rw_alert(\"Full selection will not be spoken due to its length.\");\n                //            }\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: 'setupCheck',\n        value: function setupCheck(p_data) {\n            var ssdom = new _SSDOM.SSDOM();\n            var domNav = new _DomNavigation.DomNavigation();\n            // At start need to check if the starting node is suitable place.\n            // If it is an element and not a special case need to move to next text node.\n            // Include moving over breaks if no match before that, if nothing before break, then nothing to add.\n            if (p_data.leftNode.nodeType == 1) {\n                if (!ssdom.isSpecialCase(p_data.leftNode) && this.checkForSsmlAttribute(p_data.leftNode) == null) {\n                    p_data.leftNode = domNav.getNextNodeAllowMoveToChild(p_data.currentNode, false, p_data.rightNode);\n                    p_data.leftOffset = 0;\n                }\n            }\n\n            // ssml\n        }\n\n        /**\n         * This checks for SSML where the SSML is included in the HTML as attribute SSML and separate attribue\n         * giving the details.  So ssml=\"sub  alias=\"...\"\n         *\n         * @param p_curNode\n         */\n\n    }, {\n        key: 'checkForSsmlAttribute',\n        value: function checkForSsmlAttribute(p_curNode) {\n            if (p_curNode.nodeType == 1) {\n                var result = this.checkForSsmlNoNamespace(p_curNode);\n                if (result != null) {\n                    return result;\n                }\n\n                result = this.checkForSsmlNamespace(p_curNode);\n                if (result != null) {\n                    return result;\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Check for ssml in format ssml:<config>=\"\" ...\n         *\n         * According to standard for this (so far) with this there should be a page level value\n         * @param p_curNode\n         */\n\n    }, {\n        key: 'checkForSsmlNamespace',\n        value: function checkForSsmlNamespace(p_curNode) {\n            //todo\n            //        var htmlElem = p_curNode.ownerDocument.body.parentNode;\n            //        if(rw_getAttribute(htmlElem, \"xmlns:ssml\"))\n            //        {\n            //            // check for page level alphabet\n            //            var strAlpha = rw_getAttribute(htmlElem, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.ALPHABET);\n            //\n            //            // todo switch to using rw_getAttribute\n            //\n            //            if(rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.PH))  //PHONEME\n            //            {\n            //                var strLocalAlpha = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.ALPHABET);\n            //                var strPh = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.PH);\n            //\n            //                if(strLocalAlpha == null)\n            //                {\n            //                    strLocalAlpha = strAlpha;\n            //                }\n            //\n            //                if(strLocalAlpha != null && strPh != null)\n            //                {\n            //                    return new SpeechStream.speechDom.PhonemeElement(p_curNode, strLocalAlpha, strPh);\n            //                }\n            //            }\n            //\n            //            if(rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.ALIAS))\n            //            {\n            //                var strAlias = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.ALIAS ); //sub\n            //\n            //                if(strAlias != null)\n            //                {\n            //                    return new SpeechStream.speechDom.SubElement(p_curNode, strAlias);\n            //                }\n            //            }\n            //\n            //            if(rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.INTERPRETAS))\n            //            {\n            //                var strInt = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.INTERPRETAS ); //sayas\n            //                var strFormat = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.FORMAT ); //sayas\n            //\n            //                if(strInt != null)\n            //                {\n            //                    return new SpeechStream.speechDom.SayasElement(p_curNode, strInt, strFormat);\n            //                }\n            //            }\n            //\n            //            if(rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_TYPES.EMPHASIS))\n            //            {\n            //                var strLevel = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.LEVEL ); //emphasis\n            //\n            //                if(strLevel != null)\n            //                {\n            //                    return new SpeechStream.speechDom.EmphasisElement(p_curNode, strLevel);\n            //                }\n            //            }\n            //\n            //            if(rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_TYPES.BREAK))\n            //            {\n            //                var strTime = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.TIME ); //break\n            //                var strStrength = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.STRENGTH ); //break\n            //\n            //                if(strTime != null)\n            //                {\n            //                    return new SpeechStream.speechDom.BreakElement(p_curNode, strTime, strStrength);\n            //                }\n            //            }\n            //\n            //\n            //            if(rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_TYPES.PROSODY))\n            //            {\n            //                var strPitch = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.PITCH ); //prosody\n            //                var strRate = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.RATE ); //prosody\n            //                var strVolume = rw_getAttribute(p_curNode, SSML_NAMESPACE + \":\" + SSMS_ATTRIBUTES.VOLUME ); //prosody\n            //\n            //                if(strTime != null)\n            //                {\n            //                    return new SpeechStream.speechDom.ProsodyElement(p_curNode, strPitch, strRate, strVolume);\n            //                }\n            //            }\n            //        }\n            return null;\n        }\n\n        /**\n         * Check for the ssml format of  ssml=\"<type>\" <config name>=\"\"\n         * @param p_curNode\n         */\n\n    }, {\n        key: 'checkForSsmlNoNamespace',\n        value: function checkForSsmlNoNamespace(p_curNode) {\n            //todo\n            //        var ssdom = new SSDOM();\n            //        if(ssdom.rw_getAttribute(p_curNode, this.SSML_NAMESPACE))\n            //        {\n            //            var strSsmlType = ssdom.rw_getAttribute(p_curNode, this.SSML_NAMESPACE);\n            //            // has ssml\n            //            if(strSsmlType == this.SSMS_TYPES.PHONEME)\n            //            {\n            //                var strAlpha = \"ipa\";\n            //                // check if alphabet value in element\n            //                if(ssdom.rw_getAttribute(p_curNode, this.SSMS_ATTRIBUTES.ALPHABET) !== null)\n            //                {\n            //                    strAlpha = ssdom.rw_getAttribute(p_curNode, this.SSMS_ATTRIBUTES.ALPHABET);\n            //                }\n            //\n            //                return new SpeechStream.speechDom.PhonemeElement(p_curNode, strAlpha, rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.PH));\n            //            }\n            //\n            //            if(strSsmlType == SSMS_TYPES.SUB)\n            //            {\n            //                if(rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.ALIAS))\n            //                {\n            //                    return new SpeechStream.speechDom.SubElement(p_curNode, rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.ALIAS));\n            //                }\n            //            }\n            //\n            //            if(strSsmlType == SSMS_TYPES.SAYAS)\n            //            {\n            //                if(rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.INTERPRETAS))\n            //                {\n            //                    return new SpeechStream.speechDom.SayasElement(p_curNode,\n            //                        rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.INTERPRETAS),\n            //                        rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.FORMAT));\n            //                }\n            //            }\n            //\n            //\n            //            if(strSsmlType == SSMS_TYPES.EMPHASIS)\n            //            {\n            //                return new SpeechStream.speechDom.EmphasisElement(p_curNode,\n            //                    rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.LEVEL));\n            //            }\n            //\n            //            if(strSsmlType == SSMS_TYPES.BREAK)\n            //            {\n            //                return new SpeechStream.speechDom.BreakElement(p_curNode,\n            //                    rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.TIME),\n            //                    rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.STRENGTH));\n            //            }\n            //\n            //            if(strSsmlType == SSMS_TYPES.PROSODY)\n            //            {\n            //                return new SpeechStream.speechDom.ProsodyElement(p_curNode,\n            //                    rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.PITCH),\n            //                    rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.RATE),\n            //                    rw_getAttribute(p_curNode, SSMS_ATTRIBUTES.VOLUME));\n            //            }\n            //        }\n            return null;\n        }\n\n        //todo to be removed\n        /**\n         * This checks if commands in the HTML to be read apply to the speech.\n         */\n\n    }, {\n        key: 'checkForCommands',\n        value: function checkForCommands() {\n            if (g_bUseCommands) {\n                var sentences = this.getSentences();\n\n                var sentence;\n                var i;\n                for (i = 0; i < sentences.length; i++) //note array can increase during loop, so keep length check in loop not stored before.\n                {\n                    sentence = sentences[i];\n                    var leftCaret = sentence.getCaretRange().leftCaret;\n                    var rightCaret = sentence.getCaretRange().rightCaret;\n\n                    var startElement = rw_findCommandNode(leftCaret.node);\n\n                    // Check if needs to break\n                    var newRightCommandCaret = rw_checkForCommandChange(leftCaret.node, rightCaret.node, startElement);\n\n                    if (newRightCommandCaret != null) {\n                        // split the sentence\n                        var newSentence = sentence.clone();\n                        var followingSentence = sentence.clone();\n\n                        var newRange = new THCaretRange(leftCaret, newRightCommandCaret);\n\n                        var followingLeftCaret = newRightCommandCaret.clone();\n                        followingLeftCaret.forwardBias = true;\n                        followingLeftCaret = _SSDOM.SSDOM.moveCaret(followingLeftCaret, 0, false); // if at end of element, this moves to start of the next one.\n                        var followingRange = new THCaretRange(followingLeftCaret, rightCaret);\n\n                        newSentence.setCaretRange(newRange);\n                        followingSentence.setCaretRange(followingRange);\n\n                        // add in to the array.\n                        sentences.splice(i, 1, newSentence, followingSentence);\n                    }\n                }\n                this.setSentences(sentences);\n            }\n        }\n    }]);\n\n    return SentenceObject;\n}(_BaseObject2.BaseObject);\n\n},{\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/DomNavigation\":3,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/MathJax/MathSpeak\":16,\"src/SpeechStream/Sentence/BaseObject\":22,\"src/SpeechStream/Sentence/MathWordObject\":23,\"src/SpeechStream/Sentence/WordObject\":25,\"src/SpeechStream/THDomRange\":29,\"src/SpeechStream/THRange\":31,\"src/SpeechStream/TextOverRangeBeanClass\":33,\"src/SpeechStream/Utilities/Utilities\":34}],25:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.WordObject = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BaseObject2 = require('src/SpeechStream/Sentence/BaseObject');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by kevin on 06/04/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n/**\n * Created by IntelliJ IDEA.\n * User: stuart\n * Date: 02/06/15\n * Time: 13:59\n * This is for a word of a page stored in way to assist toolbar speech.\n */\n\n\n/**\n * Public API\n * Inherit from BaseObject\n *\n * getWord\n * setPronunciation\n * getPronunciation\n * isOverridingText\n * getSpokenText\n *\n * @param p_range THRange\n * @param p_strWord the text of the word\n */\nvar WordObject = exports.WordObject = function (_BaseObject) {\n    _inherits(WordObject, _BaseObject);\n\n    function WordObject(p_range, p_strWord) {\n        _classCallCheck(this, WordObject);\n\n        //todo\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(WordObject).call(this, 1));\n\n        _this.setRange(p_range);\n\n        _this.m_strWord = p_strWord; // Word for the given object.  Read only.\n        _this.m_strPronunciation = null; // If word is to be changed, it is given a pronunciation to override it.\n        return _this;\n    }\n\n    // getters / setters\n\n    /**\n     * Get the current word set to this object\n     */\n\n\n    _createClass(WordObject, [{\n        key: 'getWord',\n        value: function getWord() {\n            return this.m_strWord;\n        }\n    }, {\n        key: 'setPronunciation',\n\n\n        /**\n         *\n         * @param p_strPron\n         */\n        value: function setPronunciation(p_strPron) {\n            this.m_strPronunciation = p_strPron;\n        }\n    }, {\n        key: 'getPronunciation',\n        value: function getPronunciation() {\n            return this.m_strPronunciation;\n        }\n    }, {\n        key: 'isOverridingText',\n\n\n        // impl\n\n        /**\n         *Override from base type\n         */\n        value: function isOverridingText() {\n            return this.m_strPronunciation != null;\n        }\n    }, {\n        key: 'getSpokenText',\n\n\n        /**\n         * Override from base type\n         */\n        value: function getSpokenText() {\n            var str;\n            if (this.m_strPronunciation != null) {\n                str = this.m_strPronunciation;\n            } else {\n                str = this.m_strWord;\n            }\n\n            return str;\n            //todo return SpeechStream.speechDom.util.filterWord(str);\n        }\n    }]);\n\n    return WordObject;\n}(_BaseObject2.BaseObject);\n\n},{\"src/SpeechStream/Sentence/BaseObject\":22}],26:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SpeechObject = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BaseObject2 = require('src/SpeechStream/Sentence/BaseObject');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _SentenceObject = require('src/SpeechStream/Sentence/SentenceObject');\n\nvar _THCaret = require('src/SpeechStream/THCaret');\n\nvar _Utilities = require('src/SpeechStream/Utilities/Utilities');\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nvar _THDomRange = require('src/SpeechStream/THDomRange');\n\nvar _DomSentences = require('src/SpeechStream/DOM/DomSentences');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Created by kevin on 06/04/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */\n\n/**\n * Created by IntelliJ IDEA.\n * User: stuart\n * Date: 02/06/15\n * Time: 13:59\n * This is for a section of a page stored in way to assist toolbar speech.  It may include multiple sentences.\n * Not necessary the entire document of page.\n *\n * Dependency  SSDOM\n */\n\n/**\n * The SpeechObject contains text from an HTML page to be spoken.  Split up in to SentenceObjects.\n *\n * Public API\n * Inherit from BaseObject\n *\n * setSentences\n * getSentences\n * setBatch\n * isBatch\n * processSentence\n * getFirstSentence\n *\n *\n * All this functions.\n */\nvar SpeechObject = exports.SpeechObject = function (_BaseObject) {\n    _inherits(SpeechObject, _BaseObject);\n\n    function SpeechObject() {\n        _classCallCheck(this, SpeechObject);\n\n        //todo\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SpeechObject).call(this, 3));\n\n        _this.m_bBatch = false;\n        _this.SSML_NAMESPACE = \"ssml\";\n\n        _this.SSMS_TYPES = {\n            SUB: \"sub\",\n            PHONEME: \"phoneme\",\n            SAYAS: \"say-as\",\n            EMPHASIS: \"emphasis\",\n            BREAK: \"break\",\n            PROSODY: \"prosody\"\n        };\n\n        _this.SSMS_ATTRIBUTES = {\n            ALPHABET: \"alphabet\",\n            PH: \"ph\",\n            ALIAS: \"alias\",\n            INTERPRETAS: \"interpret-as\",\n            FORMAT: \"format\",\n\n            LEVEL: \"level\",\n            STRENGTH: \"strength\",\n            TIME: \"time\",\n            PITCH: \"pitch\",\n            RATE: \"rate\",\n            VOLUME: \"volume\"\n\n        };\n        _this.sentenceNo = 0;\n        return _this;\n    }\n\n    // getters / setters\n    /**\n     * Wrapper for setContents call.\n     * @param p_contents\n     */\n\n\n    _createClass(SpeechObject, [{\n        key: 'setSentences',\n        value: function setSentences(p_contents) {\n            this.setContents(p_contents);\n        }\n\n        /**\n         * Wrapper for getContents\n         */\n\n    }, {\n        key: 'getSentences',\n        value: function getSentences() {\n            return this.getContents();\n        }\n    }, {\n        key: 'setBatch',\n        value: function setBatch(p_bBatch) {\n            this.m_bBatch = p_bBatch;\n        }\n    }, {\n        key: 'isBatch',\n        value: function isBatch() {\n            return this.m_bBatch;\n        }\n    }, {\n        key: 'getNextSentence',\n        value: function getNextSentence(continousReading) {\n            this.sentenceNo++;\n            var sentences = this.getSentences();\n            if (this.sentenceNo < sentences.length) {\n                //check that test is words in this sentence so that we don't return a blank sentence\n                // when there are still sentences to read.\n                if (sentences[this.sentenceNo].getWords().length == 0) {\n                    return this.getNextSentence(continousReading);\n                } else {\n                    return sentences[this.sentenceNo];\n                }\n            } else if (continousReading) {\n                var last = sentences[sentences.length - 1];\n                var range = last.getCaretRange();\n                last.m_range.refresh();\n                var caretRange = new _THCaretRange.THCaretRange(last.m_range.body, last.m_range.startRef.path, last.m_range.startRef.offset, last.m_range.endRef.path, last.m_range.endRef.offset);\n                var domSent = new _DomSentences.DomSentences();\n                var range = domSent.getSentenceFromPoint(caretRange.leftCaret);\n                var next = domSent.getNextSentence(range, null);\n                var sentence = this.processSentence(next);\n                this.m_contents.length = 0;\n                this.setSentences.apply(this, _toConsumableArray(sentence));\n                this.sentenceNo = 0;\n                if (sentence[0].getWords().length == 0) {\n                    return this.getNextSentence(continousReading);\n                } else {\n                    return sentence[0];\n                }\n            }\n            return null;\n        }\n    }, {\n        key: 'getCurrentSentence',\n        value: function getCurrentSentence() {\n            var sentences = this.getSentences();\n            if (this.sentenceNo < sentences.length) {\n                return sentences[this.sentenceNo];\n            } else {\n                return sentences[sentences.length - 1];\n            }\n            return null;\n        }\n    }, {\n        key: 'getFirstSentence',\n        value: function getFirstSentence() {\n            this.sentenceNo = 0;\n            if (this.getSentences().length > 0) {\n                return this.getSentences()[0];\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'processRange',\n        value: function processRange(thDomRange, hoverSpeak) {\n            this.setSentences([]); //clear the array\n            this.sentenceNo = 0;\n            var caretRange = new _THCaretRange.THCaretRange(thDomRange.body, thDomRange.startRef.path, thDomRange.startRef.offset, thDomRange.endRef.path, thDomRange.endRef.offset);\n\n            if (thDomRange.startCaret.node.tagName && thDomRange.startCaret.node.tagName.toLowerCase() == \"textarea\") {\n                var sent = new _SentenceObject.SentenceObject(caretRange);\n                sent.setWords(thDomRange.startCaret.node.value);\n                sent.m_strRawText = thDomRange.startCaret.node.value;\n                this.setSentences(sent);\n            } else {\n                var _sentences;\n\n                var domSent = new _DomSentences.DomSentences();\n                var range = domSent.getSentenceFromPoint(caretRange.leftCaret);\n\n                var sentences = new Array();\n                var sentence = this.processSentence(range);\n                (_sentences = sentences).push.apply(_sentences, _toConsumableArray(sentence));\n                if (!hoverSpeak) {\n                    var hasMoreSentences = true;\n                    do {\n                        var nextSentence = domSent.getNextSentence(range, caretRange.rightCaret.node);\n\n                        if (nextSentence != null) {\n                            if (nextSentence.leftCaret.node != caretRange.rightCaret.node || nextSentence.leftCaret.offset < caretRange.rightCaret.offset) {\n\n                                sentence = this.processSentence(nextSentence);\n                                if (sentence != null) {\n                                    var _sentences2;\n\n                                    (_sentences2 = sentences).push.apply(_sentences2, _toConsumableArray(sentence));\n                                }\n                                range = nextSentence;\n                            } else {\n                                hasMoreSentences = false;\n                            }\n                        } else {\n                            hasMoreSentences = false;\n                        }\n                    } while (hasMoreSentences);\n\n                    if (sentences.length == 1 && range.rightCaret.offset > caretRange.rightCaret.offset && caretRange.rightCaret.offset != caretRange.leftCaret.offset) {\n                        sentences = this.processSentence(caretRange);\n                    }\n                }\n\n                this.setSentences(sentences);\n            }\n        }\n        // impl\n\n        /**\n         * Process a given range for the first sentence to be read in it.\n         * Various aspects might result in the range of the sentence being truncated.\n         * @param p_caretRange\n         */\n\n    }, {\n        key: 'processSentence',\n        value: function processSentence(p_caretRange) {\n            // iterate over range to get text, store as array of sentences\n            try {\n                // check range exists and has valid start and end points.\n                if (!this.checkRange(p_caretRange)) {\n                    this.setValid(false);\n                }\n\n                // clear contents\n                //this.setSentences([]);\n\n                // Assume contains sentence, start with that till discover otherwise.\n                var currentSentence = new _SentenceObject.SentenceObject(p_caretRange);\n\n                // Get sentences as split by language if necessary, returns an array of SentenceObjects.\n                var sentences = this.splitSentenceByLanguage(currentSentence);\n                if (sentences.length == 0) {\n                    this.setValid(false);\n                }\n\n                // set contents of this speech object to be the array of sentence objects (one sentence or several if split buy language)\n                //this.setSentences(sentences);\n\n\n                //todo check that correct to remove this.  Instead of breaking here, break should be in target selection\n                // which is done using logic to move to next target not going past cmd breaks.\n                // check for custom texthelp commands that would break up a sentence.\n                // This will use what is currently set as the contents.\n                //checkForCommands();\n\n\n                //\n                //  The main processing occurs here.\n                //\n\n                //todo var nLen = (this.m_bBatch?this.getSentences().length:1);\n                var nLen = sentences.length;\n                // if only want the first sentence will just process the first and others obtained later.\n\n                for (var i = 0; i < nLen; i++) {\n                    // populate sentence with elements in its range\n                    if (!sentences[i].isMathML()) {\n                        sentences[i].processTextToSpeakInSentenceObject();\n                    }\n\n                    // populate sentence with the text to speak\n                    // todo var tmp = new SpeechStream.speechDom.SpeechBuilder(SpeechStream.SpeechRequestBookmarks.ALL);\n                    //tmp.processText(this.getSentences()[i]);\n                }\n                return sentences;\n            } catch (err) {\n                // console.log(\"err SpeechObject processSentence:\" + \"|\"+ err.message);\n                this.setValid(false);\n            }\n            return null;\n        }\n    }, {\n        key: 'splitSentenceByLanguage',\n\n\n        /**\n         * This checks if language changes over the range and truncates accordingly, also if there is a voice set\n         * other than page default this is added to the sentence.\n         *\n         * If no changes, returns original sentence.\n         * @param p_currentSentence\n         * returns array of sentences. (SentenceObject)\n         */\n        value: function (_splitSentenceByLanguage) {\n            function splitSentenceByLanguage(_x) {\n                return _splitSentenceByLanguage.apply(this, arguments);\n            }\n\n            splitSentenceByLanguage.toString = function () {\n                return _splitSentenceByLanguage.toString();\n            };\n\n            return splitSentenceByLanguage;\n        }(function (p_currentSentence) {\n            var caretRange = p_currentSentence.getCaretRange();\n            var leftCaret = caretRange.leftCaret;\n            var rightCaret = caretRange.rightCaret;\n            var bInTranslatePopup = false;\n            if (false) //todo!g_bVoiceFromLangFlag)\n                {\n                    // if inside a translation popup screen still want to check for lang flag\n                    // even when turned off for the rest of the page.\n\n                    var tmpNode = leftCaret.node;\n                    var tmpId;\n                    var tmpClass;\n\n                    while (tmpNode != null) {\n                        if (tmpNode.nodeType == 1) {\n                            tmpId = tmpNode.getAttribute(\"id\");\n                            tmpClass = tmpNode.getAttribute(\"class\");\n\n                            if (tmpClass != null) {\n                                if (tmpClass.indexOf(\"contentTranslate\") > -1) {\n                                    bInTranslatePopup = true;\n                                    break;\n                                }\n                            }\n\n                            if (tmpId != null && tmpId.length > 0) {\n                                if (tmpId == \"rwpopuptrans\") {\n                                    bInTranslatePopup = true;\n                                    break;\n                                } else {\n                                    if (tmpId.indexOf(\"rwMeaning\") != 0 && tmpId.indexOf(\"rwHeadWord\") != 0) {\n                                        // if rwMeaning want to keep going up otherwise break as any other id means not in trans popup\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        tmpNode = tmpNode.parentNode;\n                    }\n                }\n\n            // check for custom voice tag\n            if (false /*todo g_bVoiceFromLangFlag*/ || bInTranslatePopup) {\n                var strVoice = rw_getVoiceSetForNode(leftCaret.node);\n                if (strVoice != null) {\n                    p_currentSentence.setVoice(strVoice);\n                }\n\n                //Check for case of one sentence with multiple lang ...\n                // check if lang changes over course of the range.  If so need to limit the range to single language.\n                var newRightCaret = rw_checkForVoiceChange(leftCaret.node, rightCaret.node, strVoice);\n                if (newRightCaret != null) {\n                    var secondSentenceCaret = newRightCaret.clone();\n                    secondSentenceCaret.forwardBias = true;\n                    secondSentenceCaret = _SSDOM.SSDOM.moveCaret(secondSentenceCaret, 0, false); //still between same points but moves to 'before next' rather than 'after previous', which might be different places in the DOM.\n\n                    var leftNewCaretRange = new _THCaretRange.THCaretRange(leftCaret, newRightCaret);\n                    var rightNewCaretRange = new _THCaretRange.THCaretRange(secondSentenceCaret, rightCaret);\n                    var secondSentence = p_currentSentence.clone();\n\n                    p_currentSentence.setCaretRange(leftNewCaretRange);\n                    secondSentence.setCaretRange(rightNewCaretRange);\n                    secondSentence.setVoice(null); // will have copied from first, which might not apply\n\n                    // range has been reduced, make sure still has speech\n                    var txt = leftNewCaretRange.toString();\n                    if (txt.length == 0 || !rw_isWordSpeakable(txt)) {\n                        // First sentence is not valid.  Assuming that got here with valid sentence, to speakable part\n                        // is now just in the second sentence.\n                        // Second sentence, might need to be split further.\n                        return splitSentenceByLanguage(secondSentence);\n                    } else {\n                        var tmpArr = [];\n                        tmpArr.push(p_currentSentence);\n                        tmpArr = tmpArr.concat(splitSentenceByLanguage(secondSentence));\n                        return tmpArr;\n                    }\n                }\n            }\n\n            // no split so just return current sentence\n            return [p_currentSentence];\n        })\n\n        /**\n         * Check range, return false on error.\n         * @param p_caretRange\n         */\n\n    }, {\n        key: 'checkRange',\n        value: function checkRange(p_caretRange) {\n            var ssdom = new _SSDOM.SSDOM();\n            if (p_caretRange == null || p_caretRange.leftCaret == null || p_caretRange.rightCaret == null || p_caretRange.leftCaret.node == null || p_caretRange.rightCaret.node == null) {\n                return false;\n            }\n\n            // Check if start or end point needs to be moved.\n\n            var leftCaret = p_caretRange.leftCaret;\n            var rightCaret = p_caretRange.rightCaret;\n\n            // the left node and right node might be inside a text node that is a special case\n            // such and a span with a pron tag.  This will be missed if selection starts inside it.\n            var tmpPar = ssdom.checkForSpecialParent(leftCaret.node);\n            if (tmpPar != null) {\n                // if change range here, dont think it needs to be passed back through\n                leftCaret.node = tmpPar;\n                leftCaret.setSpecialCase(true);\n                p_caretRange.leftCaret = leftCaret;\n            }\n\n            tmpPar = ssdom.checkForSpecialParent(rightCaret.node);\n            if (tmpPar != null) {\n                // if change range here, dont think it needs to be passed back through\n                rightCaret.node = tmpPar;\n                rightCaret.setSpecialCase(true);\n                p_caretRange.rightCaret = rightCaret;\n            }\n\n            return true;\n        }\n    }]);\n\n    return SpeechObject;\n}(_BaseObject2.BaseObject);\n\n},{\"src/SpeechStream/DOM/DomSentences\":4,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/Sentence/BaseObject\":22,\"src/SpeechStream/Sentence/SentenceObject\":24,\"src/SpeechStream/THCaret\":27,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/THDomRange\":29,\"src/SpeechStream/Utilities/Utilities\":34}],27:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevin on 31/03/16.\n */\n\n// Dependant on SSDOM\n\n\n// NB according to one site I should use ClassName.prototype.methodname = function(){}\n// rather than put inside initial function this.methodname = function(){}\n// due to later having memory leaks in IE.  Need to check this later.\n\n/*\n /**\n * This holds a point in the text in the document.\n * It is marked by a text node and an offset in that node.\n * This should only be used temporarily, if stored for later may become invalid.\n *\n * @param p_node DOM element\n * @param p_nOffset integer offset\n * @param p_bForwardBias boolean\n */\nvar THCaret = exports.THCaret = function () {\n    function THCaret(p_node, p_nOffset, p_bForwardBias) {\n        _classCallCheck(this, THCaret);\n\n        this.node = p_node;\n        this.offset = p_nOffset;\n        this.forwardBias = p_bForwardBias;\n        this.specialCase = false;\n\n        //        // (Unit test note external dependency)\n        //        if (SSDOM.checkForSpecialParent(this.node) != null) {\n        //            this.specialCase = true;\n        //            //this.offset = 0;\n        //        }\n    }\n\n    _createClass(THCaret, [{\n        key: \"setSpecialCase\",\n        value: function setSpecialCase(p_bSpecialCase) {\n            this.specialCase = p_bSpecialCase;\n            if (p_bSpecialCase) {\n                //this.offset = 0;\n            }\n        }\n    }, {\n        key: \"isSpecialCase\",\n        value: function isSpecialCase() {\n            return this.specialCase;\n        }\n    }, {\n        key: \"check\",\n\n\n        /* Checks if is valid caret position in the dom, ie is text node with offset inside the node.\n         This is to check that it can be used to access item in dom with range object for example.\n         If so return true, otherwise return false.*/\n        value: function check() {\n            var bValid = true;\n            if (this.node == null || this.node.parentNode == null) {\n                // doesn't exist or is orphaned so no use\n                bValid = false;\n            } else {\n                if (this.node.nodeType != 3) {\n                    if (this.node.nodeType == 1 && this.specialCase) {\n                        // is valid\n                    } else {\n                        bValid = false;\n                    }\n                } else if (this.offset < 0 || this.offset > this.node.nodeValue.length) {\n                    bValid = false;\n                }\n            }\n            return bValid;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            var txt = \"TH\" + \"Caret \"; //split due to obfuscator logic  (If didn't split it wouldnt obfuscate THCaret)\n            if (this.node != null) {\n                if (this.node.nodeType == 3) {\n                    txt += this.node.nodeValue + \" \" + this.node.parentNode.tagName + \" \";\n                } else if (this.node.nodeType == 1) {\n                    txt += this.node.tagName + \" \";\n                }\n            }\n            txt += this.offset;\n            return txt;\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(p_caret) {\n            if (p_caret == null) {\n                return false;\n            }\n\n            return this.node == p_caret.node && this.offset == p_caret.offset && this.forwardBias == p_caret.forwardBias;\n        }\n    }, {\n        key: \"clone\",\n        value: function clone() {\n            return new THCaret(this.node, this.offset, this.forwardBias);\n        }\n    }]);\n\n    return THCaret;\n}();\n\n},{}],28:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.THCaretRange = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevin on 01/04/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\n\nvar _THCaret = require('src/SpeechStream/THCaret');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _DomNavigation = require('src/SpeechStream/DOM/DomNavigation');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar THCaretRange = exports.THCaretRange = function () {\n    function THCaretRange(p_theBody, p_strPathLeft, p_nPosLeft, p_strPathRight, p_nPosRight) {\n        _classCallCheck(this, THCaretRange);\n\n        this.leftCaret = null;\n        this.rightCaret = null;\n\n        if (p_theBody != null && p_strPathLeft != null && p_nPosLeft != null && p_strPathRight != null && p_nPosRight != null) {\n            this.getCaretPairFromDomPosition(p_theBody, p_strPathLeft, p_nPosLeft, p_strPathRight, p_nPosRight);\n        }\n    }\n\n    _createClass(THCaretRange, [{\n        key: 'setCaretRange',\n        value: function setCaretRange(left, right) {\n            this.leftCaret = left;\n            this.rightCaret = right;\n        }\n    }, {\n        key: 'equals',\n        value: function equals(p_caretRange) {\n            if (p_caretRange == null) {\n                return false;\n            }\n\n            return this.leftCaret.equals(p_caretRange.leftCaret) && this.rightCaret.equals(p_caretRange.rightCaret);\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return this.getTextOverCaretRange();\n        }\n\n        /*\n         Use this to get the text given a caret range.  This gets the exact text not taking substitutions for speech.\n         Will only include content of text nodes and elements that are images with msg.\n         */\n\n    }, {\n        key: 'getTextOverCaretRange',\n        value: function getTextOverCaretRange() {\n            // iterate over range to get text\n            var ssdom = new _SSDOM.SSDOM();\n            try {\n                if (this.leftCaret == null || this.rightCaret == null) {\n                    return \"\";\n                }\n\n                var leftCaret = this.leftCaret;\n                var rightCaret = this.rightCaret;\n\n                var leftNode = leftCaret.node;\n                var rightNode = rightCaret.node;\n\n                var tmpTxt;\n                var strResult = \"\";\n                var elemList = ssdom.getNodesOverRange(leftNode, rightNode);\n\n                if (elemList != null && elemList.length > 0) {\n                    for (var i = 0; i < elemList.length; i++) {\n                        var elem = elemList[i];\n                        if (elem.nodeType == 3 && elem.parentNode.tagName.toLowerCase() != \"textarea\") {\n                            tmpTxt = elem.nodeValue;\n                            if (rightNode == leftNode) {\n                                strResult += tmpTxt.substring(leftCaret.offset, rightCaret.offset);\n                            } else if (elem == leftNode && leftCaret.offset > 0) {\n                                strResult += tmpTxt.substr(leftCaret.offset);\n                            } else if (elem == rightNode && rightCaret.offset > -1) {\n                                strResult += tmpTxt.substring(0, rightCaret.offset);\n                            } else {\n                                strResult += tmpTxt;\n                            }\n                            //                        strResult += tmpTxt;\n                        } else if (elem.nodeType == 1) {\n                            if (elem.tagName.toLowerCase() == \"img\" && rw_getAttribute(elem, \"msg\")) {\n                                strResult = rw_getAttribute(elem, \"msg\");\n                            }\n                        }\n                    }\n                }\n\n                return strResult.trimTH();\n            } catch (err) {\n                // console.log(\"Error getTextOverCaretRange: \" + err.message);\n                return \"\";\n            }\n        }\n    }, {\n        key: 'rw_getTHRangeFromTHCaretRange',\n\n        /*\n         Convert THCaretRange to THRange\n         */\n        value: function rw_getTHRangeFromTHCaretRange() {\n            if (this == null || this.leftCaret == null || this.rightCaret == null) {\n                //\"Error converting THCaretRange to THRange\";\n                return null;\n            }\n\n            return new THRange(this.leftCaret.node.ownerDocument.body, this.rw_getRefPt(this.leftCaret.node, this.leftCaret.offset), this.rw_getRefPt(this.rightCaret.node, this.rightCaret.offset));\n        }\n\n        /*\n         Function to get left and right caret points for a range.\n         Use this to check for the case were the left and right point are the same\n         as otherwise will get the right caret before the left due to the forward bias\n         (e.g. <b>ab</b>cd  if point is to after b, with forward bias will get point\n         before the c and without forward bias will get after the b.  Same logically in text order\n         but as in different nodes and the second before the first this cases problems.)\n         With this function know that the two carets are linked so can ensure that the second\n         is not before the first.\n         */\n\n    }, {\n        key: 'getCaretPairFromDomPosition',\n        value: function getCaretPairFromDomPosition(p_theBody, p_strPathLeft, p_nPosLeft, p_strPathRight, p_nPosRight) {\n            var ssdom = new _SSDOM.SSDOM();\n            this.leftCaret = ssdom.getCaretFromDomPosition(p_theBody, p_strPathLeft, p_nPosLeft, true);\n\n            var rightCaret;\n            if (p_strPathLeft == p_strPathRight && p_nPosLeft >= p_nPosRight) {\n                // Also catch case of right pos being less that left pos in same node.  Should not happen but\n                // if that occurs is a bug but this should prevent worst effects of it if it occurs.\n                // If right path gives node before left node will still bug but too much to check every time in this high use method.\n                this.rightCaret = this.leftCaret;\n            } else {\n                this.rightCaret = ssdom.getCaretFromDomPosition(p_theBody, p_strPathRight, p_nPosRight, false);\n            }\n        }\n\n        // diff between this and getTextOverCaretRange is that this looks to the special elements, to see what is actually\n        // to be said looking to acronym substitution etc.\n        // NB even if find this has no usages, is used for test page, so do not remove!\n        /* Use this to get the text given a caret range.  This gets the text to be read out.\n         If starts in element rather than text node, will move to next text node without adding any text.\n         Unless img with msg.\n         */\n\n    }, {\n        key: 'getTextSpokenOverCaretRange',\n        value: function getTextSpokenOverCaretRange(p_thCaretRange) {\n            // iterate over range to get text\n            var domNav = new _DomNavigation.DomNavigation();\n            var ssdom = new _SSDOM.SSDOM();\n\n            try {\n                if (p_thCaretRange == null || p_thCaretRange.leftCaret == null || p_thCaretRange.rightCaret == null) {\n                    return \"\";\n                }\n\n                var leftCaret = p_thCaretRange.leftCaret;\n                var rightCaret = p_thCaretRange.rightCaret;\n\n                var leftNode = leftCaret.node;\n                var rightNode = rightCaret.node;\n\n                var bSpecial = ssdom.isSpecialCaseNested(leftNode);\n                if (bSpecial) {\n                    // starts inside special case.  Check to ensure is not nested too deep.\n                    leftNode = ssdom.checkForSpecialParent(leftNode);\n                    leftCaret = new _THCaret.THCaret(leftNode, 0, true);\n                }\n                var curNode = leftNode;\n                var txt = \"\";\n                while (curNode != null) {\n                    bSpecial = ssdom.isSpecialCase(curNode);\n                    if (bSpecial || curNode.nodeType == 3) {\n                        var tmp = domNav.getTextFromNode(curNode);\n\n                        if (tmp != null && tmp != \"\") {\n                            if (!bSpecial) {\n                                if (curNode == rightNode && rightCaret.offset > -1) {\n                                    tmp = tmp.substring(0, rightCaret.offset);\n                                }\n                                if (curNode == leftNode && leftCaret.offset > -1) {\n                                    tmp = tmp.substring(leftCaret.offset);\n                                }\n                            }\n\n                            txt += tmp;\n                        }\n                    }\n                    if (bSpecial) {\n                        curNode = domNav.getNextNodeIgnoreChildren(curNode, false, rightNode);\n                    } else {\n                        curNode = domNav.getNextNode(curNode, false, rightNode);\n                    }\n                }\n                return txt.trimTH();\n            } catch (err) {\n                // thLog(\"Error getTextOverCaretRange: \" + err.message);\n                return \"\";\n            }\n        }\n\n        //    /*This uses a position in the dom to get the text node referred to.\n        //     The offset is used to handle case were the target node has been split and\n        //     the target word is not in the first part.  Set to p_nPos to 0 to always get the\n        //     first text node regardless of split.  Set p_nPos to -1 to get the target node\n        //     even if it is now an element and not a text node.\n        //     <p>\n        //     NB count multiple text nodes together as single item.  Text could be split\n        //     since the count made.  Also to match this when counting take adjacent text nodes as one.\n        //     <p>\n        //     For special case, directs to element node not text node, here need to take either start or end of contained text based on p_bForwardBias\n        //     <p>\n        //     p_theBody to body containing the node that path is referenced from\n        //     p_strPath the path from the body\n        //     p_nPos the offset\n        //     p_bForwardBias set true if caret is to refer to character after itself, false if is to refer to character before it\n        //     <p> Returns THCaret object containing the node and offset.\n        //     */\n        //    getCaretFromDomPosition (p_theBody, p_strPath, p_nPos, p_bForwardBias, p_bForceSpecial)\n        //    {\n        //        var ssdom = new SSDOM();\n        //        var domNav = new DomNavigation();\n        //        if(typeof(p_bForceSpecial) == \"undefined\")\n        //        {\n        //            p_bForceSpecial = false;\n        //        }\n        //\n        //        try\n        //        {\n        //            if(p_theBody == null)\n        //            {\n        //                return null;\n        //            }\n        //            // Get the node from the position string\n        //            var theNode = this.getNodeFromPosition(p_theBody, p_strPath);\n        //\n        //            // First check if it is a special case\n        //\n        //            if(p_bForceSpecial)\n        //            {\n        //                var tmpCaret = new THCaret(theNode, 0, p_bForwardBias);\n        //                tmpCaret.setSpecialCase(true);\n        //                return tmpCaret;\n        //            }\n        //\n        //            var tmpNode = ssdom.checkForSpecialParent(theNode);\n        //\n        //            if(tmpNode != null)\n        //            {\n        //                theNode = tmpNode;\n        //\n        //                //if not a highlightable one should just return the item\n        //                if(ssdom.isSpecialCaseHighlightable(tmpNode))\n        //                {\n        //                    if(p_bForwardBias)\n        //                    {   // get start\n        //                        var startNode = domNav.getFirstChildTextNode(theNode, false);\n        //                        if(startNode != null)\n        //                        {\n        //                            return new THCaret(startNode, 0, p_bForwardBias);\n        //                        }\n        //                        else\n        //                        {\n        //                            // treat as non highlightable\n        //                            return new THCaret(theNode, 0, p_bForwardBias);\n        //                        }\n        //                    }\n        //                    else\n        //                    {   //get end\n        //                        var endNode = domNav.getLastChildTextNode(theNode, false);\n        //                        if(endNode != null)\n        //                        {\n        //                            if(endNode.nodeType == 3)\n        //                            {\n        //                                return new THCaret(endNode, endNode.length, p_bForwardBias);\n        //                            }\n        //                            else\n        //                            {   // is img with msg, not highlightable\n        //                                return new THCaret(endNode, 0, p_bForwardBias);\n        //                            }\n        //                        }\n        //                        else\n        //                        {   // treat as non highlightable\n        //                            return new THCaret(theNode, 0, p_bForwardBias);\n        //                        }\n        //                    }\n        //                }\n        //                else\n        //                {\n        //                    return new THCaret(tmpNode, 0, p_bForwardBias);\n        //                }\n        //            }\n        //\n        //\n        //            var nOffset = 0;\n        //            if(!p_bForwardBias)\n        //            {   // Looking for caret position just before the p_nPos point so need to be comparing to +1 position\n        //                ++nOffset;\n        //            }\n        //\n        //            if(p_nPos > -1)\n        //            {\n        //                // found node, but may have been subsequently split, so need to check passed position\n        //                // is inside it\n        //                // Ensure doesnt go past parent\n        //                if(theNode == null)\n        //                {   //error\n        //                    return null;\n        //                }\n        //                var bMatch = false;\n        //\n        //                var endNode = theNode.parentNode;\n        //                var lastSafeNode = theNode;\n        //                var tmpTxt;\n        //\n        //                while(!bMatch)\n        //                {\n        //                    if(theNode.nodeType == 3)\n        //                    {\n        //                        tmpTxt = theNode.nodeValue;\n        //                        //console.log(\"check if in \" + theNode.nodeValue + \"  where offset is \" + nOffset + \" and pos \" + p_nPos);\n        //                        if(p_nPos < (nOffset + tmpTxt.length))\n        //                        { // found\n        //                            //console.log(\"yes\");\n        //                            bMatch = true;\n        //                            break;\n        //                        }\n        //\n        //                        lastSafeNode = theNode;\n        //                        nOffset += theNode.nodeValue.length;\n        //\n        //                        theNode = domNav.getNextNode(theNode, false, endNode);\n        //                    }\n        //                    else if(theNode.nodeType == 1)\n        //                    {   // check if special case of node, i.e. element that can be spoken (img with msg)\n        //                        tmpNode = ssdom.checkForSpecialParent(theNode);\n        //                        if(tmpNode != null)\n        //                        {\n        //                            theNode = tmpNode;\n        //                            // might have found target\n        //                            // ensure that the offset should not take it on past this\n        //                            // if p_nPos matches nOffset then match\n        //                            var nDiff = p_nPos - nOffset;\n        //\n        //                            if(nDiff > 0)\n        //                            {\n        //                                // need to carry on\n        //                                nOffset += 1;\n        //                            }\n        //                            else\n        //                            {\n        //                                bMatch = true;\n        //                                break;\n        //                            }\n        //\n        //                            // ignore children so do not include text of special node and also include the +1 here\n        //                            theNode = domNav.getNextNodeIgnoreChildren(theNode, false, endNode);\n        //                        }\n        //                        else\n        //                        {\n        //                            theNode = domNav.getNextNode(theNode, false, endNode);\n        //                        }\n        //                    }\n        //\n        //                    //console.log(theNode + \" \" + theNode.tagName + \" \" + theNode.nodeValue);\n        //                    if(theNode == null || theNode == endNode)\n        //                    {            // alert(\" \" + p_strPath + \" <=> \" + p_nPos);\n        //                        //shouldnt really happen, but dont always have valid data so this catches the dodgy case\n        //                        // can happen due to offset calculation being wrong, some elements can give unexpected offset,\n        //                        // as do not know exactly how the different browsers work it out for themselves.\n        //                        //In this case use last safe offset, most likely work or at least highlight most of word\n        //                        if(lastSafeNode != null)\n        //                        {\n        //                            theNode = lastSafeNode;\n        //                            if(theNode.nodeType == 3)\n        //                            {\n        //                                // The value of nOffset set below is purely done to cancel out in\n        //                                // calculation further down for new THCaret\n        //                                nOffset = p_nPos - theNode.nodeValue.length;\n        //\n        //                            }\n        //                            else\n        //                            {   // such as img\n        //                                nOffset = 0;\n        //                            }\n        //\n        //                            if(!p_bForwardBias)\n        //                            {\n        //                                ++nOffset;\n        //                            }\n        //                            break;\n        //                        }\n        //                        else\n        //                        {\n        //                            return null;\n        //                        }\n        //                    }\n        //                }\n        //\n        //                //console.log(\"theNode \" + theNode + \"   \" + theNode.nodeValue + \"  from \" + p_strPath);\n        //                if(p_bForwardBias)\n        //                {\n        //                    return new THCaret(theNode, p_nPos - nOffset, p_bForwardBias);\n        //                }\n        //                else\n        //                {   // remember to remove the extra part added on to stop going to next node.\n        //                    return new THCaret(theNode, p_nPos - (nOffset - 1), p_bForwardBias);\n        //                }\n        //            }\n        //            else\n        //            {\n        //                return new THCaret(theNode, p_nPos, p_bForwardBias);\n        //            }\n        //        }\n        //        catch(err)\n        //        {   // Likely that path is no longer valid\n        //            console.log(\"getCaretFromDomPosition error: \" + err);\n        //\n        //            return null;\n        //        }\n        //    }\n        //\n        //\n        //\n        //    /*Used by getCaretFromDomPosition\n        //     returns a node or null if error occurs*/\n        //    getNodeFromPosition (p_theBody, p_strPath)\n        //    {\n        //        var ssdom  = new SSDOM();\n        //        var attribute  = new Attribute();\n        //        var theNode = p_theBody;\n        //\n        //        // logic to remove chunk part of path\n        //        if(p_strPath.lastIndexOf(\"*\") > -1)\n        //        {\n        //            var nPos = p_strPath.lastIndexOf(\"*\");\n        //            p_strPath = p_strPath.substring(nPos + 1);\n        //        }\n        //\n        //        // parse offset values and iterate end to start,\n        //        //moving set number of nodes to right before going to next level\n        //        var aStr = p_strPath.split(\"~\");\n        //        var nLen = aStr.length;\n        //        var i;\n        //\n        //        for(i = nLen - 2; i > -1; i--)\n        //        {\n        //            theNode = theNode.firstChild;\n        //            if(theNode == null)\n        //            {   //error\n        //                return null;\n        //            }\n        //            var nVal;\n        //            if(aStr[i].length == 0)\n        //            {\n        //                nVal = 0;\n        //            }\n        //            else\n        //            {\n        //                nVal = parseInt(aStr[i], 10);\n        //            }\n        //\n        //            // To check for multiple text nodes together\n        //\n        //            var bIsText = false;\n        //            var bWasLastText = (theNode.nodeType == 3) ||\n        //                (theNode.nodeType == 1 &&\n        //                    theNode.tagName.toLowerCase() == \"span\" &&\n        //                    attribute.rw_getAttribute(theNode, \"rwstate\") != null);\n        //\n        //            while(nVal > 0)\n        //            {   // need to move right\n        //                theNode = theNode.nextSibling;\n        //\n        //                if(theNode == null)\n        //                {\n        //                    return null;\n        //                }\n        //\n        //                bIsText = (theNode.nodeType == 3) ||\n        //                    (theNode.nodeType == 1 &&\n        //                        theNode.tagName.toLowerCase() == \"span\" /*SSDAT.pageData.strHighlightTag*/ &&\n        //                        attribute.rw_getAttribute(theNode, \"rwstate\") != null);\n        //                if(bIsText && bWasLastText)\n        //                {\n        //                    // text together keep moving\n        //                    // leave bWasLastText as is\n        //                }\n        //                else\n        //                {\n        //                    --nVal;\n        //                    bWasLastText = bIsText;\n        //                }\n        //\n        //                // for all non text will decrease nVal\n        //                // for non text to non text will leave bWasLastText false\n        //                // for non text to text will set bWasLastText true\n        //\n        //                // for text to text will leave as is; and no decrease of nVal\n        //                // for text to non text will set bWasLastText to false; and decrease nVal\n        //\n        //                // doesn't care here if text is empty here, if that is a problem need to remove empty\n        //                // text in tagsentences method, as is done with pkt\n        //            }\n        //        }\n        //        return theNode;\n        //    };\n\n\n    }]);\n\n    return THCaretRange;\n}();\n\n},{\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/DomNavigation\":3,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/THCaret\":27}],29:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.THDomRange = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by kevin on 31/03/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n//*! Used by safariReader\n\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nvar _THCaret = require('src/SpeechStream/THCaret');\n\nvar _THDomRefPt = require('src/SpeechStream/THDomRefPt');\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _Attribute = require('src/SpeechStream/DOM/Attribute');\n\nvar _Constants = require('src/Constants/Constants');\n\nvar Constants = _interopRequireWildcard(_Constants);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*This holds the range in a dom in a way that will not be broken by nodes being split up.\n It holds positions by node ref and by string mapping to the node.*/\nvar THDomRange = exports.THDomRange = function () {\n    function THDomRange(p_startNode, p_nStartOffset, p_endNode, p_nEndOffset) {\n        _classCallCheck(this, THDomRange);\n\n        this.body = p_startNode.ownerDocument.body;\n        this.startCaret = new _THCaret.THCaret(p_startNode, p_nStartOffset, true);\n        this.endCaret = new _THCaret.THCaret(p_endNode, p_nEndOffset, false);\n        this.startRef = this.rw_getRefPt(p_startNode, p_nStartOffset);\n        this.endRef = this.rw_getRefPt(p_endNode, p_nEndOffset);\n    }\n\n    _createClass(THDomRange, [{\n        key: 'getPositionInDom',\n        value: function getPositionInDom(p_theNode) {\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            var strPos = \"\";\n            var nLeftCount = 0;\n            var prefix = \"\";\n            if (p_theNode != null && p_theNode.ownerDocument != null) {\n                var bWasLastText = false;\n                var bIsText = false;\n                var bod = p_theNode.ownerDocument.body;\n                while (p_theNode != null && p_theNode != bod) {\n\n                    if (ssdom.isSpecialCase(p_theNode)) {\n                        // reset path so directs straight to this\n                        strPos = \"\";\n                    }\n                    bWasLastText = p_theNode.nodeType == 3 || p_theNode.nodeType == 1 && p_theNode.tagName.toLowerCase() == Constants.HIGHLIGHT_TAG && attribute.rw_getAttribute(p_theNode, \"rwstate\") != null; // set true if text for orig.\n                    var aNode = p_theNode.previousSibling;\n                    while (aNode != null) {\n                        bIsText = aNode.nodeType == 3 || aNode.nodeType == 1 && aNode.tagName.toLowerCase() == Constants.HIGHLIGHT_TAG && attribute.rw_getAttribute(aNode, \"rwstate\") != null; // set for current node\n                        if (bWasLastText && bIsText) {// dont increment for two text nodes together\n                        } else {\n                            ++nLeftCount;\n                        }\n                        aNode = aNode.previousSibling;\n                        bWasLastText = bIsText;\n                    }\n                    strPos = strPos + nLeftCount + \"~\";\n                    nLeftCount = 0;\n                    p_theNode = p_theNode.parentNode;\n                    if (p_theNode != null && p_theNode.getAttribute != null && p_theNode.tagName != null) {\n                        var ttmp = attribute.rw_getAttribute(p_theNode, \"chunk\");\n                        if (p_theNode.tagName.toLowerCase() == \"span\" && ttmp == \"1\") {\n                            var innerPos = attribute.getPositionInDom(p_theNode);\n                            prefix = \"#^th*\" + innerPos + \"#^th*\";\n                        }\n                    }\n                }\n            }\n            return prefix + strPos;\n        }\n    }, {\n        key: 'rw_getRefPt',\n        value: function rw_getRefPt(p_node, p_nOffset) {\n            var RWTH_GENERATED = \"rwTHgen\" + \"\";\n            var ssdom = new _SSDOM.SSDOM();\n            var attribute = new _Attribute.Attribute();\n            try {\n                // if text node want ref to parent with offset to get to right point\n                // if passed element want direct ref to it and offset is irrelevant\n                if (p_node == null) {\n                    return null;\n                }\n\n                if (p_node.nodeType == 1 || p_node.nodeType == 3) {\n                    // check if text is inside special case\n\n                    var tmpPar = ssdom.checkForSpecialParent(p_node);\n                    if (tmpPar != null) {\n                        // is in special case so need to extend range to include whole item\n                        return new _THDomRefPt.THDomRefPt(this.getPositionInDom(tmpPar), p_nOffset);\n                    }\n\n                    // get offset of passed node\n                    var nOffset;\n\n                    var theParent;\n\n                    if (p_node.nodeType == 1) {\n                        nOffset = 0;\n                        theParent = p_node;\n                    } else {\n                        // causes a problem in tinymce, not sure why this is there, but been long time so risk of some\n                        // bizarre side affect here.\n                        //todo check how this affects sticky notes.\n                        //                // special check for selecting node where is in whitespace only element, might only exist on\n                        //                // firefox\n                        //                if(p_node.nodeValue.trimTH().length == 0)\n                        //                {\n                        //                   p_nOffset = 0;\n                        //                }\n\n                        nOffset = this.getNodeOffset_(p_node);\n                        theParent = p_node.parentNode;\n                    }\n\n                    var attr = attribute.rw_getAttribute(theParent, \"rwstate\");\n                    var thgenAttr = attribute.rw_getAttribute(theParent, RWTH_GENERATED);\n                    while (attr != null && attr.length > 0 || thgenAttr != null) {\n                        // It is a rwonline added element move up again ( ss sp or csp)\n                        // or is autogenerate span tag for split text node\n                        // or if font element as this added by IE for highlighting\n                        nOffset += this.getNodeOffset_(theParent);\n                        theParent = theParent.parentNode;\n                        attr = attribute.rw_getAttribute(theParent, \"rwstate\");\n                        thgenAttr = attribute.rw_getAttribute(theParent, RWTH_GENERATED);\n                    }\n                    if (p_nOffset == -1) {\n                        // case of text node in a special case (abbr)\n                        nOffset = -1;\n                    }\n                    return new _THDomRefPt.THDomRefPt(this.getPositionInDom(theParent), nOffset + p_nOffset);\n                } else {\n                    return null;\n                }\n            } catch (ignore) {\n                // likely invalid node passed giving null parent\n                return null;\n            }\n        }\n\n        // Get the text offset of the node from all text contained by the parent.\n\n    }, {\n        key: 'getNodeOffset_',\n        value: function getNodeOffset_(p_node) {\n            var ssdom = new _SSDOM.SSDOM();\n            if (p_node == null) {\n                return 0;\n            }\n            var nOffset = 0;\n            var leftNode = p_node.previousSibling;\n            if (leftNode != null) {\n                nOffset = ssdom.rw_getNodeOffsetImpl(leftNode);\n            }\n            return nOffset;\n        }\n\n        /*This checks that the nodes are valid and if not updates them*/\n\n    }, {\n        key: 'refresh',\n        value: function refresh() {\n            if (this.startCaret.check() == false || this.endCaret.check() == false) {\n                // need to recalculate the nodes\n\n                var caretRange = new _THCaretRange.THCaretRange(this.body, this.startRef.path, this.startRef.offset, this.endRef.path, this.endRef.offset);\n                this.startCaret = caretRange.leftCaret;\n                this.endCaret = caretRange.rightCaret;\n\n                // could be null which will cause crash, best recovery is to just set to an enpty selection to avoid crashing\n                if (this.startCaret == null && this.endCaret == null) {\n                    this.startCaret = new _THCaret.THCaret(document.body, 0, true);\n                    this.endCaret = new _THCaret.THCaret(document.body, 0, false);\n                } else if (this.startCaret == null || this.endCaret == null) {\n                    if (this.startCaret == null) {\n                        // end valid, start failed, collapse to end\n                        this.startCaret = new _THCaret.THCaret(this.endCaret.node, this.endCaret.offset, true);\n                    } else {\n                        // start valid, end failed, collapse to start\n                        this.endCaret = new _THCaret.THCaret(this.startCaret.node, this.startCaret.offset, false);\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'toString',\n\n\n        // gets the text of the object\n        value: function toString() {\n            var ssdom = new _SSDOM.SSDOM();\n\n            this.refresh();\n\n            var thCaretRange = new _THCaretRange.THCaretRange();\n            thCaretRange.setCaretRange(this.startCaret, this.endCaret);\n            return thCaretRange.getTextSpokenOverCaretRange(thCaretRange);\n        }\n    }, {\n        key: 'getRangeObject',\n\n\n        // get range or textrange\n        value: function getRangeObject(p_body) {\n            if (typeof p_body == 'undefined' || p_body == null) {\n                p_body = document.body;\n            }\n\n            var doc = p_body.ownerDocument;\n            return doc.createRange();\n        }\n\n        // Get a range object refering to the start point of this\n\n    }, {\n        key: 'getStartAsRange',\n        value: function getStartAsRange() {\n            var range = this.getRangeObject(this.body);\n            range.setStart(this.startCaret.node, this.startCaret.offset);\n            range.setEnd(this.startCaret.node, this.startCaret.offset);\n            return range;\n        }\n    }, {\n        key: 'getEndAsRange',\n\n\n        // Get a range object refering to the end point of this\n        value: function getEndAsRange() {\n            var range = this.getRangeObject(this.body);\n            range.setStart(this.endCaret.node, this.endCaret.offset);\n            range.setEnd(this.endCaret.node, this.endCaret.offset);\n            return range;\n        }\n    }, {\n        key: 'equals',\n\n\n        /*Compares start and end points*/\n        value: function equals(p_target) {\n            return this.startRef.path == p_target.startRef.path && this.startRef.offset == p_target.startRef.offset && this.endRef.path == p_target.endRef.path && this.endRef.offset == p_target.endRef.offset;\n        }\n    }, {\n        key: 'compareRange',\n\n\n        /*This compares range with other THDomRange.*/\n        value: function compareRange(p_target) {\n            if (this.equals(p_target)) {\n                return Constants.THDomRange_TARGET_SAME;\n            }\n\n            this.refresh();\n            p_target.refresh();\n\n            var selectedStart = this.getStartAsRange();\n            var selectedEnd = this.getEndAsRange();\n\n            var targetStart = p_target.getStartAsRange();\n            var targetEnd = p_target.getEndAsRange();\n\n            //var nRes = rw_whichNodeFirst(tmp.startNode, tmp.endNode);\n            var nStartDiff1 = selectedStart.compareBoundaryPoints(\"START_TO_START\", targetStart);\n            var nStartDiff2 = selectedStart.compareBoundaryPoints(\"START_TO_START\", targetEnd);\n            var nEndDiff1 = selectedEnd.compareBoundaryPoints(\"START_TO_START\", targetStart);\n            var nEndDiff2 = selectedEnd.compareBoundaryPoints(\"START_TO_START\", targetEnd);\n\n            var nResult = Constants.THDomRange_ERROR;\n\n            // cover two special cases first that are most common results then do start diff -> end diff combinations\n            if (nStartDiff2 > -1) {\n                // Target ends before this starts\n                nResult = Constants.THDomRange_AFTER_TARGET;\n            } else if (nEndDiff1 < 1) {\n                // Target starts after this ends\n                nResult = Constants.THDomRange_BEFORE_TARGET;\n            } else if (nStartDiff1 == -1) {\n                // starts before target\n                // nEndDiff1 < 1 done already\n\n                if (nEndDiff2 == -1) {\n                    // overlaps start of target\n                    nResult = Constants.THDomRange_OVERLAPS_START_OF_TARGET;\n                } else // if(nEndDiff2 > -1)\n                    {\n                        // includes target fully\n                        nResult = Constants.THDomRange_TARGET_INSIDE;\n                    }\n            } else if (nStartDiff1 == 0) {\n                // start at target start\n                if (nEndDiff2 == -1) {\n                    // this is entirely inside target with starts at same point\n                    nResult = Constants.THDomRange_TARGET_INCLUDES_THIS_AT_START;\n                } else if (nEndDiff2 == 0) {\n                    // is exact match\n                    nResult = Constants.THDomRange_TARGET_SAME;\n                } else //nEndDiff2 == 1\n                    {\n                        // same start, selection goes beyond target\n                        nResult = Constants.THDomRange_TARGET_INSIDE;\n                    }\n            } else // if(nStartDiff1 == 1)\n                {\n                    // starts after start of target\n                    if (nEndDiff2 == -1) {\n                        // this is entirely inside target (no matching boundaries)\n                        nResult = Constants.THDomRange_TARGET_INCLUDES_THIS;\n                    } else if (nEndDiff2 == 0) {\n                        // this is entirely inside target with ends at same point\n                        nResult = Constants.THDomRange_TARGET_INCLUDES_THIS_AT_END;\n                    } else //nEndDiff2 == 1\n                        {\n                            // overlaps end of target\n                            nResult = Constants.THDomRange_OVERLAPS_END_OF_TARGET;\n                        }\n                }\n\n            return nResult;\n        }\n\n        /// move to sep file\n        //\n        // Functions for range for each browser\n        //\n\n    }, {\n        key: 'rw_getTextFromRange',\n        value: function rw_getTextFromRange() {\n            var txt = \"\";\n\n            if (this.text) {\n                //IE\n                txt = this.text;\n            } else {\n                // safari //FireFox\n                txt = this.toString();\n            }\n            return txt;\n        }\n    }, {\n        key: 'rw_getTHCaretRangeFromTHDomRange',\n        value: function rw_getTHCaretRangeFromTHDomRange() {\n            var ssdom = new _SSDOM.SSDOM();\n            if (this.startRef == null || this.endRef == null) {\n                return null;\n            } else {\n                var leftCaret = ssdom.getCaretFromDomPosition(this.body, this.startRef.path, this.startRef.offset, true);\n                var rightCaret = ssdom.getCaretFromDomPosition(this.body, this.endRef.path, this.endRef.offset, false);\n\n                if (leftCaret != null && rightCaret != null) {\n                    var range = new _THCaretRange.THCaretRange();\n                    range.setCaretRange(leftCaret, rightCaret);\n                    return range;\n                } else {\n                    return null;\n                }\n            }\n        }\n    }]);\n\n    return THDomRange;\n}();\n\n},{\"src/Constants/Constants\":1,\"src/SpeechStream/DOM/Attribute\":2,\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/THCaret\":27,\"src/SpeechStream/THCaretRange\":28,\"src/SpeechStream/THDomRefPt\":30}],30:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevin on 31/03/16.\n */\n//*! Used by safariReader\n\n\n//Reference to a point in the dom that is not lost by text node splitting.\n// This can be used for longer term storage of a position.\nvar THDomRefPt = exports.THDomRefPt = function () {\n    function THDomRefPt(p_strPath, p_nOffset) {\n        _classCallCheck(this, THDomRefPt);\n\n        // the path is the path as obtained by getPositionInDomTH() and gives path from the body to the node.\n        this.path = p_strPath;\n        this.offset = p_nOffset;\n    }\n\n    _createClass(THDomRefPt, [{\n        key: \"toString\",\n        value: function toString() {\n            return \"THDomRefPt \" + this.path + \" \" + this.offset;\n        }\n    }, {\n        key: \"getPath\",\n        value: function getPath() {\n            return this.path;\n        }\n    }, {\n        key: \"getOffset\",\n        value: function getOffset() {\n            return this.getOffset;\n        }\n    }]);\n\n    return THDomRefPt;\n}();\n\n//!*\n\n},{}],31:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.THRange = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Created by kevin on 05/04/16.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n//*! Used by safariReader\n\n\nvar _SSDOM = require('src/SpeechStream/DOM/SSDOM');\n\nvar _THCaretRange = require('src/SpeechStream/THCaretRange');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// alt to THDomRange , might replace if works out\n// p_body   refers to body node paths are from, for frame pages.\n// p_refPtLeft   THDomRefPt\n// p_refPtRight   THDomRefPt\nvar THRange = exports.THRange = function () {\n    function THRange(p_body, p_startRefPt, p_endRefPt) {\n        _classCallCheck(this, THRange);\n\n        this.body = p_body;\n        this.startRef = p_startRefPt;\n        this.endRef = p_endRefPt;\n    }\n\n    /*Compares start and end points*/\n\n\n    _createClass(THRange, [{\n        key: 'equals',\n        value: function equals(p_target) {\n            return this.body == p_target.body && this.startRef.path == p_target.startRef.path && this.startRef.offset == p_target.startRef.offset && this.endRef.path == p_target.endRef.path && this.endRef.offset == p_target.endRef.offset;\n        }\n\n        // Get the text for the range as determined by the browser using range object.\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var range = this.getAsRange();\n            if (range != null) {\n                if (g_bIEOld) {\n                    return this.getAsRange().text;\n                } else {\n                    return this.getAsRange().toString();\n                }\n            } else {\n                return \"\";\n            }\n        }\n\n        // This is TextRange for IE and Range for SFF\n\n    }, {\n        key: 'getAsRange',\n        value: function getAsRange() {\n            var range = null;\n            if (g_bIEOld) {\n                range = rw_getAsTextRange(this.body, this.startRef.path, this.startRef.offset, this.endRef.path, this.endRef.offset);\n            } else {\n                range = _SSDOM.SSDOM.getRangeObject(this.body);\n\n                var caretRange = new new _THCaretRange.THCaretRange(this.body, this.startRef.path, this.startRef.offset, this.endRef.path, this.endRef.offset)();\n                var startCaret = caretRange.leftCaret;\n                var endCaret = caretRange.rightCaret;\n\n                if (startCaret != null && endCaret != null) {\n                    range.setStart(startCaret.node, startCaret.offset);\n                    range.setEnd(endCaret.node, endCaret.offset);\n                } else {\n                    range = null;\n                    // console.log(\"Error in THRange:getAsRange: Failed to get the start or end caret.\");\n                }\n            }\n            return range;\n        }\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return new THRange(this.body, this.startRef, this.endRef);\n        }\n    }, {\n        key: 'rw_getTHCaretRangeFromTHRange',\n        value: function rw_getTHCaretRangeFromTHRange() {\n            var ssdom = new _SSDOM.SSDOM();\n            if (this.startRef == null || this.endRef == null) {\n                return null;\n            } else {\n                var leftCaret = ssdom.getCaretFromDomPosition(this.body, this.startRef.path, this.startRef.offset, true);\n                var rightCaret = ssdom.getCaretFromDomPosition(this.body, this.endRef.path, this.endRef.offset, false);\n\n                if (leftCaret != null && rightCaret != null) {\n                    var range = new _THCaretRange.THCaretRange();\n                    range.setCaretRange(leftCaret, rightCaret);\n                    return range;\n                } else {\n                    return null;\n                }\n            }\n        }\n    }]);\n\n    return THRange;\n}();\n\n//!*\n\n},{\"src/SpeechStream/DOM/SSDOM\":5,\"src/SpeechStream/THCaretRange\":28}],32:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevin on 04/04/16.\n */\n\nvar THReturnObject = exports.THReturnObject = function THReturnObject() {\n    _classCallCheck(this, THReturnObject);\n\n    this.node = null;\n    this.offset = 0;\n};\n\n},{}],33:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TextOverRangeBeanClass = undefined;\n\nvar _SSDOM = require(\"src/SpeechStream/DOM/SSDOM\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /**\n                                                                                                                                                           * Created by kevin on 06/04/16.\n                                                                                                                                                           */\n\n\nvar TextOverRangeBeanClass = exports.TextOverRangeBeanClass = function TextOverRangeBeanClass(p_sentenceObject) {\n    _classCallCheck(this, TextOverRangeBeanClass);\n\n    var tmp = p_sentenceObject.getCaretRange();\n    var ssdom = new _SSDOM.SSDOM();\n    // start data\n    this.sentenceObject = p_sentenceObject;\n    this.leftNode = tmp.leftCaret.node;\n    this.rightNode = tmp.rightCaret.node;\n    this.body = ssdom.getBody(this.leftNode);\n    this.leftOffset = tmp.leftCaret.offset;\n    this.rightOffset = tmp.rightCaret.offset;\n\n    // varying data\n    this.currentNode = this.leftNode;\n    this.storedText = \"\";\n    this.startRefPt = null;\n    this.endRefPt = null;\n\n    // Some convenience methods?\n};\n\n},{\"src/SpeechStream/DOM/SSDOM\":5}],34:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Created by kevin on 01/04/16.\n */\n\nString.prototype.trimTH = function () {\n    return this.replace(/^[\\s\\xA0]+/, \"\").replace(/[\\s\\xA0]+$/, \"\");\n};\n\nvar Utilities = exports.Utilities = function () {\n    function Utilities() {\n        _classCallCheck(this, Utilities);\n    }\n\n    _createClass(Utilities, [{\n        key: \"trim\",\n        value: function trim(string) {\n            return string.replace(/^[\\s\\xA0]+/, \"\").replace(/[\\s\\xA0]+$/, \"\");\n        }\n    }, {\n        key: \"trimEndTH\",\n        value: function trimEndTH(string) {\n            return string.replace(/[\\s\\xA0]+$/, \"\");\n        }\n    }, {\n        key: \"rw_filterForHtml\",\n        value: function rw_filterForHtml(p_strText) {\n            var strOut = p_strText.replace(/\\x26/g, '&amp;');\n            strOut = strOut.replace(/\\x3c/g, '&lt;');\n            strOut = strOut.replace(/\\x3e/g, '&gt;');\n\n            return strOut;\n        }\n    }]);\n\n    return Utilities;\n}();\n\n},{}],35:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ParserAPI = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _SelectionController = require('src/SpeechStream/Selection/SelectionController');\n\nvar _SpeechHighlightManager = require('src/SpeechStream/Highlighting/SpeechHighlightManager');\n\nvar _SpeechObject = require('src/SpeechStream/SpeechObject');\n\nvar _HoverSpeak = require('src/SpeechStream/Selection/HoverSpeak');\n\nvar _StudySkillsHighlighting = require('src/SpeechStream/Highlighting/StudySkillsHighlighting');\n\nvar _Prediction = require('src/SpeechStream/Prediction/Prediction');\n\nvar _EventBus = require('src/SpeechStream/Events/EventBus');\n\nvar _THDomRange = require('src/SpeechStream/THDomRange');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// import {BabelPolyfill} from 'src/plugins/BabelPolyfill'\n\n\nvar ParserAPI = exports.ParserAPI = function () {\n    function ParserAPI(loadLoadFiles, url) {\n        _classCallCheck(this, ParserAPI);\n\n        this.selectionController = new _SelectionController.SelectionController();\n        this.speechHighlightManager = null;\n        this.hoverSpeak = new _HoverSpeak.HoverSpeak();\n        this.speechObject = new _SpeechObject.SpeechObject();\n        this.studySkills = new _StudySkillsHighlighting.StudySkillsHighlighting();\n        this.hoverSpeakOn = false;\n        this.mathLoaded = false;\n        this.url = url;\n        if (typeof MathJax != \"undefined\") {\n            MathJax.Ajax.Load(url + \"toMathML.js\");\n            this.load_script(url + \"sre_browser.js\");\n            this.mathLoaded = true;\n        }\n        this.predictionOn = false;\n        this.prediction = new _Prediction.Prediction();\n        var event = new _EventBus.EventBus();\n        event.subscribe(\"pauseHover\", this.pauseHover.bind(this));\n        this.isHoverSpeakEnabled = false;\n    }\n\n    _createClass(ParserAPI, [{\n        key: 'setUpiframes',\n        value: function setUpiframes() {\n            if (window.frames.length > 0) {\n                for (var i = 0; i < window.frames.length; i++) {\n                    try {\n                        window.frames[i].document.body.addEventListener(\"mouseover\", this.iframeCallback.bind(this));\n                    } catch (e) {}\n                }\n            }\n        }\n    }, {\n        key: 'iframeCallback',\n        value: function iframeCallback(event) {\n\n            if (this.hoverSpeakOn && this.speechCallback) {\n                this.hoverSpeak.mouseMoved(event, this.speechCallback);\n            }\n        }\n    }, {\n        key: 'forceLoadMath',\n        value: function forceLoadMath() {\n            if (!this.mathLoaded) {\n                if (typeof MathJax != \"undefined\") {\n                    MathJax.Ajax.Load(this.url + \"toMathML.js\");\n                    this.load_script(this.url + \"sre_browser.js\");\n                    this.mathLoaded = true;\n                }\n            }\n        }\n    }, {\n        key: 'pauseHover',\n        value: function pauseHover() {\n            var _this = this;\n\n            if (this.hoverSpeakOn || this.isHoverSpeakEnabled) {\n                this.hoverSpeakOn = false;\n                this.isHoverSpeakEnabled = true;\n                this.pauseHoverTimer = setTimeout(function () {\n                    return _this.unPauseHover();\n                }, 300);\n            } else {\n                this.isHoverSpeakEnabled = false;\n            }\n        }\n    }, {\n        key: 'unPauseHover',\n        value: function unPauseHover() {\n            if (this.isHoverSpeakEnabled) {\n                this.hoverSpeakOn = true;\n            }\n        }\n    }, {\n        key: 'clearHoverSpeak',\n        value: function clearHoverSpeak() {\n            this.hoverSpeak.clearHoverSpeak();\n        }\n    }, {\n        key: 'load_script',\n        value: function load_script(source) {\n            var new_script = document.createElement('script');\n            new_script.type = 'text/javascript';\n            new_script.src = source;\n            new_script.className = 'MyInjectedScript';\n            document.getElementsByTagName('head')[0].appendChild(new_script);\n        }\n    }, {\n        key: 'predictionEnabled',\n        value: function predictionEnabled(enabled) {\n            this.predictionOn = enabled;\n        }\n    }, {\n        key: 'getPredictionCoordinates',\n        value: function getPredictionCoordinates() {\n            return this.prediction.getPositionOfPopup();\n        }\n    }, {\n        key: 'getPredictionSentence',\n        value: function getPredictionSentence() {\n            return this.prediction.getSentence();\n        }\n    }, {\n        key: 'predictionInsertText',\n        value: function predictionInsertText(text) {\n            this.prediction.insertText(text);\n        }\n    }, {\n        key: 'isEditable',\n        value: function isEditable() {\n            return this.prediction.isEditable();\n        }\n    }, {\n        key: 'hoverSpeakEnabled',\n        value: function hoverSpeakEnabled(enabled) {\n            this.hoverSpeakOn = enabled;\n            this.isHoverSpeakEnabled = enabled;\n            if (!enabled) {\n                clearTimeout(this.pauseHoverTimer);\n            }\n        }\n    }, {\n        key: 'mouseOverEvent',\n        value: function mouseOverEvent(event, callback) {\n            this.speechCallback = callback;\n            if (this.hoverSpeakOn) {\n                this.hoverSpeak.mouseMoved(event, this.speechCallback);\n            } else {\n                clearTimeout(this.pauseHoverTimer);\n            }\n        }\n        /**\n         * Checks if there are any selections\n         * @return {boolean} true if there are any selections.\n         */\n\n    }, {\n        key: 'hasSelection',\n        value: function hasSelection() {\n            return this.selectionController.hasSelection();\n        }\n\n        /**\n         * Gets the current word. If more than one word is selected the first word in\n         * the selection will be returned. If no word is selected the word below the\n         * cursor will be returned.\n         * @return {Array} an array containing the word.\n         */\n\n    }, {\n        key: 'getWord',\n        value: function getWord() {\n\n            var words = new Array();\n            var selection = this.selectionController.getSelectionRange();\n            if (selection) {\n                var words = selection.toString().split(/\\s/);\n\n                if (words.length > 0) {\n                    return new Array(words[0]);\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Gets currently selected text.\n         * @return {Array} The text that was selected and highlighted.\n         */\n\n    }, {\n        key: 'getSelection',\n        value: function getSelection() {\n            return this.selectionController.getSelectionRange().toString().split(/\\s/);\n        }\n    }, {\n        key: 'getSelectionLocal',\n        value: function getSelectionLocal() {\n            return this.getSelection();\n        }\n    }, {\n        key: 'clearSelection_',\n        value: function clearSelection_() {\n            this.selectionController.clearSelection_();\n        }\n\n        /**\n         * Clears the web page selection. This is not the highlights\n         * we add.\n         */\n\n    }, {\n        key: 'clearBrowserSelection',\n        value: function clearBrowserSelection() {\n            this.selectionController.clearBrowserSelection();\n        }\n\n        /**\n         * Highlights the currently selected text.\n         * @return {Array} The text that was selected and highlighted. If\n         *              nothing is selected an empty string will be returned.\n         */\n\n    }, {\n        key: 'hiliteSelection',\n        value: function hiliteSelection() {\n            var sentence = null;\n            if (this.hasSelection() || this.hoverSpeakOn) {\n                this.sentenceNo = 0;\n                if (this.hoverSpeakOn) {\n                    var range = this.hoverSpeak.getSelectionRange();\n                    this.speechObject.processRange(range, true);\n                } else {\n                    this.speechObject.processRange(this.selectionController.getSelectionRange(), false);\n                }\n                sentence = this.speechObject.getFirstSentence();\n                if (sentence && sentence.getRawText() == \"\") {\n                    sentence = this.speechObject.getNextSentence(true);\n                }\n            } else {\n                var range;\n                if (document.caretRangeFromPoint) {\n                    var docRange = document.caretRangeFromPoint(event.clientX, event.clientY);\n                    range = new _THDomRange.THDomRange(docRange.startContainer, docRange.startOffset, docRange.endContainer, docRange.endContainer);\n                } else {\n                    var docRange = document.caretPositionFromPoint(event.clientX, event.clientY);\n                    range = new _THDomRange.THDomRange(docRange.offsetNode, docRange.offset, docRange.offsetNode, docRange.offset);\n                }\n                this.speechObject.processRange(range, true);\n                sentence = this.speechObject.getNextSentence(true);\n            }\n            this.selectionController.clearBrowserSelection();\n            if (sentence != null) {\n                var text = sentence.getWords();\n                if (text.length == 0) {\n                    return \"\";\n                } else {\n                    this.speechHighlightManager = new _SpeechHighlightManager.SpeechHighlightManager(sentence);\n                    this.speechHighlightManager.highlightRange();\n                    return text;\n                }\n            }\n            return \"\";\n        }\n\n        /**\n         * Highlights a word with the current word colors. Used to\n         * highlight the currently spoken word.\n         * @param {number} wordNo number of the word to highlight.\n         */\n\n    }, {\n        key: 'hiliteWord',\n        value: function hiliteWord(wordNo) {\n            this.speechHighlightManager.highlightWord(wordNo);\n        }\n        /**\n         * Stops any speech\n         */\n\n    }, {\n        key: 'stop',\n        value: function stop() {\n            var sentence = this.speechObject.getCurrentSentence();\n            if (sentence != null && this.speechHighlightManager != null) {\n                this.speechHighlightManager.unHighlightRange();\n            }\n        }\n    }, {\n        key: 'hiliteNextSentence',\n        value: function hiliteNextSentence(continousReading) {\n            if (this.speechHighlightManager != null) {\n                this.speechHighlightManager.unHighlightRange();\n            }\n            var sentence = this.speechObject.getNextSentence(continousReading);\n            var text = null;\n            if (sentence != null) {\n                text = sentence.getWords();\n                this.speechHighlightManager = new _SpeechHighlightManager.SpeechHighlightManager(sentence);\n                this.speechHighlightManager.highlightRange(sentence);\n            }\n            return text;\n        }\n    }, {\n        key: 'highlightSelection',\n        value: function highlightSelection(colour) {\n            var selectionObject = this.selectionController.getSelectionObject();\n            this.studySkills.studySkillsHTMLHighlightRange(colour, selectionObject);\n        }\n    }, {\n        key: 'clearHighlights',\n        value: function clearHighlights() {\n            var selectionObject = null;\n            if (this.hasSelection()) {\n                selectionObject = this.selectionController.getSelectionObject();\n            }\n            this.studySkills.studySkillsClearHighlights(false, selectionObject);\n        }\n\n        /**\n         * Collects all the highlights fromt he current document.\n         * @param {Function} callback called when the highlights have been collected.\n         */\n\n    }, {\n        key: 'collectHighlights',\n        value: function collectHighlights(sort, colors) {\n            var highlights = new Array();\n            if (sort == 2) {\n                //collect by colour\n                for (var i = 0; i < colors.length; i++) {\n                    highlights.push.apply(highlights, _toConsumableArray(this.studySkills.studySkillsCollateForColour(colors[i])));\n                }\n            } else {\n                highlights.push.apply(highlights, _toConsumableArray(this.studySkills.studySkillsCollateForColour(colors)));\n            }\n            //callback();\n            return highlights;\n        }\n\n        /**\n         * Collects vocab words\n         * @param {Function} callback called when the words have been collected.\n         */\n\n    }, {\n        key: 'collectVocabWords',\n        value: function collectVocabWords(callback) {}\n\n        /**\n         * Add voice note to the current selection\n         */\n\n    }, {\n        key: 'addVoiceNote',\n        value: function addVoiceNote() {}\n\n        /****************************************************************\n         *                                                              *\n         *  End of the iParser interface implementation                 *\n         *                                                              *\n         /****************************************************************/\n\n    }, {\n        key: 'collectVocabs',\n        value: function collectVocabs(callback, colors, fileName) {\n            return this.studySkills.fetchWords();\n        }\n\n        /*******************************************************************\n         * Mouse events\n         *\n         *******************************************************************/\n\n    }, {\n        key: 'onMouseUp',\n        value: function onMouseUp(event) {}\n    }, {\n        key: 'onMouseDown',\n        value: function onMouseDown(event) {\n            this.prediction.setEditControl(event.target);\n        }\n    }, {\n        key: 'onKeyDown',\n        value: function onKeyDown(event) {\n            this.prediction.setEditControl(event.target);\n        }\n    }]);\n\n    return ParserAPI;\n}();\n/**\n * Public instance of this class.\n * @type {ParserAPI}\n */\n\ntextHelp.parsers = textHelp.parsers || {};\ntextHelp.parsers.HTMLParserAPI = textHelp.parsers.HTMLParserAPI || {};\ntextHelp.parsers.HTMLParserAPI = ParserAPI;\n\n},{\"src/SpeechStream/Events/EventBus\":6,\"src/SpeechStream/Highlighting/SpeechHighlightManager\":10,\"src/SpeechStream/Highlighting/StudySkillsHighlighting\":11,\"src/SpeechStream/Prediction/Prediction\":17,\"src/SpeechStream/Selection/HoverSpeak\":20,\"src/SpeechStream/Selection/SelectionController\":21,\"src/SpeechStream/SpeechObject\":26,\"src/SpeechStream/THDomRange\":29}],36:[function(require,module,exports){\n\"use strict\";\n\nrequire(\"src/api/ParserAPI\");\n\n},{\"src/api/ParserAPI\":35}]},{},[36])\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmNcXENvbnN0YW50c1xcQ29uc3RhbnRzLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXERPTVxcQXR0cmlidXRlLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXERPTVxcRG9tTmF2aWdhdGlvbi5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxET01cXERvbVNlbnRlbmNlcy5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxET01cXFNTRE9NLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXEV2ZW50c1xcRXZlbnRCdXMuanMiLCJzcmNcXFNwZWVjaFN0cmVhbVxcSGlnaGxpZ2h0aW5nXFxIaWdobGlnaHRCYXNlQ29udHJvbGxlci5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxIaWdobGlnaHRpbmdcXE1hdGhKYXhIaWdobGlnaHRDb250cm9sbGVyLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXEhpZ2hsaWdodGluZ1xcU3BlZWNoSGlnaGxpZ2h0Q29udHJvbGxlci5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxIaWdobGlnaHRpbmdcXFNwZWVjaEhpZ2hsaWdodE1hbmFnZXIuanMiLCJzcmNcXFNwZWVjaFN0cmVhbVxcSGlnaGxpZ2h0aW5nXFxTdHVkeVNraWxsc0hpZ2hsaWdodGluZy5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxNYXRoSmF4XFxFbGVtZW50SGVscGVyLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXE1hdGhKYXhcXEhpZ2hsaWdodERhdGEuanMiLCJzcmNcXFNwZWVjaFN0cmVhbVxcTWF0aEpheFxcTG9vcFN0YXRlLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXE1hdGhKYXhcXE1hdGhKYXhIaWdobGlnaHRlci5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxNYXRoSmF4XFxNYXRoU3BlYWsuanMiLCJzcmNcXFNwZWVjaFN0cmVhbVxcUHJlZGljdGlvblxcUHJlZGljdGlvbi5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxTY3JvbGxJblRvVmlldy5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxTZWxlY3Rpb25cXEJhc2VTZWxlY3Rpb24uanMiLCJzcmNcXFNwZWVjaFN0cmVhbVxcU2VsZWN0aW9uXFxIb3ZlclNwZWFrLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXFNlbGVjdGlvblxcU2VsZWN0aW9uQ29udHJvbGxlci5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxTZW50ZW5jZVxcQmFzZU9iamVjdC5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxTZW50ZW5jZVxcTWF0aFdvcmRPYmplY3QuanMiLCJzcmNcXFNwZWVjaFN0cmVhbVxcU2VudGVuY2VcXFNlbnRlbmNlT2JqZWN0LmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXFNlbnRlbmNlXFxXb3JkT2JqZWN0LmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXFNwZWVjaE9iamVjdC5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxUSENhcmV0LmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXFRIQ2FyZXRSYW5nZS5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxUSERvbVJhbmdlLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXFRIRG9tUmVmUHQuanMiLCJzcmNcXFNwZWVjaFN0cmVhbVxcVEhSYW5nZS5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxUSFJldHVybk9iamVjdC5qcyIsInNyY1xcU3BlZWNoU3RyZWFtXFxUZXh0T3ZlclJhbmdlQmVhbkNsYXNzLmpzIiwic3JjXFxTcGVlY2hTdHJlYW1cXFV0aWxpdGllc1xcVXRpbGl0aWVzLmpzIiwic3JjXFxhcGlcXFBhcnNlckFQSS5qcyIsInNyY1xcaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQ0FBOzs7O0FBSU8sSUFBTSx3Q0FBYyx5QkFBcEI7QUFDQSxJQUFNLG9DQUFhLHVCQUFuQjtBQUNBLElBQU0sOENBQW1CLENBQUMsQ0FBMUI7QUFDQSxJQUFNLDBEQUF5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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Y2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW5tbCBvbiAwMy8wNi8yMDE2LlxuICovXG5cbmV4cG9ydCBjb25zdCBISUdITElHSFRfVEFHPVwidGV4dGhlbHAtaGlnaGxpZ2h0LXNwYW5cIjtcbmV4cG9ydCBjb25zdCBXUkFQUEVSX1RBRyA9XCJ0ZXh0aGVscC13cmFwcGVyLXNwYW5cIjtcbmV4cG9ydCBjb25zdCBUSERvbVJhbmdlX0VSUk9SID0gLTE7XG5leHBvcnQgY29uc3QgVEhEb21SYW5nZV9UQVJHRVRfU0FNRSA9IDA7XG5leHBvcnQgY29uc3QgVEhEb21SYW5nZV9BRlRFUl9UQVJHRVQgPSAxO1xuZXhwb3J0IGNvbnN0IFRIRG9tUmFuZ2VfQkVGT1JFX1RBUkdFVCA9IDI7XG5leHBvcnQgY29uc3QgVEhEb21SYW5nZV9UQVJHRVRfSU5TSURFID0gMztcbmV4cG9ydCBjb25zdCBUSERvbVJhbmdlX1RBUkdFVF9JTkNMVURFU19USElTID0gNDtcbmV4cG9ydCBjb25zdCBUSERvbVJhbmdlX09WRVJMQVBTX0VORF9PRl9UQVJHRVQgPSA1O1xuZXhwb3J0IGNvbnN0IFRIRG9tUmFuZ2VfT1ZFUkxBUFNfU1RBUlRfT0ZfVEFSR0VUID0gNjtcbmV4cG9ydCBjb25zdCBUSERvbVJhbmdlX1RBUkdFVF9JTkNMVURFU19USElTX0FUX1NUQVJUID0gNztcbmV4cG9ydCBjb25zdCBUSERvbVJhbmdlX1RBUkdFVF9JTkNMVURFU19USElTX0FUX0VORCA9IDg7XG5cbmV4cG9ydCBjb25zdCBTUEVFQ0hfUkFOR0VfQ09MT1VSICA9IFwiY29sb3VyOiNycmdnYmI7IGJhY2tncm91bmQ6I0ZGRkYwMFwiO1xuZXhwb3J0IGNvbnN0IFNQRUVDSF9XT1JEX0NPTE9VUiAgID0gXCJjb2xvcjojRkZGRkZGOyBiYWNrZ3JvdW5kOiMwMDAwRkY7IHBhZGRpbmc6IDJweDsgbWFyZ2luOiAtMnB4OyBib3JkZXItcmFkaXVzOiA0cHg7IHRleHQtc2hhZG93OiAwIDNweCA4cHggIzJBMkEyQVwiO1xuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGtldmlubWwgb24gMDMvMDUvMjAxNi5cbiAqL1xuXG5leHBvcnQgY2xhc3MgQXR0cmlidXRle1xuICAgIGNvbnN0cnVjdG9yKCl7XG5cbiAgICB9XG5cbiAgICAvLyBhdHRyaWJ1dGUgc3VwcG9ydCBmb3IgaHRtbDVcbiAgICAvKipcbiAgICAgKiBUaGlzIGdldHMgYXR0cmlidXRlIGZvciBjdXN0b20gdHlwZXMuICBDdXN0b20gdHlwZXMgaW4gaHRtbDUgYXJlIHRvIGhhdmUgZGF0YS0gaW4gZnJvbnQgb2YgdGhlbS5cbiAgICAgKiBUaGlzIGFzc3VtZXMgdGhhdCBjYWxsIGlzIG1hZGUgd2l0aG91dCB0aGUgZGF0YS0gcHJlZmV4LlxuICAgICAqXG4gICAgICogSWYgaXQgZG9lcyBub3QgaGF2ZSBhIGRhdGEtIHByZWZpeCBpdCB3aWxsIGNoZWNrIHdpdGggdGhhdCBhZGRlZCwgdGhlbiBpZiBubyBtYXRjaCBjaGVjayB3aXRob3V0IHRoZSBwcmVmaXguXG4gICAgICpcbiAgICAgKiBJZiBpdCBkb2VzIGhhdmUgdGhlIGRhdGEtIHByZWZpeCwgd2lsbCBqdXN0IGNoZWNrIHRoYXQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgbm90IGZvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcF9ub2RlXG4gICAgICogQHBhcmFtIHBfc3RyTmFtZVxuICAgICAqL1xuICAgICByd19nZXRBdHRyaWJ1dGUocF9ub2RlLCBwX3N0ck5hbWUpXG4gICAge1xuICAgICAgICBpZihwX25vZGUgIT0gbnVsbCAmJiBwX25vZGUubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgdHlwZW9mKHBfc3RyTmFtZSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGF0dHIgPSBudWxsO1xuICAgICAgICAgICAgaWYocF9zdHJOYW1lLmluZGV4T2YoXCJkYXRhLXRleHRoZWxwLVwiKSAhPSAwKVxuICAgICAgICAgICAgeyAgIC8vIE5vdCBjYWxsZWQgd2l0aCBkYXRhLSB0cnkgZmlyc3Qgd2l0aCBkYXRhLVxuICAgICAgICAgICAgICAgIGF0dHIgPSBwX25vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZXh0aGVscC1cIiArIHBfc3RyTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGF0dHIgPT0gbnVsbCAmJiBwX3N0ck5hbWUuaW5kZXhPZihcImRhdGEtXCIpICE9IDApXG4gICAgICAgICAgICB7ICAgLy8gTm90IGNhbGxlZCB3aXRoIGRhdGEtIHRyeSBmaXJzdCB3aXRoIGRhdGEtXG4gICAgICAgICAgICAgICAgYXR0ciA9IHBfbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgcF9zdHJOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoYXR0ciA9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHIgPSBwX25vZGUuZ2V0QXR0cmlidXRlKHBfc3RyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHNldHMgYXR0cmlidXRlIGZvciBjdXN0b20gdHlwZXMuICBDdXN0b20gdHlwZXMgaW4gaHRtbDUgYXJlIHRvIGhhdmUgZGF0YS0gaW4gZnJvbnQgb2YgdGhlbS5cbiAgICAgKiBUaGlzIHdpbGwgYWRkIGEgZGF0YS0gdG8gdGhlIGZyb250IGlmIG5vdCB0aGVyZS5cbiAgICAgKiBAcGFyYW0gcF9ub2RlXG4gICAgICogQHBhcmFtIHBfc3RyTmFtZVxuICAgICAqIEBwYXJhbSBwX3N0clZhbFxuICAgICAqL1xuICAgICByd19zZXRBdHRyaWJ1dGUocF9ub2RlLCBwX3N0ck5hbWUsIHBfc3RyVmFsKVxuICAgIHtcbiAgICAgICAgaWYocF9ub2RlICE9IG51bGwgJiYgcF9ub2RlLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgIHR5cGVvZihwX3N0ck5hbWUpID09IFwic3RyaW5nXCIgJiYgdHlwZW9mKHBfc3RyVmFsKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihwX3N0ck5hbWUgPT0gXCJzdHlsZVwiICYmIGZhbHNlIC8qU1NITC5kYXQuYnJvd3Nlci5iSUVPbGQqLylcbiAgICAgICAgICAgIHsgICAvL3dvcmthcm91bmQgZm9yIElFIGJ1ZyBvZiBzZXRBdHRyaWJ1dGUgbm90IHdvcmtpbmcgZm9yIHN0eWxlXG4gICAgICAgICAgICAgICAgcF9ub2RlLnN0eWxlLnNldEF0dHJpYnV0ZShcImNzc1RleHRcIiwgcF9zdHJWYWwsIDApOyAvLyB0aGlyZCBwYXJhbWV0ZXIgaXMgZm9yIGNhc2Ugc2Vuc2l0aXZlIG9yIG5vdCAoMCBmb3Igbm90KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocF9zdHJOYW1lLmluZGV4T2YoXCJkYXRhLVwiKSAhPSAwICYmIHBfc3RyTmFtZSAhPSBcInN0eWxlXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcF9zdHJOYW1lID0gXCJkYXRhLVwiICsgcF9zdHJOYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwX25vZGUuc2V0QXR0cmlidXRlKHBfc3RyTmFtZSwgcF9zdHJWYWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyByZW1vdmVzIGF0dHJpYnV0ZSBmb3IgY3VzdG9tIHR5cGVzLiAgQ3VzdG9tIHR5cGVzIGluIGh0bWw1IGFyZSB0byBoYXZlIGRhdGEtIGluIGZyb250IG9mIHRoZW0uXG4gICAgICogVGhpcyB3aWxsIGFkZCBhIGRhdGEtIHRvIHRoZSBmcm9udCBpZiBub3QgdGhlcmUgdG8gY2hlY2sgdGhhdCBmaXJzdC5cbiAgICAgKiBAcGFyYW0gcF9ub2RlXG4gICAgICogQHBhcmFtIHBfc3RyTmFtZVxuICAgICAqL1xuICAgICByd19yZW1vdmVBdHRyaWJ1dGUocF9ub2RlLCBwX3N0ck5hbWUpXG4gICAge1xuICAgICAgICBpZihwX25vZGUgIT0gbnVsbCAmJiBwX25vZGUubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgdHlwZW9mKHBfc3RyTmFtZSkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYocF9zdHJOYW1lLmluZGV4T2YoXCJkYXRhLVwiKSAhPSAwKVxuICAgICAgICAgICAgeyAgIC8vIGRvZXNuJ3Qgc3RhcnQgd2l0aCBcImRhdGEtXCJcbiAgICAgICAgICAgICAgICBpZihwX25vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIHBfc3RyTmFtZSkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBfbm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLVwiICsgcF9zdHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocF9ub2RlLmdldEF0dHJpYnV0ZShwX3N0ck5hbWUpICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcF9ub2RlLnJlbW92ZUF0dHJpYnV0ZShwX3N0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDAzLzA1LzIwMTYuXG4gKi9cbmltcG9ydCB7VXRpbGl0aWVzfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1V0aWxpdGllcy9VdGlsaXRpZXMnXG5pbXBvcnQge1NTRE9NfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9TU0RPTSdcbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9BdHRyaWJ1dGUnXG5pbXBvcnQge01hdGhTcGVha30gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9NYXRoSmF4L01hdGhTcGVhaydcbmltcG9ydCB7VEhDYXJldH0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USENhcmV0J1xuaW1wb3J0IHtUSENhcmV0UmFuZ2V9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhDYXJldFJhbmdlJ1xuaW1wb3J0ICogYXMgQ29uc3RhbnRzIGZyb20gJ3NyYy9Db25zdGFudHMvQ29uc3RhbnRzJ1xuXG5cbmV4cG9ydCBjbGFzcyBEb21OYXZpZ2F0aW9ue1xuICAgIGNvbnN0cnVjdG9yKCl7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgZ2V0IGFjdHVhbCBuZXh0IG5vZGUsIGxvb2tpbmcgaW4gb3JkZXIgbmV4dC9uZXh0IG9mIHBhcmVudFxuICAgICAqIEBwYXJhbSBwX25vZGVcbiAgICAgKiBAcGFyYW0gcF9lbmROb2RlXG4gICAgICogQHJldHVybnMgeyp9ICBudWxsIG9mIGVycm9yIG9yIG5vIG5leHRcbiAgICAgKi9cbiAgICBnZXRBY3R1YWxOZXh0Tm9kZUlnbm9yZUNoaWxkcmVuIChwX25vZGUsIHBfZW5kTm9kZSlcbiAgICB7XG4gICAgICAgIGlmKHBfbm9kZSA9PSBudWxsIHx8IHBfbm9kZSA9PSBwX2VuZE5vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocF9ub2RlLm5leHRTaWJsaW5nICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwX25vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAvL3VwIHRvIHJpZ2h0XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciByaWdodE5vZGUgPSBwX25vZGU7XG4gICAgICAgICAgICB3aGlsZSAocmlnaHROb2RlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmlnaHROb2RlID0gcmlnaHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYocF9lbmROb2RlID09IHJpZ2h0Tm9kZSlcbiAgICAgICAgICAgICAgICB7ICAgLy8gZG9uJ3QgZ28gcGFzdCBlbmRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHJpZ2h0Tm9kZS5uZXh0U2libGluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHsgICAvLyBkb2Vzbid0IG1hdHRlciBpZiB0aGlzIGlzIGVuZCBvciBub3QsIGFsbG93ZWQgdG8gbW92ZSB0byBlbmQsIGp1c3Qgbm90IHBhc3QgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgZ2V0IGFjdHVhbCBuZXh0IG5vZGUsIGxvb2tpbmcgaW4gb3JkZXIgY2hpbGQvbmV4dC9uZXh0IG9mIHBhcmVudC5cbiAgICAgKiBUaGlzIGNhbiBtb3ZlIHRvIHRoZSBlbmQgbm9kZSBidXQgbm90IHBhc3QgaXQuXG4gICAgICogR29pbmcgcGFzdCBtZWFucyBnb2luZyB0byBuZXh0IHNpYmxpbmcgZnJvbSBhbiBlbmQgbm9kZSwgb3IgdXAgdHJlZSB0byByaWdodCBieSBtb3ZpbmcgZnJvbSBvciBvdmVyIGVuZCBub2RlLlxuICAgICAqIEFzIGluY2x1c2l2ZSB3aWxsIGluY2x1ZGUgY29udGVudHMgb2YgdGhlIGNoaWxkcmVuIG9mIHRoZSBlbmQgbm9kZS4gIChTbyBnb2VzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIGVuZCBub2RlLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwX25vZGVcbiAgICAgKiBAcGFyYW0gcF9lbmROb2RlXG4gICAgICogQHJldHVybnMgeyp9ICBudWxsIG9mIGVycm9yIG9yIG5vIG5leHRcbiAgICAgKi9cbiAgICBnZXRBY3R1YWxOZXh0Tm9kZSAocF9ub2RlLCBwX2VuZE5vZGUpXG4gICAge1xuICAgICAgICBpZihwX25vZGUgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwX25vZGUuZmlyc3RDaGlsZCAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcF9ub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwX25vZGUgPT0gcF9lbmROb2RlKVxuICAgICAgICB7ICAgLy8gZG9uJ3QgZ28gcGFzdCBlbmRcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocF9ub2RlLm5leHRTaWJsaW5nICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwX25vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAvL3VwIHRvIHJpZ2h0XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciByaWdodE5vZGUgPSBwX25vZGU7XG4gICAgICAgICAgICB3aGlsZSAocmlnaHROb2RlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmlnaHROb2RlID0gcmlnaHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYocF9lbmROb2RlID09IHJpZ2h0Tm9kZSlcbiAgICAgICAgICAgICAgICB7ICAgLy8gZG9uJ3QgZ28gcGFzdCBlbmRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHJpZ2h0Tm9kZS5uZXh0U2libGluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHsgICAvLyBkb2Vzbid0IG1hdHRlciBpZiB0aGlzIGlzIGVuZCBvciBub3QsIGFsbG93ZWQgdG8gbW92ZSB0byBlbmQsIGp1c3Qgbm90IHBhc3QgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKlVzZWQgYnkgZ2V0Q2FyZXRGcm9tRG9tUG9zaXRpb25cbiAgICAgcmV0dXJucyBhIG5vZGUgb3IgbnVsbCBpZiBlcnJvciBvY2N1cnMqL1xuICAgIGdldE5vZGVGcm9tUG9zaXRpb24gKHBfdGhlQm9keSwgcF9zdHJQYXRoKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgdmFyIHRoZU5vZGUgPSBwX3RoZUJvZHk7XG5cbiAgICAgICAgLy8gbG9naWMgdG8gcmVtb3ZlIGNodW5rIHBhcnQgb2YgcGF0aFxuICAgICAgICBpZihwX3N0clBhdGgubGFzdEluZGV4T2YoXCIqXCIpID4gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuUG9zID0gcF9zdHJQYXRoLmxhc3RJbmRleE9mKFwiKlwiKTtcbiAgICAgICAgICAgIHBfc3RyUGF0aCA9IHBfc3RyUGF0aC5zdWJzdHJpbmcoblBvcyArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFyc2Ugb2Zmc2V0IHZhbHVlcyBhbmQgaXRlcmF0ZSBlbmQgdG8gc3RhcnQsXG4gICAgICAgIC8vbW92aW5nIHNldCBudW1iZXIgb2Ygbm9kZXMgdG8gcmlnaHQgYmVmb3JlIGdvaW5nIHRvIG5leHQgbGV2ZWxcbiAgICAgICAgdmFyIGFTdHIgPSBwX3N0clBhdGguc3BsaXQoXCJ+XCIpO1xuICAgICAgICB2YXIgbkxlbiA9IGFTdHIubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IoaSA9IG5MZW4gLSAyOyBpID4gLTE7IGktLSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhlTm9kZSA9IHRoZU5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmKHRoZU5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHsgICAvL2Vycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgblZhbDtcbiAgICAgICAgICAgIGlmKGFTdHJbaV0ubGVuZ3RoID09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgblZhbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgblZhbCA9IHBhcnNlSW50KGFTdHJbaV0sIDEwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVG8gY2hlY2sgZm9yIG11bHRpcGxlIHRleHQgbm9kZXMgdG9nZXRoZXJcblxuICAgICAgICAgICAgdmFyIGJJc1RleHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBiV2FzTGFzdFRleHQgPSAodGhlTm9kZS5ub2RlVHlwZSA9PSAzKSB8fFxuICAgICAgICAgICAgICAgICh0aGVOb2RlLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhlTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gQ29uc3RhbnRzLkhJR0hMSUdIVF9UQUcmJlxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRoZU5vZGUsIFwicndzdGF0ZVwiKSAhPSBudWxsKTtcblxuICAgICAgICAgICAgd2hpbGUoblZhbCA+IDApXG4gICAgICAgICAgICB7ICAgLy8gbmVlZCB0byBtb3ZlIHJpZ2h0XG4gICAgICAgICAgICAgICAgdGhlTm9kZSA9IHRoZU5vZGUubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICBpZih0aGVOb2RlID09IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiSXNUZXh0ID0gKHRoZU5vZGUubm9kZVR5cGUgPT0gMykgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoZU5vZGUubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gQ29uc3RhbnRzLkhJR0hMSUdIVF9UQUcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUodGhlTm9kZSwgXCJyd3N0YXRlXCIpICE9IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmKGJJc1RleHQgJiYgYldhc0xhc3RUZXh0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGV4dCB0b2dldGhlciBrZWVwIG1vdmluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBsZWF2ZSBiV2FzTGFzdFRleHQgYXMgaXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLS1uVmFsO1xuICAgICAgICAgICAgICAgICAgICBiV2FzTGFzdFRleHQgPSBiSXNUZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGZvciBhbGwgbm9uIHRleHQgd2lsbCBkZWNyZWFzZSBuVmFsXG4gICAgICAgICAgICAgICAgLy8gZm9yIG5vbiB0ZXh0IHRvIG5vbiB0ZXh0IHdpbGwgbGVhdmUgYldhc0xhc3RUZXh0IGZhbHNlXG4gICAgICAgICAgICAgICAgLy8gZm9yIG5vbiB0ZXh0IHRvIHRleHQgd2lsbCBzZXQgYldhc0xhc3RUZXh0IHRydWVcblxuICAgICAgICAgICAgICAgIC8vIGZvciB0ZXh0IHRvIHRleHQgd2lsbCBsZWF2ZSBhcyBpczsgYW5kIG5vIGRlY3JlYXNlIG9mIG5WYWxcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGV4dCB0byBub24gdGV4dCB3aWxsIHNldCBiV2FzTGFzdFRleHQgdG8gZmFsc2U7IGFuZCBkZWNyZWFzZSBuVmFsXG5cbiAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IGNhcmUgaGVyZSBpZiB0ZXh0IGlzIGVtcHR5IGhlcmUsIGlmIHRoYXQgaXMgYSBwcm9ibGVtIG5lZWQgdG8gcmVtb3ZlIGVtcHR5XG4gICAgICAgICAgICAgICAgLy8gdGV4dCBpbiB0YWdzZW50ZW5jZXMgbWV0aG9kLCBhcyBpcyBkb25lIHdpdGggcGt0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoZU5vZGU7XG4gICAgfTtcblxuICAgIC8vR2V0IHRleHQgdGhhdCBjYW4gYmUgc3Bva2VuIGZyb20gYSBub2RlIG9yIGVsZW1lbnQsXG4vLyBidXQgb25seSBmcm9tIGltbWVkaWF0ZSBsZXZlbCwgbm90IGRvd24gdHJlZVxuICAgIGdldFRleHRGcm9tTm9kZSAocF9ub2RlKVxuICAgIHtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKCk7XG4gICAgICAgIHZhciB0eHQgPSBcIlwiO1xuXG4gICAgICAgIGlmKHNzZG9tLmlzSW52YWxpZE5vZGUocF9ub2RlKSB8fCBzc2RvbS5pc0lnbm9yZWQocF9ub2RlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHR4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBfbm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihwX25vZGUucGFyZW50Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT0gXCJ0ZXh0YXJlYVwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR4dCA9IHBfbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihwX25vZGUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0clRhZ05hbWUgPSBwX25vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYoc3RyVGFnTmFtZSA9PSBcImltZ1wiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0bXBBdHRyID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShwX25vZGUsIFwibXNnXCIpO1xuICAgICAgICAgICAgICAgIGlmKHRtcEF0dHIgIT0gbnVsbCAmJiB0bXBBdHRyLnRyaW1USCgpLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eHQgPSBcIiBcIiArIHRtcEF0dHIudHJpbVRIKCkgKyBcIiBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHN0clRhZ05hbWUgPT0gXCJzcGFuXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcEF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHBfbm9kZSwgXCJwcm9uXCIpO1xuICAgICAgICAgICAgICAgIGlmKHRtcEF0dHIgIT0gbnVsbCAmJiB0bXBBdHRyLnRyaW1USCgpLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eHQgPSB0bXBBdHRyLnRyaW1USCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRtcEF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHBfbm9kZSwgXCJjaHVua1wiKTtcbiAgICAgICAgICAgICAgICBpZih0bXBBdHRyICE9IG51bGwgJiYgdG1wQXR0ciA9PSBcIjFcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR4dCA9IHBfbm9kZS5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRtcEF0dHIgPSBwX25vZGUuaXNNYXRoSmF4O1xuICAgICAgICAgICAgICAgIGlmKHRtcEF0dHIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0aFNwZWFrID0gbmV3IE1hdGhTcGVhaygpO1xuICAgICAgICAgICAgICAgICAgICB0eHQgPSBtYXRoU3BlYWsuZ2V0VGV4dEZyb21NYXRoSmF4KHBfbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihzdHJUYWdOYW1lID09IFwiYWNyb255bVwiIHx8IHN0clRhZ05hbWUgPT0gXCJhYmJyXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gYWNyb255bSBhbmQgYWJiciBhcmUgcmVxdWlyZWQgdG8gaGF2ZSBhIHRpdGxlLCBidXQgdGhpcyBpcyBkaXNwbGF5ZWQgaW4gYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIGFuZCBtYXkgbm90IGJlIHByb25vdW5jZWQgY29ycmVjdGx5LCByYXRoZXIgdGhhbiBoYXZlIHRoZSB0aXRsZSBzcGVsdCBhcyBwcm9ub3VuY2VkXG4gICAgICAgICAgICAgICAgLy8gYW5kIGhhdmUgdXNlciBzZWUgdGhpcywgaGF2ZSB0aXRsZSBhbmQgcHJvbiBhdHRyaWJ1dGVzIGFuZCB1c2UgcHJvbiBmb3IgY29ycmVjdCBwcm9udW5jaWF0aW9uLlxuICAgICAgICAgICAgICAgIHZhciB0bXBBdHRyID0gIGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocF9ub2RlLCBcInByb25cIik7XG4gICAgICAgICAgICAgICAgdmFyIHV0aWxzID0gbmV3IFV0aWxpdGllcygpXG4gICAgICAgICAgICAgICAgaWYodG1wQXR0ciAhPSBudWxsICYmIHV0aWxzLnRyaW0odG1wQXR0cikubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR4dCA9IHV0aWxzLnRyaW0odG1wQXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRtcEF0dHIgPSBwX25vZGUuZ2V0QXR0cmlidXRlKFwidGl0bGVcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcEF0dHIgIT0gbnVsbCAmJiB1dGlscy50cmltKHRtcEF0dHIpLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4dCA9IHV0aWxzLnRyaW0odG1wQXR0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHN0clRhZ05hbWUgPT0gXCJtYXRoXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHh0ID0gdGhpcy5nZXRUZXh0RnJvbU1hdGhNbChwX25vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR4dDtcbiAgICB9XG5cbiAgICAvKlVzZSB0aGlzIHdoZW4gcF9ub2RlIG1pZ2h0IGVxdWFsIHBfZW5kTm9kZSBhbmQgZG8gbm90IHdhbnQgdG9cbiAgICAganVzdCByZXR1cm4gbnVsbCBpbiB0aGlzIGNhc2UuICBNb3ZpbmcgdG8gY2hpbGQgYWxsb3dlZCBmcm9tIGVuZCBub2RlLCBidXQgbm90IHRvIG5leHQuXG4gICAgIFRoaXMgc2hvdWxkIGJlIHVzZWQgb24gZmlyc3QgbG9vcCBvbmx5LCBvbiBzdWJzZXF1ZW50IGxvb3BzIHJlYWNoaW5nIHBfZW5kTm9kZVxuICAgICB3b3VsZCBlaXRoZXIgbWVhbiBtb3ZlZCB0byBlbmQgbm9kZSBvciByZXR1cm5lZCB0byBub2RlLCBub3Qgc3RhcnRpbmcgZnJvbSBlbmQgbm9kZS5cbiAgICAgKFRoaXMgaXMgbmVlZGVkIGZvciBleGFtcGxlIGluIHNlYXJjaGluZyByYW5nZSBvZiBjaGlsZHJlbiBvZiBzaW5nbGUgbm9kZSwgc28gc3RhcnQgYW5kIGVuZCBub2RlIGFyZSBzYW1lLFxuICAgICB3aXRob3V0IHRoaXMgd291bGQganVzdCBza2lwIGFsbCBjaGlsZHJlbiBpbiB0aGF0IGNhc2UuKVxuICAgICAqL1xuICAgIGdldE5leHROb2RlQWxsb3dNb3ZlVG9DaGlsZCAocF9ub2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHROb2RlSW1wbChwX25vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypSZXR1cm5zIHRoZSBuZXh0IG5vZGUsIGVpdGhlciBkaXJlY3RseSB0byByaWdodCBvciB1cCB0byByaWdodC5cbiAgICAgUmV0dXJucyBudWxsIGlmIG5vIHJpZ2h0IG5vZGUuXG5cbiAgICAgYWxsb3dlZCB0byBtb3ZlIHRvIGVuZCBub2RlIGJ1dCBpZiBlbmQgbm9kZSBwYXNzZWQgaW4gYXMgbm9kZSByZXR1cm4gbnVsbCovXG4gICAgZ2V0TmV4dE5vZGVJZ25vcmVDaGlsZHJlbiAocF9ub2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHROb2RlSW1wbChwX25vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qIFVzZSB0aGlzIHRvIGdldCB0aGUgYm90dG9tIGNoaWxkIHRleHQgbm9kZSBhdCBlbmQgb2YgdGhlIGVsZW1lbnRcbiAgICAgdXNpbmcgc2FtZSBydWxlcyBmb3IgaWdub3Jpbmcgbm9kZXMuXG4gICAgIDxicj5cbiAgICAgcF9ub2RlIHRoZSBub2RlIHRvIGdldCBsYXN0IGNoaWxkIG9mXG5cbiAgICAgcmV0dXJuIHRoZSBmaXJzdCB0ZXh0IG5vZGUgcmVhY2hlZCAsIG51bGwgaWYgY2Fubm90IGdldCBvbmVcbiAgICAgQ291bGQgYWxzbyBiZSBpbWcgZWxlbWVudCB3aXRoIG1zZ1xuICAgICBJZiBubyB2YWxpZCBjaGlsZHJlbiB3aWxsIHJldHVybiBpdHNlbGYuXG4gICAgICovXG4gICAgZ2V0TGFzdENoaWxkVGV4dE5vZGUgKHBfbm9kZSwgcF9iQWxsb3dJbWcpXG4gICAge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSgpO1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgaWYocF9ub2RlID09IG51bGwgfHwgcF9ub2RlLmxhc3RDaGlsZCA9PSBudWxsIHx8IHNzZG9tLmlzSW52YWxpZE5vZGUocF9ub2RlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBfbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNzZG9tLmlzU3BlY2lhbENhc2VXaXRoSWdub3JlZENvbnRlbnQocF9ub2RlKSlcbiAgICAgICAgeyAgIC8vIE5vIHZhbGlkIGNoaWxkIHRleHQgdG8gZ28gdG8gYW5kIHRoaXMgaXMgdGhlIHRvcCBsZXZlbCBub2RlIHNvIGNhbid0IGdvIHRvIHByZXZpb3VzLlxuICAgICAgICAgICAgcmV0dXJuIHBfbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5lZWQgdG8gZ2V0IGRvd24gdG8gYWJzb2x1dGUgbGFzdCBjaGlsZCBmb3IgZ2V0IHByZXZpb3VzIHRvIHdvcmsuXG4gICAgICAgIC8vKGRpZmZlcmVudCB0byBnZXQgZmlyc3QgYXMgZ2V0bmV4dCBnb2VzIGRvd24gdHJlZSB3aGlsZSBnZXRQcmV2IGRvZXNuJ3QpXG5cbiAgICAgICAgdmFyIHRtcE5vZGUgPSBwX25vZGUubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSh0bXBOb2RlICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBiSWdub3JlZCA9IHNzZG9tLmlzSWdub3JlZChwX25vZGUpO1xuXG4gICAgICAgICAgICBpZighYklnbm9yZWQgJiYgdG1wTm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZighYklnbm9yZWQgJiZcbiAgICAgICAgICAgICAgICB0bXBOb2RlLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgICAgICBwX2JBbGxvd0ltZyAmJlxuICAgICAgICAgICAgICAgIHRtcE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwiaW1nXCIgJiZcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRtcE5vZGUsIFwibXNnXCIpICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRtcE5vZGUsIFwibXNnXCIpLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHNzZG9tLmlzSW52YWxpZE5vZGUodG1wTm9kZSkgfHwgdG1wTm9kZS5sYXN0Q2hpbGQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHNzZG9tLmlzU3BlY2lhbENhc2VXaXRoSWdub3JlZENvbnRlbnQocF9ub2RlKSlcbiAgICAgICAgICAgIHsgICAvLyBjYW4ndCBnbyBkb3duIGFuZCBubyBtYXRjaCB5ZXQgc28gbG9vayB0byBwcmV2aW91c1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Tm9kZTtcbiAgICAgICAgICAgICAgICBpZihwX2JBbGxvd0ltZylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZOb2RlID0gdGhpcy5nZXRQcmV2aW91c1RleHROb2RlKHRtcE5vZGUsIGZhbHNlLCBwX25vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcmV2Tm9kZSA9IHRoaXMuZ2V0UHJldmlvdXNUZXh0Tm9kZU5vSW1nKHRtcE5vZGUsIGZhbHNlLCBwX25vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0bXBOb2RlID0gdG1wTm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gICAvL25iIHdvbnQgZXZlciBhY3R1YWxseSBleGl0IG5vcm1hbGx5IGZyb20gdGhpcywgd2lsbCBhbHdheXMgYmUgbGVmdCB2aWEgYSByZXR1cm4uXG5cbiAgICAgICAgLy8gaWYgY2Fubm90IGdldCB0byBjaGlsZCByZXR1cm4gc2VsZlxuICAgICAgICByZXR1cm4gcF9ub2RlO1xuICAgIH07XG5cbiAgICAvKlVzZSB0aGlzIHRvIGdldCBndWFyYW50ZWVkIHRleHQgbm9kZSBhbmQgbm90IGltZyB3aXRoIG1zZ1xuICAgICAqL1xuICAgIGdldFByZXZpb3VzVGV4dE5vZGVOb0ltZyAocF9ub2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSwgcF9iSW5jbHVkZUJsYW5rcylcbiAgICB7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IChwX2JJbmNsdWRlQmxhbmtzKT9cbiAgICAgICAgICAgIHRoaXMuZ2V0UHJldmlvdXNUZXh0Tm9kZShwX25vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlKSA6XG4gICAgICAgICAgICB0aGlzLmdldFByZXZpb3VzVGV4dE5vZGVOb0JsYW5rKHBfbm9kZSwgcF9iR29CeVN0eWxlLCBwX2VuZE5vZGUpO1xuXG4gICAgICAgIHdoaWxlKGxlZnROb2RlICE9IG51bGwgJiZcbiAgICAgICAgICAgIGxlZnROb2RlLm5vZGVUeXBlICE9IDMgJiZcbiAgICAgICAgICAgIGxlZnROb2RlICE9IHBfZW5kTm9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYobGVmdE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwibWF0aFwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihsZWZ0Tm9kZS5pc01hdGhKYXgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlZnROb2RlID0gKHBfYkluY2x1ZGVCbGFua3MpP1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0UHJldmlvdXNUZXh0Tm9kZShsZWZ0Tm9kZSwgcF9iR29CeVN0eWxlLCBwX2VuZE5vZGUpIDpcbiAgICAgICAgICAgICAgICB0aGlzLmdldFByZXZpb3VzVGV4dE5vZGVOb0JsYW5rKGxlZnROb2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVmdE5vZGU7XG4gICAgfTtcblxuICAgIC8qIFRoaXMgc2NyaXB0IGdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBvbmUgcGFzc2VkIHRvIHRoZSBzY3JpcHRcbiAgICAgYnV0IG9ubHkgaWYgY29udGFpbnMgdXNlZnVsIHRleHQuXG5cbiAgICAgcF9ub2RlIHN0YXJ0IG5vZGUgdG8gbG9vayBmcm9tXG4gICAgIHBfYkdvQnlTdHlsZSBpZiB0cnVlIGtlZXAgbG9va2luZyB0aWxsIHJlYWNoIG5vbiBzdHlsZSBub2RlIChwYXNzZXMgYmFjayBvcmlnaW5hbCBvZiBub3RoaW5nIGZvdW5kKVxuICAgICBwX2VuZE5vZGUsIGEgbm9kZSB0byBub3QgZ28gcGFzdCBhbmQgbm90IHRvIGJlIGluY2x1ZGVkIGFzIGEgcmV0dXJuIG5vZGVcbiAgICAgKi9cbiAgICBnZXRQcmV2aW91c1RleHROb2RlTm9CbGFuayAocF9ub2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKCk7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBwX25vZGU7XG5cbiAgICAgICAgd2hpbGUobGVmdE5vZGUgIT0gbnVsbCAmJiBsZWZ0Tm9kZSAhPSBwX2VuZE5vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxlZnROb2RlID0gdGhpcy5nZXRQcmV2aW91c1RleHROb2RlKGxlZnROb2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSk7XG5cbiAgICAgICAgICAgIGlmKGxlZnROb2RlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHN0clRvQ2hlY2s7XG5cbiAgICAgICAgICAgICAgICAvL0VpdGhlciB0ZXh0IG5vZGUgb3IgbXNnIGltZ1xuICAgICAgICAgICAgICAgIGlmKGxlZnROb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHJUb0NoZWNrID0gbGVmdE5vZGUubm9kZVZhbHVlLnRyaW1USCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihsZWZ0Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJpbWdcIiAmJiBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKGxlZnROb2RlLCBcIm1zZ1wiKSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJUb0NoZWNrID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShsZWZ0Tm9kZSwgXCJtc2dcIikudHJpbVRIKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihsZWZ0Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJtYXRoXCIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clRvQ2hlY2sgPSB0aGlzLmdldFRleHRGcm9tTWF0aE1sKGxlZnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGxlZnROb2RlLmlzTWF0aEpheClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGhTcGVhayA9IG5ldyBNYXRoU3BlYWsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clRvQ2hlY2sgPSBtYXRoU3BlYWsuZ2V0VGV4dEZyb21NYXRoSmF4KGxlZnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHNzZG9tLnJ3X2lzV29yZFNwZWFrYWJsZShzdHJUb0NoZWNrKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qIFRoaXMgc2NyaXB0IGdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGUgb2YgdGhlIG9uZSBwYXNzZWQgdG8gdGhlIHNjcmlwdFxuICAgICBUaGlzIHdpbGwgZ2l2ZSB0aGUgdGV4dCBub2RlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY3VycmVudCBub2RlIGlmIG1hdGNoIGZvdW5kIGFuZFxuICAgICB3aWxsIGluY2x1ZGUgaW1nIGVsZW1lbnRzIHdpdGggbXNnIHRleHQuXG5cbiAgICAgcF9ub2RlIHN0YXJ0IG5vZGUgdG8gbG9vayBmcm9tXG4gICAgIHBfYkdvQnlTdHlsZSBpZiB0cnVlIHRoZW4gc3RvcCBpZiBoaXQgbm9uIHN0eWxlIG5vZGVcbiAgICAgcF9lbmROb2RlLCBhIG5vZGUgdG8gbm90IGdvIHBhc3QgYW5kIG5vdCB0byBiZSBpbmNsdWRlZCBhcyBhIHJldHVybiBub2RlXG5cbiAgICAgcmV0dXJuIHByZXZpb3VzIHRleHQgbm9kZSBvciBudWxsIGlmIG5vIHByZXZpb3VzIHRleHQgbm9kZSBvciBpdCBub24gc3R5bGUgb3IgZW5kIG5vZGUsIG9yIHJldHVybnMgZWxlbWVudCBpZiBpbWFnZSB3aXRoIG1zZyB0ZXh0LlxuICAgICAqL1xuICAgIGdldFByZXZpb3VzVGV4dE5vZGUgKHBfbm9kZSwgcF9iR29CeVN0eWxlLCBwX2VuZE5vZGUpXG4gICAge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSgpO1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBwX25vZGU7XG4gICAgICAgIHZhciBiTWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAvLyBOb3RlIGxlZnROb2RlIGNvdWxkIGVxdWFsIGVuZCBub2RlIGZyb20gcmV0dXJuIGZyb20gZ2V0IHByZXYgTm9kZVxuICAgICAgICAvLyBva2F5IHRvIHJldHVybiB0aGlzIGlmIGEgbWF0Y2gsIGJ1dCBkbyBub3Qgd2FudCB0byBzZWFyY2ggb24gYmVmb3JlIHRoaXMgdG8gcHJldiBub2RlLlxuXG4gICAgICAgIHdoaWxlIChsZWZ0Tm9kZSAhPSBudWxsICYmIGxlZnROb2RlICE9IHBfZW5kTm9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGVmdE5vZGUgPSB0aGlzLmdldFByZXZpb3VzTm9kZShsZWZ0Tm9kZSwgcF9iR29CeVN0eWxlLCBwX2VuZE5vZGUpO1xuXG4gICAgICAgICAgICBpZihsZWZ0Tm9kZSAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0Tm9kZS5ub2RlVHlwZSA9PSAzICYmXG4gICAgICAgICAgICAgICAgICAgIGxlZnROb2RlLnBhcmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9IFwidGV4dGFyZWFcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGxlZnROb2RlLm5vZGVWYWx1ZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxlZnROb2RlLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgbGVmdE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwibWF0aFwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdE5vZGUubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBsZWZ0Tm9kZS5pc01hdGhKYXgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGxlZnROb2RlLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgbGVmdE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwiaW1nXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wQXR0ciA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUobGVmdE5vZGUsIFwibXNnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG1wQXR0ciAhPSBudWxsICYmIHRtcEF0dHIubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGJNYXRjaClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLypSZXR1cm5zIHRoZSBwcmV2aW91cyBub2RlLlxuICAgICBUaGlzIGlnbm9yZXMgY2hpbGQgbm9kZXMgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgSWYgdGhlIG5vZGUgaGFzIG5vIHByZXZpb3VzIHNpYmxpbmdzIGl0IHdpbGwgZ28gdG8gdGhlIHBhcmVudC5cbiAgICAgVGhpcyBnaXZlcyB0aGUgaW1tZWRpYXRlIG5vZGUgdG8gdGhlIGxlZnQgZXhjZXB0IGluIG9uZSBjYXNlLlxuICAgICBJZiB0aGUgbm9kZSBtb3ZlZCB0byBoYXMgY2hpbGQgbm9kZXMsIGltbWVkaWF0ZWx5IG1vdmUgdG8gdGhlIGJvdHRvbS4gIFRoZSBub2RlcyBza2lwcGVkIHdpbGwgYmVcbiAgICAgaGl0IGluIGZvbGxvd2luZyBjYWxscyB0byBnZXRQcmV2aW91b3NOb2RlIGFzIGl0IGdvZXMgdXAgdGhlIHRyZWUgYWdhaW4uICBUaGlzIGlzIG5lZWRlZCB0b1xuICAgICByZW1vdmUgYWJpcXVpdHkgb2YgZGlyZWN0aW9uIHRvIHN0ZXAgKHdoZW4gZ2l2ZW4gbm9kZSB3aXRoIGRvd24gYW5kIGxlZnQsIGFzc3VtZSBhbHdheXMgY2FtZVxuICAgICBmcm9tIHRoZSBvbmUgYmVsb3cpLlxuICAgICBwX2FOb2RlIGdpdmVzIHRoZSBzdGFydCBub2RlXG4gICAgIHBfYkdvQnlTdHlsZSBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1vdmUgc2hvdWxkIG9ubHkgZ28gb3ZlciBzdHlsZSBlbGVtZW50cywgc3RvcHBpbmcgd2hlbiBoaXRzIGFueXRoaW5nIGVsc2VcbiAgICAgKG5lZWRlZCBoZXJlIHJhdGhlciBjaGVja2VkIGJ5IGNhbGxlciwgYXMgY2FsbGVyIHdvbnQga25vdyBpZiBlbGVtZW50cyBqdW1wZWQgb24gYSAnbGVmdCBhbmQgZG93bicgbW92ZSlcbiAgICAgcF9iRW5kTm9kZSAtIGlmIG5vdCBudWxsIHRoZW4gY2hlY2sgaWYgbm9kZSBtYXRjaGVzIHRoZSBlbmQgbm9kZSxcbiAgICAgaWYgcGFzcyBpbiBwX25vZGUgdGhhdCBtYXRjaGVzIGVuZCBub2RlIHRoZW4gcmV0dXJuIG51bGwgaXMgbm8gbmV4dFxuICAgICBob3dldmVyIGlmIG1vdmVzIHRvIHRoZSBlbmQgbm9kZSB0aGVuIHJldHVybiB0aGF0IGFzIGFsbG93ZWQgdG8gbW92ZSB0byBuZXh0IHRoYXQgaXMgZW5kIG5vZGUsIGp1c3QgZG9udCB3YW50IHRvIGdvIHBhc3QgaXRcbiAgICAgaWYgaXQgZG9lcyB0aGVuIGJyZWFrIGZyb20gd2hpbGUgbG9vcCBhbmQgcmV0dXJuIHRoYXQsIGlmIGludmFsaWQgcmV0dXJuIG51bGwuXG5cbiAgICAgcmV0dXJucyBhIG5vZGUuICBudWxsIGlmIG5vIGxlZnQgbm9kZSBmb3VuZCAoZWl0aGVyIHRvIGJlaW5nIGF0IHN0YXJ0IG9yIGR1ZSB0byBwX2JHb0J5U3R5bGUgb3IgZW5kIG5vZGUuXG4gICAgICovXG4gICAgZ2V0UHJldmlvdXNOb2RlIChwX25vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlKVxuICAgIHtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIGlmKHBfbm9kZSA9PSBudWxsIHx8IHBfbm9kZSA9PSBwX2VuZE5vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnROb2RlID0gcF9ub2RlO1xuICAgICAgICAvLyBjaGVjayBpZiBjYW4gZ28gbGVmdFxuICAgICAgICBpZiAobGVmdE5vZGUucHJldmlvdXNTaWJsaW5nICE9IG51bGwpXG4gICAgICAgIHsgICAvLyBtb3ZlIGxlZnRcbiAgICAgICAgICAgIGxlZnROb2RlID0gbGVmdE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgaWYocF9iR29CeVN0eWxlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKCFzc2RvbS5pc1N0eWxlTm9kZShsZWZ0Tm9kZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGxlZnROb2RlICE9IG51bGwgJiYgc3Nkb20uaXNJbnZhbGlkTm9kZShsZWZ0Tm9kZSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYocF9lbmROb2RlID09IGxlZnROb2RlKVxuICAgICAgICAgICAgICAgIHsgICAvLyBkb24ndCBnbyBwYXN0IGFuZCBkbyBub3Qgd2FudCB0byByZXR1cm4gYW4gaW52YWxpZCBub2RlIHNvIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0Tm9kZSA9IHRoaXMuZ2V0UHJldmlvdXNOb2RlKGxlZnROb2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9tb3ZlIHRvIGVuZCBvZiBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgICAgIC8vSWYgZmluZCBhIG5vZGUgdGhhdCBpcyBub3QgaW52YWxpZCBvciBub24gc3R5bGUgdHlwZSwgZG8gbm90IG5lZWQgdG8gY2hlY2sgaWYgaXMgZW5kIG5vZGVcbiAgICAgICAgICAgICAgICAvLyBhcyBldmVuIGlmIGlzIGJlaGF2aW91ciBpcyB0byBqdXN0IHJldHVybiB0aGUgbm9kZSwgd2hpY2ggd2lsbCBoYXBwZW4gYW55d2F5LFxuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgZm9yIGVuZCBub2RlIHdoZW4gYWx0ZXJuYXRpdmUgaXMgdG8gY29udGludWUgbG9va2luZyB0byBwcmV2aW91cyBub2RlIHZpYSBuZXcgbWV0aG9kIGNhbGwuXG5cbiAgICAgICAgICAgICAgICB3aGlsZShsZWZ0Tm9kZSAhPSBudWxsICYmIGxlZnROb2RlLmxhc3RDaGlsZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoc3Nkb20uaXNTcGVjaWFsQ2FzZVdpdGhJZ25vcmVkQ29udGVudChsZWZ0Tm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvLyBkb24ndCBnbyB0byBjaGlsZCBvZiB0aGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZWZ0Tm9kZSA9IGxlZnROb2RlLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgaWYocF9iR29CeVN0eWxlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighc3Nkb20uaXNTdHlsZU5vZGUobGVmdE5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnROb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHBhc3Mgc3R5bGUgY2hlY2sgYWxzbyB3YW50IHRvIGNoZWNrIGlmIGludmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIGlmKGxlZnROb2RlICE9IG51bGwgJiYgc3Nkb20uaXNJbnZhbGlkTm9kZShsZWZ0Tm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBfZW5kTm9kZSA9PSBsZWZ0Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgICAvLyBkb24ndCBnbyBwYXN0IGFuZCBkbyBub3Qgd2FudCB0byByZXR1cm4gYW4gaW52YWxpZCBub2RlIHNvIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0Tm9kZSA9IHRoaXMuZ2V0UHJldmlvdXNOb2RlKGxlZnROb2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGxlZnROb2RlICE9IG51bGwgJiYgc3Nkb20uaXNJZ25vcmVkKGxlZnROb2RlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGxlZnROb2RlID09IHBfZW5kTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGRvbid0IGdvIHBhc3QgYW5kIGRvIG5vdCB3YW50IHRvIHJldHVybiBhbiBpZ25vcmVkIG5vZGUgc28gcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdE5vZGUgPSB0aGlzLmdldFByZXZpb3VzTm9kZShsZWZ0Tm9kZSwgcF9iR29CeVN0eWxlLCBwX2VuZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gbW92ZSB1cFxuICAgICAgICAgICAgLy8gTm90IGNoZWNraW5nIGZvciBpbnZhbGlkIGhlcmUgYXMgc2hvdWxkIG5ldmVyIGdldCB0byBzdWIgY2hpbGQgb2YgaW52YWxpZCBub2RlLlxuXG4gICAgICAgICAgICBsZWZ0Tm9kZSA9IGxlZnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZihwX2JHb0J5U3R5bGUgJiYgbGVmdE5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZighc3Nkb20uaXNTdHlsZU5vZGUobGVmdE5vZGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYobGVmdE5vZGUgIT0gbnVsbCAmJiBzc2RvbS5pc0lnbm9yZWQoKGxlZnROb2RlKSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYobGVmdE5vZGUgPT0gcF9lbmROb2RlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnROb2RlID0gdGhpcy5nZXRQcmV2aW91c05vZGUobGVmdE5vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVmdE5vZGU7XG4gICAgfTtcblxuICAgIC8qIFVzZSB0aGlzIHRvIGdldCB0aGUgYm90dG9tIGNoaWxkIHRleHQgbm9kZSBhdCBzdGFydCBvZiB0aGUgZWxlbWVudFxuICAgICB1c2luZyBzYW1lIHJ1bGVzIGZvciBpZ25vcmluZyBub2Rlcy5cbiAgICAgPGJyPlxuICAgICBwX25vZGUgdGhlIG5vZGUgdG8gZ2V0IGZpcnN0IGNoaWxkIG9mXG5cbiAgICAgcmV0dXJuIHRoZSBmaXJzdCB0ZXh0IG5vZGUgcmVhY2hlZCAsXG4gICAgIENvdWxkIGFsc28gYmUgaW1nIGVsZW1lbnQgd2l0aCBtc2dcbiAgICAgSWYgbm8gdmFsaWQgY2hpbGRyZW4gd2lsbCByZXR1cm4gaXRzZWxmLlxuICAgICBUaGlzIG1lYW5zIHRoZSByZXN1bHQgaXMgbm90IG5lY2Vzc2FyaWx5IGEgdGV4dCBub2RlLlxuXG4gICAgICovXG4gICAgZ2V0Rmlyc3RDaGlsZFRleHROb2RlIChwX25vZGUsIHBfYkFsbG93SW1nKVxuICAgIHtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKCk7XG4gICAgICAgIGlmKHBfbm9kZSA9PSBudWxsIHx8IHBfbm9kZS5maXJzdENoaWxkID09IG51bGwgfHwgc3Nkb20uaXNJbnZhbGlkTm9kZShwX25vZGUpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcF9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc3Nkb20uaXNTcGVjaWFsQ2FzZVdpdGhJZ25vcmVkQ29udGVudChwX25vZGUpKVxuICAgICAgICB7ICAgLy8gTm8gdmFsaWQgY2hpbGQgdGV4dCB0byBnbyB0byBhbmQgdGhpcyBpcyB0aGUgdG9wIGxldmVsIG5vZGUgc28gY2FuJ3QgZ28gdG8gbmV4dC5cbiAgICAgICAgICAgIHJldHVybiBwX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wTm9kZSA9IHBfbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZih0bXBOb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0bXBOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodG1wTm9kZS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBwX2JBbGxvd0ltZyAmJlxuICAgICAgICAgICAgdG1wTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJpbWdcIiAmJlxuICAgICAgICAgICAgYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZSh0bXBOb2RlLCBcIm1zZ1wiKSAhPSBudWxsICYmXG4gICAgICAgICAgICBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRtcE5vZGUsIFwibXNnXCIpLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0bXBOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaWYocF9iQWxsb3dJbWcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dFRleHROb2RlKHRtcE5vZGUsIGZhbHNlLCBwX25vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5leHRUZXh0Tm9kZU5vSW1nKHRtcE5vZGUsIGZhbHNlLCBwX25vZGUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLypVc2UgdGhpcyB0byBnZXQgZ3VhcmFudGVlZCB0ZXh0IG5vZGUgYW5kIG5vdCBpbWcgd2l0aCBtc2dcbiAgICAgKi9cbiAgICBnZXROZXh0VGV4dE5vZGVOb0ltZyAocF9ub2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSwgcF9iSW5jbHVkZUJsYW5rcylcbiAgICB7XG4gICAgICAgIHZhciByaWdodE5vZGUgPSAocF9iSW5jbHVkZUJsYW5rcyk/XG4gICAgICAgICAgICB0aGlzLmdldE5leHRUZXh0Tm9kZShwX25vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlKSA6XG4gICAgICAgICAgICB0aGlzLmdldE5leHRUZXh0Tm9kZU5vQmxhbmsocF9ub2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSk7XG5cbiAgICAgICAgd2hpbGUocmlnaHROb2RlICE9IG51bGwgJiZcbiAgICAgICAgICAgIHJpZ2h0Tm9kZS5ub2RlVHlwZSAhPSAzICYmXG4gICAgICAgICAgICByaWdodE5vZGUgIT0gcF9lbmROb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihyaWdodE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwibWF0aFwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYocmlnaHROb2RlLmlzTWF0aEpheClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJpZ2h0Tm9kZSA9IChwX2JJbmNsdWRlQmxhbmtzKT9cbiAgICAgICAgICAgICAgICB0aGlzLmdldE5leHRUZXh0Tm9kZShyaWdodE5vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5nZXROZXh0VGV4dE5vZGVOb0JsYW5rKHJpZ2h0Tm9kZSwgcF9iR29CeVN0eWxlLCBwX2VuZE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJpZ2h0Tm9kZTtcbiAgICB9O1xuXG4gICAgLyogVGhpcyBzY3JpcHQgZ2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIG5leHQgdGV4dCBub2RlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvbmUgcGFzc2VkIHRvIHRoZSBzY3JpcHRcbiAgICAgYnV0IG9ubHkgaWYgY29udGFpbnMgdXNlZnVsIHRleHQuXG5cbiAgICAgcF9ub2RlIHN0YXJ0IG5vZGUgdG8gbG9vayBmcm9tXG4gICAgIHBfYkdvQnlTdHlsZSBpZiB0cnVlIGtlZXAgbG9va2luZyB0aWxsIHJlYWNoIG5vbiBzdHlsZSBub2RlIChwYXNzZXMgYmFjayBvcmlnaW5hbCBvZiBub3RoaW5nIGZvdW5kKVxuICAgICBwX2VuZE5vZGUsIGEgbm9kZSB0byBub3QgZ28gcGFzdCBhbmQgbm90IHRvIGJlIGluY2x1ZGVkIGFzIGEgcmV0dXJuIG5vZGVcblxuICAgICBSZXR1cm4gZWl0aGVyIGEgdGV4dCBub2RlIHRoYXQgaXMgbm90IGJsYW5rIG9yIG51bGxcbiAgICAgKi9cbiAgICBnZXROZXh0VGV4dE5vZGVOb0JsYW5rIChwX25vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIHZhciByaWdodE5vZGUgPSBwX25vZGU7XG5cbiAgICAgICAgd2hpbGUocmlnaHROb2RlICE9IG51bGwgJiYgcmlnaHROb2RlICE9IHBfZW5kTm9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmlnaHROb2RlID0gdGhpcy5nZXROZXh0VGV4dE5vZGUocmlnaHROb2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSk7XG5cbiAgICAgICAgICAgIGlmKHJpZ2h0Tm9kZSAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vRWl0aGVyIHRleHQgbm9kZSBvciBtc2cgaW1nXG4gICAgICAgICAgICAgICAgdmFyIHN0clRvQ2hlY2s7XG4gICAgICAgICAgICAgICAgaWYocmlnaHROb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdHJUb0NoZWNrID0gcmlnaHROb2RlLm5vZGVWYWx1ZS50cmltVEgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYocmlnaHROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImltZ1wiICYmIGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocmlnaHROb2RlLCBcIm1zZ1wiKSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJUb0NoZWNrID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShyaWdodE5vZGUsIFwibXNnXCIpLnRyaW1USCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYocmlnaHROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcIm1hdGhcIilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyVG9DaGVjayA9IHRoaXMuZ2V0VGV4dEZyb21NYXRoTWwocmlnaHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHJpZ2h0Tm9kZS5pc01hdGhKYXgpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRoU3BlYWsgPSBuZXcgTWF0aFNwZWFrKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0clRvQ2hlY2sgPSBtYXRoU3BlYWsuZ2V0VGV4dEZyb21NYXRoSmF4KHJpZ2h0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihzc2RvbS5yd19pc1dvcmRTcGVha2FibGUoc3RyVG9DaGVjaykpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcF9ub2RlIHNob3VsZCBiZSBtYXRobWwgbm9kZVxuICAgICAqL1xuICAgIGdldFRleHRGcm9tTWF0aE1sIChwX25vZGUpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgLy8gaWYgaGFzIHByZXYgb3IgbmV4dCBuZWVkIG90aGVyIGxvZ2ljLlxuICAgICAgICBpZihwX25vZGUucHJldmlvdXNTaWJsaW5nICE9IG51bGwgfHwgcF9ub2RlLm5leHRTaWJsaW5nICE9IG51bGwpXG4gICAgICAgIHsgICAvLyBtb3ZlIGRvd24gbGV2ZWxcbiAgICAgICAgICAgIHZhciBzcGFuRWwgPSBzc2RvbS5jcmVhdGVXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgICAgICAgcF9ub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHNwYW5FbCwgcF9ub2RlKTtcbiAgICAgICAgICAgIHNwYW5FbC5hcHBlbmRDaGlsZChwX25vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnX2JJRSA9IGZhbHNlO1xuICAgICAgICBpZihnX2JJRSlcbiAgICAgICAge1xuXG4gICAgICAgICAgICB2YXIgc3RyTUwgPSBwX25vZGUub3V0ZXJIVE1MO1xuICAgICAgICAgICAgaWYoc3RyTUwgPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihzdHJNTC5pbmRleE9mKFwiPD9pbXBvcnQgbmFtZXNwYWNlXCIpID4gLTEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHN0ck1MLmluZGV4T2YoXCIvPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYobiA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJNTCA9IHN0ck1MLnN1YnN0cmluZyhuICsgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJNTCA9IHN0ck1MLnJlcGxhY2UoL206L2dpLFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ck1MO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuXG4gICAgICAgICAgICB2YXIgc3RyTUwgPSBwX25vZGUucGFyZW50Tm9kZS5pbm5lckhUTUw7XG4gICAgICAgICAgICBpZihzdHJNTCAhPSBudWxsICYmIHN0ck1MLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ck1MO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIFRoaXMgc2NyaXB0IGdldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHRleHQgbm9kZSBvZiB0aGUgb25lIHBhc3NlZCB0byB0aGUgc2NyaXB0XG4gICAgIFRoaXMgd2lsbCBnaXZlIHRoZSB0ZXh0IG5vZGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGN1cnJlbnQgbm9kZSBpZiBtYXRjaCBmb3VuZCBhbmRcbiAgICAgd2lsbCBpbmNsdWRlIGltZyBlbGVtZW50cyB3aXRoIG1zZyB0ZXh0LlxuXG4gICAgIHBfbm9kZSBzdGFydCBub2RlIHRvIGxvb2sgZnJvbVxuICAgICBwX2JHb0J5U3R5bGUgaWYgdHJ1ZSB0aGVuIHN0b3AgaWYgaGl0IG5vbiBzdHlsZSBub2RlXG4gICAgIHBfZW5kTm9kZSwgYSBub2RlIHRvIG5vdCBnbyBwYXN0LCBpZiBtb3ZlIHRvIHRoaXMgbm9kZSB3aWxsIHJldHVybiB0aGF0IGlmIHZhbGlkIGFuZCBnbyBubyBmdXJ0aGVyXG5cbiAgICAgcmV0dXJuIG5leHQgdGV4dCBub2RlIG9yIG51bGwgaWYgbm8gbmV4dCB0ZXh0IG5vZGUgb3IgaXQgbm9uIHN0eWxlIG9yIGVuZCBub2RlXG4gICAgICovXG4gICAgZ2V0TmV4dFRleHROb2RlIChwX25vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgdmFyIHJpZ2h0Tm9kZSA9IHBfbm9kZTtcbiAgICAgICAgdmFyIGJNYXRjaCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIE5vdGUgcmlnaHROb2RlIGNvdWxkIGVxdWFsIGVuZCBub2RlIGZyb20gcmV0dXJuIGZyb20gZ2V0IG5leHQgTm9kZVxuICAgICAgICAvLyBva2F5IHRvIHJldHVybiB0aGlzIGlmIGEgbWF0Y2gsIGJ1dCBkbyBub3Qgd2FudCB0byBzZWFyY2ggb24gcGFzdCB0aGlzIHRvIG5leHQgbm9kZS5cblxuICAgICAgICB3aGlsZSAocmlnaHROb2RlICE9IG51bGwgJiYgcmlnaHROb2RlICE9IHBfZW5kTm9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmlnaHROb2RlID0gdGhpcy5nZXROZXh0Tm9kZShyaWdodE5vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlKTtcblxuICAgICAgICAgICAgaWYocmlnaHROb2RlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0Tm9kZS5ub2RlVHlwZSA9PSAzICYmXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Tm9kZS5wYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPSBcInRleHRhcmVhXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihyaWdodE5vZGUubm9kZVZhbHVlLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmlnaHROb2RlLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgcmlnaHROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcIm1hdGhcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0Tm9kZS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Tm9kZS5pc01hdGhKYXgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHJpZ2h0Tm9kZS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJpbWdcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBBdHRyID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShyaWdodE5vZGUsIFwibXNnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG1wQXR0ciAhPSBudWxsICYmIHRtcEF0dHIubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGJNYXRjaClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLypSZXR1cm5zIHRoZSBuZXh0IG5vZGUuPGJyPlxuICAgICBUaGlzIGluY2x1ZGVzIGNoaWxkIG5vZGVzIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZHJlbiBpdCB3aWxsIG1vdmUgdG8gdGhlIHJpZ2h0LlxuICAgICBJZiB0aGUgbm9kZSBoYXMgbm8gbm9kZXMgdG8gdGhlIHJpZ2h0IGl0IHdpbGwgbW92ZSB1cCB1bnRpbCBpdCBjYW4gbW92ZSB0byB0aGUgcmlnaHRcblxuICAgICBUaGUgbm9kZXMgc2tpcHBlZCB3aWxsIGhhdmUgYmVlbiBpbiBwcmV2aW91cyBjYWxscyB0byBnZXROZXh0Tm9kZSBhcyBpdCBjYW1lIGRvd24gdGhlIHRyZWUuXG4gICAgIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSBhbWJpZ3VpdHkgb2YgZGlyZWN0aW9uIHRvIHN0ZXBcbiAgICAgKHdoZW4gZ2l2ZW4gbm9kZSB3aXRoIGRvd24sIGFzc3VtZSBpcyBvbiB3YXkgZG93bikuIDxwPlxuICAgICBwX2FOb2RlIGdpdmVzIHRoZSBzdGFydCBub2RlICAgICAgICA8YnI+XG4gICAgIHBfYkdvQnlTdHlsZSBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1vdmUgc2hvdWxkIG9ubHkgZ28gb3ZlciBzdHlsZSBlbGVtZW50cyxcbiAgICAgc3RvcHBpbmcgd2hlbiBoaXRzIGFueXRoaW5nIGVsc2VcbiAgICAgKG5lZWRlZCBoZXJlIHJhdGhlciBjaGVja2VkIGJ5IGNhbGxlciwgYXMgY2FsbGVyIHdvbnQga25vdyBpZiBlbGVtZW50cyBqdW1wZWQgb24gYW4gdXAgYW5kIHJpZ2h0IG1vdmUpICAgIDxicj5cbiAgICAgcF9iRW5kTm9kZSAtIGlmIG5vdCBudWxsIHRoZW4gY2hlY2sgaWYgbm9kZSBtYXRjaGVzIHRoZSBlbmQgbm9kZSxcbiAgICAgaWYgcGFzcyBpbiBwX25vZGUgdGhhdCBtYXRjaGVzIGVuZCBub2RlIHRoZW4gcmV0dXJuIG51bGwgYXMgbm8gbmV4dFxuICAgICBob3dldmVyIGlmIG1vdmVzIHRvIHRoZSBlbmQgbm9kZSB0aGVuIHJldHVybiB0aGF0IGFzIGFsbG93ZWQgdG8gbW92ZSB0byBuZXh0IHRoYXQgaXMgZW5kIG5vZGUsIGp1c3QgZG9udCB3YW50IHRvIGdvIHBhc3QgaXRcbiAgICAgaWYgaXQgZG9lcyB0aGVuIGJyZWFrIGZyb20gd2hpbGUgbG9vcCBhbmQgcmV0dXJuIHRoYXQsIGlmIGludmFsaWQgcmV0dXJuIG51bGwuXG5cbiAgICAgcmV0dXJucyBhIG5vZGUuICBudWxsIGlmIG5vIHJpZ2h0IG5vZGUgZm91bmQgKGVpdGhlciB0byBiZWluZyBhdCBlbmQgb3IgZHVlIHRvIHBfYkdvQnlTdHlsZSBvciBlbmQgbm9kZSkuXG4gICAgICovXG4gICAgZ2V0TmV4dE5vZGUgKHBfbm9kZSwgcF9iR29CeVN0eWxlLCBwX2VuZE5vZGUpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZXh0Tm9kZUltcGwocF9ub2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgLypSZXR1cm5zIHRoZSBuZXh0IG5vZGUuPGJyPlxuICAgICBUaGlzIGluY2x1ZGVzIGNoaWxkIG5vZGVzIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZHJlbiBpdCB3aWxsIG1vdmUgdG8gdGhlIHJpZ2h0LlxuICAgICBJZiB0aGUgbm9kZSBoYXMgbm8gbm9kZXMgdG8gdGhlIHJpZ2h0IGl0IHdpbGwgbW92ZSB1cCB1bnRpbCBpdCBjYW4gbW92ZSB0byB0aGUgcmlnaHRcblxuICAgICBUaGUgbm9kZXMgc2tpcHBlZCB3aWxsIGhhdmUgYmVlbiBpbiBwcmV2aW91cyBjYWxscyB0byBnZXROZXh0Tm9kZSBhcyBpdCBjYW1lIGRvd24gdGhlIHRyZWUuXG4gICAgIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSBhbWJpZ3VpdHkgb2YgZGlyZWN0aW9uIHRvIHN0ZXBcbiAgICAgKHdoZW4gZ2l2ZW4gbm9kZSB3aXRoIGRvd24sIGFzc3VtZSBpcyBvbiB3YXkgZG93bikuIDxwPlxuICAgICBwX2FOb2RlIGdpdmVzIHRoZSBzdGFydCBub2RlICAgICAgICA8YnI+XG4gICAgIHBfYkdvQnlTdHlsZSBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1vdmUgc2hvdWxkIG9ubHkgZ28gb3ZlciBzdHlsZSBlbGVtZW50cyxcbiAgICAgc3RvcHBpbmcgd2hlbiBoaXRzIGFueXRoaW5nIGVsc2VcbiAgICAgKG5lZWRlZCBoZXJlIHJhdGhlciBjaGVja2VkIGJ5IGNhbGxlciwgYXMgY2FsbGVyIHdvbnQga25vdyBpZiBlbGVtZW50cyBqdW1wZWQgb24gYW4gdXAgYW5kIHJpZ2h0IG1vdmUpICAgIDxicj5cbiAgICAgcF9iRW5kTm9kZSAtIGlmIG5vdCBudWxsIHRoZW4gY2hlY2sgaWYgbm9kZSBtYXRjaGVzIHRoZSBlbmQgbm9kZSxcbiAgICAgaWYgcGFzcyBpbiBwX25vZGUgdGhhdCBtYXRjaGVzIGVuZCBub2RlIHRoZW4gcmV0dXJuIG51bGwgYXMgbm8gbmV4dFxuICAgICBob3dldmVyIGlmIG1vdmVzIHRvIHRoZSBlbmQgbm9kZSB0aGVuIHJldHVybiB0aGF0IGFzIGFsbG93ZWQgdG8gbW92ZSB0byBuZXh0IHRoYXQgaXMgZW5kIG5vZGUsIGp1c3QgZG9udCB3YW50IHRvIGdvIHBhc3QgaXRcbiAgICAgaWYgaXQgZG9lcyB0aGVuIGJyZWFrIGZyb20gd2hpbGUgbG9vcCBhbmQgcmV0dXJuIHRoYXQsIGlmIGludmFsaWQgcmV0dXJuIG51bGwuXG4gICAgIHBfYkRlZmVyRW5kTm9kZUNoZWNrIC0gdXNlZCBpZiB3YW50IHRoZSBmaXJzdCBwYXNzIHRvIGlnbm9yZSB0aGUgZW5kIG5vZGUgKGkuZS4gaWYgc3RhcnQgYW5kIGVuZCBub2RlIGFyZSBzYW1lIHN0aWxsIHdhbnQgdG8gY2hlY2sgdGhlIGNoaWxkKVxuICAgICBwX2JBbHdheXNJZ25vcmVDaGlsZCAtIG5ldmVyIGxvb2sgdG8gY2hpbGRcblxuICAgICByZXR1cm5zIGEgbm9kZS4gIG51bGwgaWYgbm8gcmlnaHQgbm9kZSBmb3VuZCAoZWl0aGVyIHRvIGJlaW5nIGF0IGVuZCBvciBkdWUgdG8gcF9iR29CeVN0eWxlIG9yIGVuZCBub2RlKS5cbiAgICAgKi9cbiAgICBnZXROZXh0Tm9kZUltcGwgKHBfbm9kZSwgcF9iR29CeVN0eWxlLCBwX2VuZE5vZGUsIHBfYkRlZmVyRW5kTm9kZUNoZWNrLCBwX2JBbHdheXNJZ25vcmVDaGlsZClcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICBpZihwX25vZGUgPT0gbnVsbCB8fCAocF9ub2RlID09IHBfZW5kTm9kZSAmJiAocF9iQWx3YXlzSWdub3JlQ2hpbGQgfHwgIXBfYkRlZmVyRW5kTm9kZUNoZWNrKSApKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiSW52YWxpZCA9IHNzZG9tLmlzSW52YWxpZE5vZGUocF9ub2RlKTtcblxuICAgICAgICBpZihzc2RvbS5pc1NwZWNpYWxDYXNlV2l0aElnbm9yZWRDb250ZW50KHBfbm9kZSkpXG4gICAgICAgIHsgICAvLyBtYXRoIG9yIHRleHRhcmVhIG9yIG1zZyBpbWdcbiAgICAgICAgICAgIGJJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByaWdodE5vZGUgPSBudWxsO1xuXG4gICAgICAgIGlmKHBfbm9kZSA9PSBwX2VuZE5vZGUgJiYgcF9iRGVmZXJFbmROb2RlQ2hlY2spXG4gICAgICAgIHsgICAvLyBjYW4gZ28gdG8gY2hpbGQsIGJ1dCBpZiBzdGFydGluZyBhdCBlbmQgbm9kZSwgY2FuIG9ubHkgZ28gdG8gY2hpbGQuXG4gICAgICAgICAgICBpZighYkludmFsaWQgJiYgcF9ub2RlLmZpcnN0Q2hpbGQgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByaWdodE5vZGUgPSBwX25vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHsgICAvLyBUaGUgbm9ybWFsIGNhc2VcbiAgICAgICAgICAgIHJpZ2h0Tm9kZSA9IHBfbm9kZTtcblxuICAgICAgICAgICAgaWYocmlnaHROb2RlLmZpcnN0Q2hpbGQgIT0gbnVsbCAmJiAhYkludmFsaWQgJiYgIXBfYkFsd2F5c0lnbm9yZUNoaWxkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJpZ2h0Tm9kZSA9IHJpZ2h0Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihyaWdodE5vZGUuZmlyc3RDaGlsZCAhPSBudWxsICYmIHBfYkFsd2F5c0lnbm9yZUNoaWxkICYmIHBfZW5kTm9kZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgc3Nkb20uY2hlY2tJZkVsZW1lbnRJbnNpZGVFbGVtZW50KHBfZW5kTm9kZSwgcmlnaHROb2RlKSlcbiAgICAgICAgICAgIHsgICAvLyBjYW5ub3QgdXNlIGVuZCBub2RlIG5vciBnbyBwYXN0IGl0LiAgICAgICAvL05PVEUsIGNhbm5vdCBzZWUgZXhhY3RseSB3aHkgdGhpcyBpcyBoZXJlIGJ1dCB3YXMgYWRkZWQgYXMgYnVnIGZpeCwgYnV0IGRvbid0IGtub3cgd2hhdCB0aGUgYnVnIHdhcyBvciBob3cgdGhpcyBmaXhlcyBpdC4gIE5lZWQgdG8gc2VlIGlmIHRoaXMgY2FuIGJlIHJlbW92ZWQgc2FmZWx5LlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZihyaWdodE5vZGUubmV4dFNpYmxpbmcgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByaWdodE5vZGUgPSByaWdodE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIC8vdXAgdG8gcmlnaHRcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmlnaHROb2RlICE9IG51bGwgJiYgcmlnaHROb2RlLm5leHRTaWJsaW5nID09IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByaWdodE5vZGUgPSByaWdodE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYocF9iR29CeVN0eWxlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighc3Nkb20uaXNTdHlsZU5vZGUocmlnaHROb2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKHBfZW5kTm9kZSA9PSByaWdodE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvLyBva2F5IHRvIG1vdmUgdG8gZW5kIG5vZGUgYnV0IG5vdCB0byBzdGFydCBhdCBpdCwgc28gcmV0dXJuIGVuZCBub2RlIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodE5vZGUgIT0gbnVsbCAmJiBwX2VuZE5vZGUgIT0gcmlnaHROb2RlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHROb2RlID0gcmlnaHROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJpZ2h0Tm9kZSAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihwX2JHb0J5U3R5bGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoIXNzZG9tLmlzU3R5bGVOb2RlKHJpZ2h0Tm9kZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByaWdodE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHJpZ2h0Tm9kZSAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihzc2RvbS5pc0ludmFsaWROb2RlKHJpZ2h0Tm9kZSkpXG4gICAgICAgICAgICB7ICAgLy9pbnZhbGlkIGxvb2sgdG8gbmV4dC5cbiAgICAgICAgICAgICAgICByaWdodE5vZGUgPSB0aGlzLmdldE5leHROb2RlSW1wbChyaWdodE5vZGUsIHBfYkdvQnlTdHlsZSwgcF9lbmROb2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHNzZG9tLmlzSWdub3JlZChyaWdodE5vZGUpKVxuICAgICAgICAgICAgeyAgIC8vaWdub3JlZCBsb29rIHRvIG5leHQuXG4gICAgICAgICAgICAgICAgcmlnaHROb2RlID0gdGhpcy5nZXROZXh0Tm9kZUltcGwocmlnaHROb2RlLCBwX2JHb0J5U3R5bGUsIHBfZW5kTm9kZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIGRlZmVycmVkIGVuZCBub2RlIGNoZWNrIHRoaXMgY291bGQgbW92ZSB0byB0aGUgZW5kIG5vZGUsIHNvIG5lZWQgdG8gYmxvY2sgdGhpcy5cbiAgICAgICAgICAgIGlmKHBfYkRlZmVyRW5kTm9kZUNoZWNrICYmIHJpZ2h0Tm9kZSA9PSBwX2VuZE5vZGUgJiYgcF9ub2RlID09IHBfZW5kTm9kZSlcbiAgICAgICAgICAgIHsgICAvLyBzdGFydCBhbmQgZW5kIHRoZSBzYW1lLCBhbmQgY2hpbGQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICByaWdodE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByaWdodE5vZGU7XG4gICAgfTtcbn1cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDAzLzA1LzIwMTYuXG4gKi9cbmltcG9ydCB7VXRpbGl0aWVzfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1V0aWxpdGllcy9VdGlsaXRpZXMnXG5pbXBvcnQge1NTRE9NfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9TU0RPTSdcbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9BdHRyaWJ1dGUnXG5pbXBvcnQge0RvbU5hdmlnYXRpb259IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL0RvbU5hdmlnYXRpb24nXG5pbXBvcnQge1RIQ2FyZXR9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhDYXJldCdcbmltcG9ydCB7VEhDYXJldFJhbmdlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIQ2FyZXRSYW5nZSdcblxuZXhwb3J0IGNsYXNzIERvbVNlbnRlbmNlc3tcbiAgICBjb25zdHJ1Y3Rvcigpe1xuXG4gICAgfVxuXG5cbiAgICAvKiBSZXR1cm5zIFRIQ2FyZXRSYW5nZSBmb3IgdGhlIGZpcnN0IHNlbnRlbmNlIGluIHRoZSBwYWdlIGZvciBhIGdpdmVuIGJvZHlcbiAgICAgKi9cbiAgICBnZXRTZW50ZW5jZUZyb21Qb2ludCAocF90aENhcmV0KVxuICAgIHtcbiAgICAgICAgdmFyIHJpZ2h0Q2FyZXQgPSB0aGlzLmdldFNlbnRlbmNlQnJlYWtUb1JpZ2h0KHBfdGhDYXJldCk7XG4gICAgICAgIHZhciBsZWZ0Q2FyZXQgPSB0aGlzLmdldFNlbnRlbmNlQnJlYWtUb0xlZnQocmlnaHRDYXJldCk7XG5cbiAgICAgICAgaWYobGVmdENhcmV0ID09IG51bGwgfHwgcmlnaHRDYXJldCA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPW5ldyBUSENhcmV0UmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0Q2FyZXRSYW5nZShsZWZ0Q2FyZXQsIHJpZ2h0Q2FyZXQpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcblxuICAgIC8qR2V0IHRoZSBzZW50ZW5jZSBicmVhayBhZnRlciBwYXNzZWQgcmFuZ2UuXG4gICAgIHBfY2FyZXRSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGN1cnJlbnQgc2VudGVuY2UuXG4gICAgIHJldHVybnMgVEhDYXJldFJhbmdlXG4gICAgICovXG4gICAgZ2V0TmV4dFNlbnRlbmNlIChwX2NhcmV0UmFuZ2UsIHBfZW5kTm9kZSlcbiAgICB7XG4gICAgICAgIHZhciBkb21OYXYgPSBuZXcgRG9tTmF2aWdhdGlvbigpO1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgaWYocF9jYXJldFJhbmdlID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodHlwZW9mKHBfZW5kTm9kZSkgPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgcF9lbmROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJOb2RlID0gcF9jYXJldFJhbmdlLnJpZ2h0Q2FyZXQubm9kZTtcbiAgICAgICAgdmFyIGN1ck9mZnNldCA9IHBfY2FyZXRSYW5nZS5yaWdodENhcmV0Lm9mZnNldDtcbiAgICAgICAgaWYgKHNzZG9tLnJ3X2NoZWNrRm9ySGlkZGVuUGFyZW50KHBfY2FyZXRSYW5nZS5yaWdodENhcmV0Lm5vZGUpKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZihwX2NhcmV0UmFuZ2UucmlnaHRDYXJldC5pc1NwZWNpYWxDYXNlKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN1ck5vZGUgPSBkb21OYXYuZ2V0TmV4dE5vZGVJZ25vcmVDaGlsZHJlbihjdXJOb2RlLCBmYWxzZSwgcF9lbmROb2RlKTtcbiAgICAgICAgICAgIGN1ck9mZnNldCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmlnaHRDYXJldDtcbiAgICAgICAgdmFyIGxlZnRDYXJldDtcblxuICAgICAgICB3aGlsZShjdXJOb2RlICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGluIGEgdGV4dCBub2RlIGFuZCBvZmZzZXQgbm90IGF0IHRoZSBlbmRcbiAgICAgICAgICAgIGlmKGN1ck5vZGUubm9kZVR5cGUgPT0gMyAmJlxuICAgICAgICAgICAgICAgIGN1ck9mZnNldCA8IGN1ck5vZGUubm9kZVZhbHVlLmxlbmd0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggZnJvbSB3aXRoaW4gY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgcmlnaHRDYXJldCA9IHRoaXMuZ2V0U2VudGVuY2VCcmVha1RvUmlnaHQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUSENhcmV0KGN1ck5vZGUsIGN1ck9mZnNldCwgZmFsc2UpLCBwX2VuZE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYocmlnaHRDYXJldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgcmV0dXJucyBzYW1lIHBvaW50LCBhdCBwYXJhZ3JhcGggYnJlYWsgdGhpcyB3aWxsIG5vdCBnZXQgdG8gbmV4dFxuICAgICAgICAgICAgICAgIGlmKHJpZ2h0Q2FyZXQubm9kZSA9PSBjdXJOb2RlICYmIHJpZ2h0Q2FyZXQub2Zmc2V0ID09IGN1ck9mZnNldClcbiAgICAgICAgICAgICAgICB7ICAgLy8gbmVlZCB0byBmb3JjZSBtb3ZlIHRvIG5leHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wVGV4dCA9IGRvbU5hdi5nZXROZXh0VGV4dE5vZGVOb0JsYW5rKGN1ck5vZGUsIGZhbHNlLCBwX2VuZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZih0bXBUZXh0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2FyZXQgPSB0aGlzLmdldFNlbnRlbmNlQnJlYWtUb1JpZ2h0KG5ldyBUSENhcmV0KHRtcFRleHQsIDAsIGZhbHNlKSwgcF9lbmROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7ICAgLy8gaWYgZWl0aGVyIG5vdCBhIHRleHQgbm9kZSBvciBhdCBlbmQgb2Ygbm9kZSBzbyBuZWVkIHRvIG1vdmUgdG8gbmV4dFxuICAgICAgICAgICAgICAgIHZhciB0bXBUZXh0ID0gZG9tTmF2LmdldE5leHRUZXh0Tm9kZU5vQmxhbmsoY3VyTm9kZSwgZmFsc2UsIHBfZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYodG1wVGV4dCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJpZ2h0Q2FyZXQgPSB0aGlzLmdldFNlbnRlbmNlQnJlYWtUb1JpZ2h0KG5ldyBUSENhcmV0KHRtcFRleHQsIDAsIGZhbHNlKSwgcF9lbmROb2RlKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBsZWZ0Q2FyZXQgPSB0aGlzLmdldFNlbnRlbmNlQnJlYWtUb0xlZnQocmlnaHRDYXJldCwgbnVsbCk7XG4gICAgICAgICAgICBpZihsZWZ0Q2FyZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGlzIGlzIG5vdCBzYW1lIGFzIGN1cnJlbnQgbGVmdENhcmV0XG4gICAgICAgICAgICBpZihwX2NhcmV0UmFuZ2UubGVmdENhcmV0Lm5vZGUgIT0gbGVmdENhcmV0Lm5vZGUgfHxcbiAgICAgICAgICAgICAgICBwX2NhcmV0UmFuZ2UubGVmdENhcmV0Lm9mZnNldCAhPSBsZWZ0Q2FyZXQub2Zmc2V0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0aENhcmV0UmFuZ2UgPSBuZXcgVEhDYXJldFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgdGhDYXJldFJhbmdlLnNldENhcmV0UmFuZ2UobGVmdENhcmV0LCByaWdodENhcmV0KTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNoZWNrU2VudGVuY2UodGhDYXJldFJhbmdlKSAmJiBzc2RvbS5yd19jYXJldFJhbmdlSXNTcGVha2FibGUodGhDYXJldFJhbmdlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aENhcmV0UmFuZ2UgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZWxzZSBuZWVkIHRvIGtlZXAgbG9va2luZ1xuICAgICAgICAgICAgY3VyTm9kZSA9IHJpZ2h0Q2FyZXQubm9kZTtcblxuICAgICAgICAgICAgaWYoY3VyTm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgeyAgIC8vIHNldCB1cCBuZXh0IGxvb3Agc28gdGhhdCBzZWFyY2ggZnJvbSByaWdodCBwb2ludC4gaS5lLiBhIGZ1bGwgc3RvcCBhZnRlciB0aGUgbGFzdCBicmVhayBwb2ludFxuICAgICAgICAgICAgICAgIHZhciB0bXBUeHQgPSBjdXJOb2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC9bXFx4MjFcXHgzZlxceDNhXS9nLCBcIi5cIik7ICAgLy8gY2hhbmdlICE/OiB0byAuXG4gICAgICAgICAgICAgICAgdmFyIG5MYXN0UG9zID0gdG1wVHh0LmluZGV4T2YoXCIuXCIsIHJpZ2h0Q2FyZXQub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYobkxhc3RQb3MgPT0gLTEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdXJPZmZzZXQgPSB0bXBUeHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdXJPZmZzZXQgPSBuTGFzdFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgLy8gY3VyT2Zmc2V0IGlycmVsZXZhbnQgaWYgbm90IHRleHQgbm9kZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBpcyB2YWxpZCBzZW50ZW5jZSB0byByZWFkIHRoYXQgaXMgbm90IGZyb20gb25lIG9mIG91ciBjb250cm9scy5cbiAgICAgKiAoV2hlbiBuYXZpZ2F0aW5nIHRocm91Z2ggYSBwYWdlIGl0IGNhbiByZWFjaCB0aGUgY29tcG9uZW50cyB0aGF0IHdlIGhhdmUgYWRkZWQsXG4gICAgICogdGhlc2Ugc2hvdWxkIG5vdCBiZSByZWFjaGVkIGJ5IG5leHQgb3IgcHJldmlvdXMgb3IgZmlyc3Qgc2VudGVuY2UgY2FsbHMgZXZlcilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwX2NhcmV0UmFuZ2UgVEhDYXJldFJhbmdlXG4gICAgICpcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGNoZWNrU2VudGVuY2UocF9jYXJldFJhbmdlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZT0gbmV3IEF0dHJpYnV0ZSgpO1xuICAgICAgICB2YXIgUldUSF9DT01QT05FTlQgPSBcInJ3VEhjb21wXCIrXCJcIlxuICAgICAgICAvLyBDaGVjayBmaXJzdCBhbmQgbGFzdCBmb3IgYmVpbmcgY29tcG9uZW50IG9yIHN1YmNvbXBvbmV0IHdpdGggYXR0cmlidXRlIHJ3dGhjb21wXG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBwX2NhcmV0UmFuZ2UubGVmdENhcmV0Lm5vZGU7XG4gICAgICAgIHZhciBib2QgPSBzdGFydE5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICAgICAgICB3aGlsZShzdGFydE5vZGUgIT0gbnVsbCAmJiBzdGFydE5vZGUgIT0gYm9kKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihzdGFydE5vZGUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihzdGFydE5vZGUuY2xhc3NOYW1lID09IFwicndEaWN0RGVmaW5cIiB8fFxuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUuY2xhc3NOYW1lID09IFwicndQb3B1cENvbnRlbnRcIiB8fFxuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUuY2xhc3NOYW1lID09IFwicndUb29sYmFyQmFyQ29sbGVjdFwiKVxuICAgICAgICAgICAgICAgIHsvLyBhbGxvdyBjb250aW51b3VzIHJlYWRpbmcgZXZlbiBpZiBpbiBkaWN0aW9uYXJ5IGNvbXBvbmVudCwgb3IgYW55IHBvcHVwIGNvbnRlbnQsIG9yIGNvbGxlY3QgaGlnaGxpZ2h0XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIHRvbyBicm9hZC4gIFN0b3BzIGFsbCBjb250aW51b3VzIGluc2lkZSBhcyB3ZWxsIGFzIGluIGVudGVyaW5nIGxlYXZpbmcuXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBjaGFuZ2UgYWxsIG92ZXIgdG8gaGF2aW5nIHN0b3BzIGF0IHRoZSBzdGFydCBhbmQgZW5kIHJhdGhlciB0aGFuIGJsb2NraW5nIGFsbCBjb250aW51b3VzXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgIGlmKGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUoc3RhcnROb2RlLCBSV1RIX0NPTVBPTkVOVCkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmROb2RlID0gcF9jYXJldFJhbmdlLnJpZ2h0Q2FyZXQubm9kZTtcbiAgICAgICAgaWYoZW5kTm9kZSAhPSBzdGFydE5vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdoaWxlKGVuZE5vZGUgIT0gbnVsbCAmJiBlbmROb2RlICE9IGJvZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihlbmROb2RlLmNsYXNzTmFtZSA9PSBcInJ3RGljdERlZmluXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgZW5kTm9kZS5jbGFzc05hbWUgPT0gXCJyd1BvcHVwQ29udGVudFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIGVuZE5vZGUuY2xhc3NOYW1lID09IFwicndUb29sYmFyQmFyQ29sbGVjdFwiKVxuICAgICAgICAgICAgICAgIHsvLyBhbGxvdyBjb250aW51b3VzIHJlYWRpbmcgZXZlbiBpZiBpbiBkaWN0aW9uYXJ5IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihlbmROb2RlLm5vZGVUeXBlID09IDEgJiYgYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShlbmROb2RlLCBSV1RIX0NPTVBPTkVOVCkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kTm9kZSA9IGVuZE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qR2V0IHRoZSBzZW50ZW5jZSBicmVhayBiZWZvcmUgcGFzc2VkIHBvaW50LlxuICAgICBwX2NhcmV0UmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBjdXJyZW50IHNlbnRlbmNlLlxuICAgICByZXR1cm5zIFRIQ2FyZXRSYW5nZVxuICAgICAqL1xuICAgIGdldFByZXZpb3VzU2VudGVuY2UgKHBfY2FyZXRSYW5nZSwgcF9lbmROb2RlKVxuICAgIHtcbiAgICAgICAgdmFyIGRvbU5hdiA9IG5ldyBEb21OYXZpZ2F0aW9uKCk7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICBpZih0eXBlb2YocF9lbmROb2RlKSA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB7XG4gICAgICAgICAgICBwX2VuZE5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1ck5vZGUgPSBwX2NhcmV0UmFuZ2UubGVmdENhcmV0Lm5vZGU7XG4gICAgICAgIHZhciBjdXJPZmZzZXQgPSBwX2NhcmV0UmFuZ2UubGVmdENhcmV0Lm9mZnNldDtcbiAgICAgICAgdmFyIGxlZnRDYXJldDtcbiAgICAgICAgdmFyIHJpZ2h0Q2FyZXQ7XG5cbiAgICAgICAgd2hpbGUoY3VyTm9kZSAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBmaW5kIHByZXZpb3VzIGZ1bGwgc3RvcC4gIEl0ZXJhdGUgYmFjayB0aHJvdWdoIHRleHQgbm9kZXMgdGlsbCBmaW5kIGl0LlxuICAgICAgICAgICAgLy8oTm90ZSBuZWVkIHRvIGZpbmQgZnVsbCBzdG9wIGRpcmVjdGx5IGFuZCBub3QgdXNlIGdldFNlbnRlbmNlQnJlYWtUb0xlZnQsXG4gICAgICAgICAgICAvL2FzIHRoYXQgZ2l2ZXMgYSBwb2ludCBhZnRlciB0aGUgZnVsbCBzdG9wIG9mIHVua25vd24gZGlzdGFuY2UgYWZ0ZXIgaXQgc28gd291bGQgbmVlZCB0aGlzIHNlYXJjaCBhbnl3YXkpXG4gICAgICAgICAgICBpZihjdXJOb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcFR4dCA9IGN1ck5vZGUubm9kZVZhbHVlLnJlcGxhY2UoL1tcXHgyMVxceDNmXFx4M2FdL2csIFwiLlwiKTsgICAvLyBjaGFuZ2UgIT86IHRvIC5cbiAgICAgICAgICAgICAgICB2YXIgbkxhc3RQb3M7XG4gICAgICAgICAgICAgICAgaWYoY3VyT2Zmc2V0ID4gMClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5MYXN0UG9zID0gdG1wVHh0Lmxhc3RJbmRleE9mKFwiLlwiLCBjdXJPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGN1ck9mZnNldCA9PSAwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYXQgc3RhcnQgc28gbmVlZCB0byBtb3ZlIHRvIHByZXZpb3VzIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgbkxhc3RQb3MgPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSAvLyAtMVxuICAgICAgICAgICAgICAgIHsgICAvLyBuZWVkIHRvIHNlYXJjaCBmdWxsIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBuTGFzdFBvcyA9IHRtcFR4dC5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUobkxhc3RQb3MgPiAtMSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN1ck9mZnNldCA9IG5MYXN0UG9zO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgdmFsaWQgYnJlYWsgcG9pbnQgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgcG9pbnQgdG8gcmlnaHQgb2YgaGVyZSB3aWxsIG1hdGNoIHRoZSBvbmUgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2FyZXQgPSB0aGlzLmdldFNlbnRlbmNlQnJlYWtUb1JpZ2h0KG5ldyBUSENhcmV0KGN1ck5vZGUsIGN1ck9mZnNldCwgdHJ1ZSksIHBfZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHJpZ2h0Q2FyZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihyaWdodENhcmV0Lm5vZGUgIT0gcF9jYXJldFJhbmdlLnJpZ2h0Q2FyZXQubm9kZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRDYXJldC5vZmZzZXQgIT0gcF9jYXJldFJhbmdlLnJpZ2h0Q2FyZXQub2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBwcmV2aW91cyBicmVhayBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdENhcmV0ID0gdGhpcy5nZXRTZW50ZW5jZUJyZWFrVG9MZWZ0KHJpZ2h0Q2FyZXQsIHBfZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihsZWZ0Q2FyZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhDYXJldFJhbmdlID0gbmV3IFRIQ2FyZXRSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhDYXJldFJhbmdlLnNldENhcmV0UmFuZ2UobGVmdENhcmV0LCByaWdodENhcmV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jaGVja1NlbnRlbmNlKHRoQ2FyZXRSYW5nZSkgJiYgc3Nkb20ucndfY2FyZXRSYW5nZUlzU3BlYWthYmxlKHRoQ2FyZXRSYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoQ2FyZXRSYW5nZSA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihuTGFzdFBvcyA9PSAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuTGFzdFBvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbkxhc3RQb3MgPSB0bXBUeHQubGFzdEluZGV4T2YoXCIuXCIsIG5MYXN0UG9zIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1ck9mZnNldCA9IC0xO1xuXG4gICAgICAgICAgICAvLyBmaXJzdCBzZWFyY2ggd2l0aG91dCBnb2luZyBwYXN0IG5vbiBzdHlsZSB0eXBlIG5vZGVzIHNvIGxvb2tpbmcgZm9yIHNwbGl0IHNlbnRlbmNlcyBpblxuICAgICAgICAgICAgLy8gc2FtZSBwYXJhZ3JhcGguICBJZiBnZXQgbnVsbCB0aGVuIG5lZWQgdG8gbW92ZSB0byBwcmV2aW91cyBzZWN0aW9uIGFuZCB1c2UgdGhhdFxuICAgICAgICAgICAgLy8gaS5lLiBNb3ZpbmcgZnJvbSBzcGFuIHRvIHRhYmxlIG9yIGRpZmZlcmVudCBwYXJhZ3JhcGggd2lsbCBnZXQgbnVsbCBvbiBmaXJzdCBjYWxsXG4gICAgICAgICAgICAvLyBUaGlzIHRlc3QgZG9lcyBub3QgbmVlZCB0byBsb29rIGZvciBpbWcgd2l0aCBtc2cgYXMgdGhpcyBpcyBuZXZlciBhIGJyZWFrLFxuICAgICAgICAgICAgLy8gb25seSBjb25zaWRlciBpZiBuZWVkIHRvIGdvIHBhc3QgYSBzdHlsZSBub2RlLCBhcyBtYXkgZ2V0IHRvIGEgc2VudGVuY2UgdGhhdCBvbmx5IGNvbnRhaW5zIGFuIGltZyB3aXRoIG1zZy5cbiAgICAgICAgICAgIHRtcE5vZGUgPSBkb21OYXYuZ2V0UHJldmlvdXNUZXh0Tm9kZU5vSW1nKGN1ck5vZGUsIHRydWUsIHBfZW5kTm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYodG1wTm9kZSAhPSBudWxsKVxuICAgICAgICAgICAgeyAgIC8vIGNhcnJ5IG9uIHRvIG5leHQgbG9vcFxuICAgICAgICAgICAgICAgIGN1ck5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEZvciB0aGlzIG5lZWQgdG8gY2hlY2sgZm9yIGltZyB3aXRoIG1zZ1xuICAgICAgICAgICAgICAgIGN1ck5vZGUgPSBkb21OYXYuZ2V0UHJldmlvdXNUZXh0Tm9kZU5vQmxhbmsoY3VyTm9kZSwgZmFsc2UsIHBfZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gQXMgbW92ZWQgYmFjayB0byBwcmV2aW91cyBwYXJhZ3JhcGgsIHRoYXQgY291bnRzIGFzIGEgc2VudGVuY2VcbiAgICAgICAgICAgICAgICAvLyBicmVhayBldmVuIGlmIHRoZXJlIGlzIG5vIGZ1bGwgc3RvcC5cbiAgICAgICAgICAgICAgICBpZihjdXJOb2RlICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihjdXJOb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2FyZXQgPSB0aGlzLmdldFNlbnRlbmNlQnJlYWtUb1JpZ2h0KG5ldyBUSENhcmV0KGN1ck5vZGUsIGN1ck5vZGUubm9kZVZhbHVlLmxlbmd0aCwgZmFsc2UpLCBwX2VuZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRDYXJldCA9IHRoaXMuZ2V0U2VudGVuY2VCcmVha1RvUmlnaHQobmV3IFRIQ2FyZXQoY3VyTm9kZSwgMCwgZmFsc2UpLCBwX2VuZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYocmlnaHRDYXJldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgdmFsaWQgYnJlYWsgcG9pbnQgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgcG9pbnQgdG8gcmlnaHQgb2YgaGVyZSB3aWxsIG1hdGNoIHRoZSBvbmUgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgICAgIGlmKHJpZ2h0Q2FyZXQubm9kZSAhPSBwX2NhcmV0UmFuZ2UucmlnaHRDYXJldC5ub2RlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodENhcmV0Lm9mZnNldCAhPSBwX2NhcmV0UmFuZ2UucmlnaHRDYXJldC5vZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvLyBhdCBwcmV2aW91cyBzZW50ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdENhcmV0ID0gdGhpcy5nZXRTZW50ZW5jZUJyZWFrVG9MZWZ0KHJpZ2h0Q2FyZXQsIHBfZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihsZWZ0Q2FyZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhDYXJldFJhbmdlKGxlZnRDYXJldCwgcmlnaHRDYXJldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9lbHNlIHNob3VsZCBuZXZlciBhY3R1YWxseSBnZXQgYW4gZWxzZSBoZXJlLCBidXQgaWYgZG9lcywgY2Fycnkgb24gbG9vcGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyogVXNlIHRoaXMgdG8gZ2V0IGxlZnQgYnJlYWsgcG9pbnQgYXMgYSBUSENhcmV0IDxicj5cbiAgICAgcF90aENhcmV0IHBvaW50IHRvIHN0YXJ0IGZyb21cbiAgICAgcF9lbmROb2RlIG9wdGlvbmFsIGlmIGhhdmUgYSBub2RlIGRvIG5vdCB3YW50IHRvIGdvIHBhc3RcbiAgICAgKi9cbiAgICBnZXRTZW50ZW5jZUJyZWFrVG9MZWZ0IChwX3RoQ2FyZXQsIHBfZW5kTm9kZSlcbiAgICB7XG4gICAgICAgIHZhciBkb21OYXYgPSBuZXcgRG9tTmF2aWdhdGlvbigpO1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgaWYodHlwZW9mKHBfZW5kTm9kZSkgPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgcF9lbmROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBfdGhDYXJldCA9PSBudWxsIHx8IHBfdGhDYXJldC5ub2RlID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBwX3RoQ2FyZXQubm9kZTtcbiAgICAgICAgdmFyIG5PZmZzZXQgPSBwX3RoQ2FyZXQub2Zmc2V0O1xuXG4gICAgICAgIGlmKHBfdGhDYXJldC5ub2RlLm5vZGVUeXBlID09IDEgJiYgcF90aENhcmV0Lm5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09XCJtYXRoXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwX3RoQ2FyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwX3RoQ2FyZXQubm9kZS5ub2RlVHlwZSA9PSAxICYmIHBfdGhDYXJldC5ub2RlLmlzTWF0aEpheClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBfdGhDYXJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBfdGhDYXJldC5mb3J3YXJkQmlhcylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYobm9kZS5ub2RlVHlwZSA9PSAzICYmXG4gICAgICAgICAgICAgICAgbk9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICB7ICAgLy8gbW92ZSB0byBhY3R1YWwgY2hhciB0aGUgY2FyZXQgaXMgcG9pbnRpbmcgZm9yd2FyZCB0byAoaWYgbm9kZSBlbmRlZCBpbiAuIHdvdWxkbid0IGhhdmUgbGFzdGNoYXIgdG8gY2hlY2sgYWdhaW5zdCBvdGhlcndpc2UpXG4gICAgICAgICAgICAgICAgbm9kZSA9IGRvbU5hdi5nZXROZXh0VGV4dE5vZGUobm9kZSwgdHJ1ZSwgcF9lbmROb2RlKTtcbiAgICAgICAgICAgICAgICBuT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBpZihub2RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgeyAgIC8vIHdpdGggbm8gbmV4dCBub2RlLCBzYWZlIHRvIHVzZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICBub2RlID0gcF90aENhcmV0Lm5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgPSBwX3RoQ2FyZXQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHsgICAvLyBhcyBlbmQgaXMgYWZ0ZXIgYnJlYWsgbmVlZCB0byBtb3ZlIGJhY2sgc3BhY2UgdG8gZmluZCBwcmV2aW91cyBvbmVcbiAgICAgICAgICAgIGlmKG5PZmZzZXQgPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC0tbk9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyByZWxhdGVzIHRvIGxhc3QgY2hhcmFjdGVyIG9mIHByZXZpb3VzIHRleHQgbm9kZSwgbmVlZCB0byBtb3ZlIHRvIHRoYXRcbiAgICAgICAgICAgICAgICBub2RlID0gZG9tTmF2LmdldFByZXZpb3VzVGV4dE5vZGUobm9kZSwgdHJ1ZSwgcF9lbmROb2RlKTtcbiAgICAgICAgICAgICAgICBpZihub2RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgeyAgIC8vIG5vIHByZXZpb3VzIHBvaW50IHRvIGdvIGJhY2sgdG9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBfdGhDYXJldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbk9mZnNldCA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7ICAgLy8gaXMgc3BlY2lhbCBjYXNlIChpLmUuIGltZyB3aXRoIHRleHQpLlxuICAgICAgICAgICAgICAgICAgICBuT2Zmc2V0ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIG1vdmVzIGJhY2sgdG8gYSBtYXRoIGVsZW1lbnQsIG5lZWQgdG8gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZihub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcIm1hdGhcIilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBfdGhDYXJldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgbW92ZXMgYmFjayB0byBhIG1hdGggZWxlbWVudCwgbmVlZCB0byBicmVhayBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGUuaXNNYXRoSmF4KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcF90aENhcmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiBpcyBhdCBhIGZ1bGwgc3RvcCBhbHJlYWR5XG4gICAgICAgIC8vIGxhc3RJbmRleE9mIGxvb2tzIGZyb20gYWZ0ZXIgY3VycmVudCBjaGFyYWN0ZXIgbm90ZSBiZWZvcmUgc28gaWYgYXQgYSAuXG4gICAgICAgIC8vIHdpbGwgZmluZCBzcG90IGl0IGlzIG9uIHJhdGhlciB0aGFuIGxvb2tpbmcgYmVmb3JlIGl0LlxuICAgICAgICBpZihub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBhQ2hhciA9IG5vZGUubm9kZVZhbHVlLmNoYXJBdChuT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmKGFDaGFyID09ICcuJyB8fCBhQ2hhciA9PSAnIScgfHxcbiAgICAgICAgICAgICAgICBhQ2hhciA9PSAnPycgfHwgYUNoYXIgPT0gJzonKVxuICAgICAgICAgICAgeyAgIC8vIG1vdmUgYmFjayBvbmUuXG4gICAgICAgICAgICAgICAgaWYobk9mZnNldCA+IDApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAtLW5PZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBkb21OYXYuZ2V0UHJldmlvdXNUZXh0Tm9kZShub2RlLCB0cnVlLCBwX2VuZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZihub2RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwX3RoQ2FyZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICB7ICAgLy8gZXZlbiBpZiBsZW5ndGggPSAwIHdpbGwgc3RpbGwgd29yayBkdWUgdG8gY2hlY2sgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbk9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIG1vdmVzIGJhY2sgdG8gYSBtYXRoIGVsZW1lbnQsIG5lZWQgdG8gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJtYXRoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBfdGhDYXJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5pc01hdGhKYXgpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBfdGhDYXJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZWROb2RlID0gbm9kZTtcbiAgICAgICAgdmFyIG1hdGNoZWRPZmZzZXQgPSBuT2Zmc2V0O1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBub2RlO1xuICAgICAgICB2YXIgbGVmdE9mZnNldCA9IG5PZmZzZXQ7XG5cbiAgICAgICAgLy8gY3ljbGUgdG8gcHJldmlvdXMgYnJlYWsgcG9pbnQuXG5cbiAgICAgICAgdmFyIGJGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBsYXN0Q2hhciA9ICcgJztcblxuICAgICAgICB3aGlsZSghYkZvdW5kKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihzc2RvbS5pc1NwZWNpYWxDYXNlTmVzdGVkKGxlZnROb2RlKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZWZ0Tm9kZSA9IHNzZG9tLmNoZWNrRm9yU3BlY2lhbFBhcmVudChsZWZ0Tm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gbm90ZSBpZiBuZXN0ZWQgd2lsbCBub3QgbmVjZXNzYXJ5IG1hdGNoIHRoaXMgc3RyYWlnaHQgYXdheSBidXQgbG9vcGluZyB3aWxsIGhpdCB0aGlzIGV2ZW50dWFsbHkuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBtb3ZlcyBiYWNrIHRvIGEgbWF0aCBlbGVtZW50LCBuZWVkIHRvIGJyZWFrIGhlcmVcbiAgICAgICAgICAgICAgICBpZihsZWZ0Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJtYXRoXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIG1vdmVzIGJhY2sgdG8gYSBtYXRoIGVsZW1lbnQsIG5lZWQgdG8gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICAgIGlmKGxlZnROb2RlLmlzTWF0aEpheClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hdGNoZWROb2RlID0gbGVmdE5vZGU7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZE9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGxlZnROb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBsb29rIHRvIGJyZWFrIHBvaW50cyBpbiB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgLy9maXJzdCBnZXQgdGV4dCB0byBjaGVja1xuICAgICAgICAgICAgICAgIHZhciB0eHQgPSBsZWZ0Tm9kZS5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICBpZih0eHQubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB7ICAgLy8gaXRlcmF0ZSBsZWZ0IHRvIGJyZWFrIHBvaW50IGlmIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIGZ1bGwgc3RvcFxuXG4gICAgICAgICAgICAgICAgICAgIGlmKGxlZnRPZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRPZmZzZXQgPSB0eHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UoL1tcXHgyMVxceDNmXFx4M2FdL2csIFwiLlwiKTsgICAvLyBjaGFuZ2UgIT86IHRvIC5cblxuICAgICAgICAgICAgICAgICAgICB2YXIgblBvcyA9IHR4dC5sYXN0SW5kZXhPZihcIi5cIiwgbGVmdE9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoblBvcyA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB7ICAgLy9mb3VuZCBwb3NzaWJsZSBzZW50ZW5jZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgYWJiciB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBhZ2FpbnN0IGxhc3RDaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzc2RvbS5yd19pc0Z1bGxTdG9wKHR4dCwgblBvcywgbGVmdE5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5Qb3MgPCB0eHQubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gaWYgYmVmb3JlIGxhc3QgY2hhciBzYWZlIHRvIGFzc3VtZSBzZW50ZW5jZSBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkTm9kZSA9IGxlZnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkT2Zmc2V0ID0gblBvcyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgey8vZWxzZSBpcyBmdWxsIHN0b3AgYXQgZW5kIG9mIG5vZGUgbmVlZCB0byBjaGVjayBhZ2FpbnN0IGZpcnN0IGNoYXIgb2YgbmV4dCBub2RlIGhlbGQgaW4gbGFzdENoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXNzZG9tLnJ3X2lzVGV4dENoYXIobGFzdENoYXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gYWxsb3cgbGFzdCBtYXRjaCBzZXQgaW4gcHJldiBpdGVyYXRpb24gdG8gc3RhbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuUG9zID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy9Ob3RlLCBqYXZhc2NyaXB0IGxhc3RJbmRleE9mLCBkb2VzIE5PVCB3b3JrIHNhbWUgYXMgSmF2YSBsYXN0SW5kZXhPZi4gIElmIHBhc3MgLTEgYXMgc3RhcnQgcG9pbnQsIGdldCBhbiBpbmNvcnJlY3QgcmVzdWx0LiAgKE1vc3QgbGlrZWx5IGJ1ZyBpbiBqYXZhc2NyaXB0LilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuUG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgblBvcyA9IHR4dC5sYXN0SW5kZXhPZihcIi5cIiwgblBvcyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoYkZvdW5kKVxuICAgICAgICAgICAgICAgICAgICB7ICAgLy8gZXNjYWxhdGUgdGhlIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vTm8gc2VudGVuY2UgZW5kIGZvdW5kIHNvIHNldCBzdGFydCBvZiB0aGlzIG5vZGUgdG8gbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIGlmIHRoZSBub2RlIGNvbnRhaW5zIHRleHRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHV0aWxzID0gbmV3IFV0aWxpdGllcygpO1xuICAgICAgICAgICAgICAgICAgICBpZih1dGlscy50cmltKHR4dCkubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZE5vZGUgPSBsZWZ0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdENoYXIgPSB0eHQuY2hhckF0KDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ2V0IHByZXZpb3VzIG5vZGVcbiAgICAgICAgICAgIGxlZnROb2RlID0gZG9tTmF2LmdldFByZXZpb3VzTm9kZShsZWZ0Tm9kZSwgdHJ1ZSwgcF9lbmROb2RlKTsgIC8vaXMgbnVsbCBpZiBkb2VzbnQgZmluZCBzdWl0YWJsZSBub2RlIHRvIGxlZnRcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgPSAtMTsgICAgLy9zZXQgdG8gLTEgYW5kIHNldCB0byBsZW5ndGggbGF0ZXIgcmF0aGVyIHRoYW4gY2hlY2sgaWYgdGV4dCBub2RlIGhlcmUgKGFzIGNoZWNrIGFnYWluIG5leHQgbG9vcCBhbnl3YXkpXG4gICAgICAgICAgICBpZihsZWZ0Tm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgeyAgIC8vIEdvbmUgYmFjayBhcyBmYXIgYXMgbmVlZCB0bywgdXNlIG1hdGNoZWQgdmFsdWUgdGhhdCBjdXJyZW50bHkgaGF2ZVxuICAgICAgICAgICAgICAgIGJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG1vdmVkIHRvIGEgc3BlY2lhbCBjYXNlIGdvaW5nIGJhY2t3YXJkc1xuICAgICAgICAgICAgaWYobGVmdE5vZGUubm9kZVR5cGUgPT0gMyAmJiBzc2RvbS5pc1NwZWNpYWxDYXNlTmVzdGVkKGxlZnROb2RlKSlcbiAgICAgICAgICAgIHsgICAvL2lzIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgICAgIGxlZnROb2RlID0gc3Nkb20uY2hlY2tGb3JTcGVjaWFsUGFyZW50KGxlZnROb2RlKTtcblxuICAgICAgICAgICAgICAgIGlmKGxlZnROb2RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgeyAgIC8vIEdvbmUgYmFjayBhcyBmYXIgYXMgbmVlZCB0bywgdXNlIG1hdGNoZWQgdmFsdWUgdGhhdCBjdXJyZW50bHkgaGF2ZVxuICAgICAgICAgICAgICAgICAgICBiRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIGhlcmUgbWF0Y2hlZCBzaG91bGQgbWF0Y2ggdGhlIGxlZnQgc2VudGVuY2UgYnJlYWsgcG9pbnRcblxuICAgICAgICAvLyBjaGVjayBmb3Igd2hpdGVzcGFjZSBpbiBub2RlIGJlZm9yZSB0ZXh0XG4gICAgICAgIGlmKG1hdGNoZWROb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0eHQgPSBtYXRjaGVkTm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICBpZihtYXRjaGVkT2Zmc2V0IDwgdHh0Lmxlbmd0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3aGlsZShtYXRjaGVkT2Zmc2V0IDwgdHh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNzZG9tLnJ3X2lzV2hpdGVTcGFjZSh0eHQuY2hhckF0KG1hdGNoZWRPZmZzZXQpKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIGlmKG1hdGNoZWROb2RlID09IHBfdGhDYXJldC5ub2RlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRPZmZzZXQgPj0gcF90aENhcmV0Lm9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB7ICAgLy8gZG8gbm90IGdvIGJleW9uZCBjYXJldCBwYXNzZWQgaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgKyttYXRjaGVkT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gbmV3IFRIQ2FyZXQobWF0Y2hlZE5vZGUsICBtYXRjaGVkT2Zmc2V0LCB0cnVlKTtcbiAgICB9O1xuXG5cbiAgICAvKiBVc2UgdGhpcyB0byBnZXQgcmlnaHQgYnJlYWsgcG9pbnQgYXMgYSBUSENhcmV0IDxicj5cbiAgICAgVGhpcyB3aWxsIG5vdCBnbyBwYXN0IG5vbiBzdHlsZSBub2Rlcywgc28gaWYgdGhlIHBhc3NlZCBjYXJldCBpcyBsYXN0IHZhbHVlXG4gICAgIGJlZm9yZSBhIGJyZWFrIHRoZSBzYW1lIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuPGJyPlxuICAgICBwX3RoQ2FyZXQgcG9pbnQgdG8gc3RhcnQgZnJvbVxuICAgICBwX2VuZE5vZGUgb3B0aW9uYWwsIGluY2x1ZGUgaWYgaGF2ZSBub2RlIGRvIG5vdCB3aXNoIHRvIGdvIHBhc3QsIHNob3VsZCBub3QgYmUgc2FtZSBhcyBub2RlIGluIHBfdGhDYXJldC5cbiAgICAgKi9cbiAgICBnZXRTZW50ZW5jZUJyZWFrVG9SaWdodCAocF90aENhcmV0LCBwX2VuZE5vZGUpXG4gICAge1xuICAgICAgICB2YXIgZG9tTmF2ID0gbmV3IERvbU5hdmlnYXRpb24oKTtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIGlmKHR5cGVvZihwX2VuZE5vZGUpID09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBfZW5kTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB3aWxsIG5vdCBicmVhayBpbnNpZGUgYW4gZWxlbWVudCB0aGF0IGhhcyByZWFkYWJsZSB0ZXh0IChpLmUuIGltZyB3aXRoIHRleHQpXG4gICAgICAgIC8vIG9ubHkgaW4gYWN0dWFsIHRleHQgbm9kZXNcblxuICAgICAgICBpZihwX3RoQ2FyZXQgPT0gbnVsbCB8fCBwX3RoQ2FyZXQubm9kZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByaWdodE5vZGUgPSBwX3RoQ2FyZXQubm9kZTtcbiAgICAgICAgdmFyIHJpZ2h0T2Zmc2V0ID0gcF90aENhcmV0Lm9mZnNldDtcblxuXG4gICAgICAgIC8vIG1hdGNoZWQgbm9kZSwgd2hlbiByaWdodCBub2RlIGdvZXMgcGFzdCBlbmQgb2Ygc2VudGVuY2UgdXNlIGxhc3QgbWF0Y2hlZCBub2RlLlxuICAgICAgICB2YXIgbWF0Y2hlZE5vZGUgPSByaWdodE5vZGU7XG4gICAgICAgIHZhciBtYXRjaGVkT2Zmc2V0ID0gcmlnaHRPZmZzZXQ7XG5cbiAgICAgICAgLy8gY3ljbGUgdG8gbmV4dCBicmVhayBwb2ludC5cblxuICAgICAgICB2YXIgYkZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGxhc3RDaGFyID0gJyAnO1xuXG4gICAgICAgIHZhciBjbWRFbGVtID0gbnVsbDtcbiAgICAgICAgdmFyIHRtcENtZEVsZW0gPSBudWxsO1xuICAgICAgICAvL3RvZG8gcmVtb3ZlIG9yIGFkZFxuLy8gICAgICAgIGlmKGdfYlVzZUNvbW1hbmRzKVxuLy8gICAgICAgIHtcbi8vICAgICAgICAgICAgY21kRWxlbSA9IHJ3X2ZpbmRDb21tYW5kTm9kZShyaWdodE5vZGUpO1xuLy8gICAgICAgIH1cblxuICAgICAgICB3aGlsZSghYkZvdW5kKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihzc2RvbS5pc1NwZWNpYWxDYXNlTmVzdGVkKHJpZ2h0Tm9kZSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmlnaHROb2RlID0gc3Nkb20uY2hlY2tGb3JTcGVjaWFsUGFyZW50KHJpZ2h0Tm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gbm90ZSBpZiBuZXN0ZWQgd2lsbCBub3QgbmVjZXNzYXJ5IG1hdGNoIHRoaXMgc3RyYWlnaHQgYXdheSBidXQgbG9vcGluZyB3aWxsIGhpdCB0aGlzIGV2ZW50dWFsbHkuXG4gICAgICAgICAgICAgICAgaWYocmlnaHROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcIm1hdGhcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHJpZ2h0Tm9kZS5pc01hdGhKYXgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXRjaGVkTm9kZSA9IHJpZ2h0Tm9kZTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBnZXQgbmV4dCBub2RlLlxuICAgICAgICAgICAgICAgIHJpZ2h0Tm9kZSA9IGRvbU5hdi5nZXROZXh0Tm9kZUlnbm9yZUNoaWxkcmVuKHJpZ2h0Tm9kZSwgdHJ1ZSwgcF9lbmROb2RlKTsgIC8vaXMgbnVsbCBpZiBkb2VzbnQgZmluZCBzdWl0YWJsZSBub2RlIHRvIHJpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHJpZ2h0Tm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgbG9vayB0byBicmVhayBwb2ludHMgaW4gdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIC8vZmlyc3QgZ2V0IHRleHQgdG8gY2hlY2tcbiAgICAgICAgICAgICAgICB2YXIgdHh0ID0gcmlnaHROb2RlLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmKHR4dC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHsgICAvLyBpdGVyYXRlIHJpZ2h0IHRvIGJyZWFrIHBvaW50IGlmIHRoZXJlXG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiBsYXN0IGNoYXIgaXMgYSAuIG5lZWQgdG8gY2hlY2sgaWYgbmV4dCBpcyBsZXR0ZXIgb3IgZGlnaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gICBpZiBpcyBhIG5vbiBsZXR0ZXIgb3IgZGlnaXQgKGkuZS4gd2hpdGVzcGFjZSBzeW1ib2wpIHRoZW4gdHJlYXQgYXMgc2VudGVuY2UgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgaWYobGFzdENoYXIgPT0gJy4nKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdENoYXIgPSB0eHQuY2hhckF0KHJpZ2h0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFzc2RvbS5yd19pc1RleHRDaGFyKHRlc3RDaGFyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgICAvLyBpcyBzZW50ZW5jZSBlbmQsIGRvbnQgaW5jbHVkZSB0aGlzIGFsbG93IG1hdGNoZWQgZnJvbSBlbmQgb2YgbGFzdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHR4dCA9IHR4dC5yZXBsYWNlKC9bXFx4MjFcXHgzZlxceDNhXS9nLCBcIi5cIik7ICAgLy8gY2hhbmdlICE/OiB0byAuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuUG9zID0gdHh0LmluZGV4T2YoXCIuXCIsIHJpZ2h0T2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZShuUG9zID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvL2ZvdW5kIHBvc3NpYmxlIHNlbnRlbmNlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZnVsbCBzdG9wIGJhc2VkIG9uIGZvbGxvd2luZyBjaGFyIG9yIHByZWNlZWRpbmcgYWJici5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNzZG9tLnJ3X2lzRnVsbFN0b3AodHh0LCBuUG9zLCByaWdodE5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5Qb3MgPCB0eHQubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWROb2RlID0gcmlnaHROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkT2Zmc2V0ID0gblBvcyArIDE7ICAvLyBzZXQgdG8gcG9pbnQgYWZ0ZXIgZnVsbCBzdG9wIChzZW50ZW5jZSBpcyByYW5nZSBiZWZvcmUgdG8ganVzdCBhZnRlciBzZW50ZW5jZSB0byBpbmNsdWRlIGZ1bGwgc3RvcC4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgblBvcyA9PSB0eHQubGVuZ3RoIC0xIGFuZCBpcyBsYXN0IGNoYXIgb2Ygc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWlnaHQgYmUgZW5kIGJ1dCBuZWVkIHRvIGNoZWNrIG5leHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYnJlYWsgdG8gZ28gdG8gbmV4dCBsb29wXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRPZmZzZXQgPSBuUG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5Qb3MgPSB0eHQuaW5kZXhPZihcIi5cIiwgcmlnaHRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoYkZvdW5kKVxuICAgICAgICAgICAgICAgICAgICB7ICAgLy8gZXNjYWxhdGUgdGhlIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vTm8gc2VudGVuY2UgZW5kIGZvdW5kIHNvIHNldCBlbmQgb2YgdGhpcyBub2RlIHRvIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIC8vYXNzdW1pbmcgdGhhdCB0aGlzIGhhcyBhY3R1YWwgY29udGVudCwgbm8gbmVlZCB0byBleHRlbmQgdG8gZW1wdHkgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXRpbGl0aWVzID0gbmV3IFV0aWxpdGllcygpO1xuICAgICAgICAgICAgICAgICAgICBpZih1dGlsaXRpZXMudHJpbSh0eHQpLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWROb2RlID0gcmlnaHROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZE9mZnNldCA9IHR4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhciA9IHR4dC5jaGFyQXQodHh0Lmxlbmd0aCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGxhc3RDaGFyID09ICcuJylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgd2FudCBsYXN0IGNoYXIgc2V0IHRvIGEgLiBpZiB0aGlzIGlzIHBhcnQgb2YgYW4gYWJicmV2aWF0aW9uLCBhcyBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGxvb3Agd2lsbCBzZWUgaXQgYXMgYSBwb3NzaWJsZSBzZW50ZW5jZSBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXNzZG9tLnJ3X2lzRnVsbFN0b3AodHh0LCB0eHQubGVuZ3RoIC0xLCByaWdodE5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGFyID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IG5leHQgbm9kZS5cbiAgICAgICAgICAgICAgICByaWdodE5vZGUgPSBkb21OYXYuZ2V0TmV4dE5vZGUocmlnaHROb2RlLCB0cnVlLCBwX2VuZE5vZGUpOyAgLy9pcyBudWxsIGlmIGRvZXNudCBmaW5kIHN1aXRhYmxlIG5vZGUgdG8gcmlnaHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgbmV4dCBub2RlLlxuICAgICAgICAgICAgICAgIHJpZ2h0Tm9kZSA9IGRvbU5hdi5nZXROZXh0Tm9kZShyaWdodE5vZGUsIHRydWUsIHBfZW5kTm9kZSk7ICAvL2lzIG51bGwgaWYgZG9lc250IGZpbmQgc3VpdGFibGUgbm9kZSB0byByaWdodFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByaWdodE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZihyaWdodE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHsgICAvLyBHb25lIGZvcndhcmQgYXMgZmFyIGFzIG5lZWQgdG8sIHVzZSBtYXRjaGVkIHZhbHVlIHRoYXQgY3VycmVudGx5IGhhdmVcbiAgICAgICAgICAgICAgICBiRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgaWYoZ19iVXNlQ29tbWFuZHMpIHRvZG9cbi8vICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICB0bXBDbWRFbGVtID0gcndfZmluZENvbW1hbmROb2RlKHJpZ2h0Tm9kZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgaWYoY21kRWxlbSA9PSBudWxsKVxuLy8gICAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgY21kRWxlbSA9IHRtcENtZEVsZW07XG4vLyAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgIGVsc2Vcbi8vICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRtcENtZEVsZW0gIT0gY21kRWxlbSlcbi8vICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGNvbW1hbmQgY2hhbmdlLCBicmVha1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkZvdW5kID0gdHJ1ZTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGVyZSBtYXRjaGVkIHNob3VsZCBtYXRjaCB0aGUgbGVmdCBzZW50ZW5jZSBicmVhayBwb2ludFxuXG4gICAgICAgIC8vIGNoZWNrIGZvciB3aGl0ZXNwYWNlIGluIG5vZGUgYmVmb3JlIHRleHRcbiAgICAgICAgaWYobWF0Y2hlZE5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHR4dCA9IG1hdGNoZWROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIGlmKG1hdGNoZWRPZmZzZXQgPiAwICYmIG1hdGNoZWRPZmZzZXQgPD0gdHh0Lmxlbmd0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3aGlsZShtYXRjaGVkT2Zmc2V0ID4gMClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNzZG9tLnJ3X2lzV2hpdGVTcGFjZSh0eHQuY2hhckF0KG1hdGNoZWRPZmZzZXQgLSAxKSkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBpZihtYXRjaGVkTm9kZSA9PSBwX3RoQ2FyZXQubm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkT2Zmc2V0IDw9IHBfdGhDYXJldC5vZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGRvIG5vdCBnbyBiZWZvcmUgY2FyZXQgcGFzc2VkIGluLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tbWF0Y2hlZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVEhDYXJldChtYXRjaGVkTm9kZSwgIG1hdGNoZWRPZmZzZXQsIGZhbHNlKTtcbiAgICB9O1xufVxuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGtldmluIG9uIDAxLzA0LzE2LlxuICovXG5pbXBvcnQge1V0aWxpdGllc30gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9VdGlsaXRpZXMvVXRpbGl0aWVzJ1xuaW1wb3J0IHtUSENhcmV0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIQ2FyZXQnXG5pbXBvcnQge1RIQ2FyZXRSYW5nZX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USENhcmV0UmFuZ2UnXG5pbXBvcnQge1RIUmFuZ2V9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhSYW5nZSdcbmltcG9ydCB7VEhEb21SZWZQdH0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USERvbVJlZlB0J1xuaW1wb3J0IHtNYXRoU3BlYWt9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vTWF0aEpheC9NYXRoU3BlYWsnXG5pbXBvcnQge0RvbU5hdmlnYXRpb259IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL0RvbU5hdmlnYXRpb24nXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9ET00vQXR0cmlidXRlJ1xuaW1wb3J0IHtEb21TZW50ZW5jZXN9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL0RvbVNlbnRlbmNlcydcbmltcG9ydCAqIGFzIENvbnN0YW50cyBmcm9tICdzcmMvQ29uc3RhbnRzL0NvbnN0YW50cydcblxuXG5leHBvcnQgY2xhc3MgU1NET017XG4gICAgY29uc3RydWN0b3IoKXtcblxuICAgIH1cblxuICAgIGNoZWNrRm9yU3BlY2lhbFBhcmVudCAocF9ub2RlKVxuICAgIHtcbiAgICAgICAgaWYocF9ub2RlICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBib2QgPSB0aGlzLmdldEJvZHkocF9ub2RlKTtcbiAgICAgICAgICAgIHZhciB0bXBOb2RlID0gcF9ub2RlO1xuICAgICAgICAgICAgd2hpbGUodG1wTm9kZSAhPSBudWxsICYmIHRtcE5vZGUgIT0gYm9kKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNTcGVjaWFsQ2FzZSh0bXBOb2RlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXBOb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0bXBOb2RlID0gdG1wTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuXG4gICAgZ2V0Qm9keSAocF9ub2RlKVxuICAgIHsgICAvLyBUaGlzIGV4aXN0cyBmb3IgSUUgNS41IHNvIGZvciBhIGJyb3dzZXIgd2Ugbm8gbG9uZ2VyIHN1cHBvcnQuXG4gICAgICAgIGlmKHBfbm9kZS5kb2N1bWVudClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBfbm9kZS5kb2N1bWVudC5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBfbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogQ2hlY2sgaWYgaXQgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGV4dCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseSwgaS5lLlxuICAgICBzcGFuIHdpdGggcHJvbiBvciBjaHVuayBvciBlbGVtZW50IHdpdGggaWdub3JlIGF0dHJpYnV0ZS4gIE9yIGFjcm9ueW0gb3IgYWJici4gT1IgSW1nIHdpdGggbXNnIGF0dHJpYnV0ZS4gT1IgbWF0aE1MXG4gICAgIDxwPlxuICAgICByZXR1cm4gYm9vbGVhblxuICAgICAqL1xuICAgIGlzU3BlY2lhbENhc2UgKHBfbm9kZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKCk7XG4gICAgICAgIGlmKHBfbm9kZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYocF9ub2RlLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gcF9ub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmKHRhZ05hbWUgPT0gQ29uc3RhbnRzLkhJR0hMSUdIVF9UQUcgfHwgdGFnTmFtZSA9PSBcInNwYW5cIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocF9ub2RlLCBcInByb25cIik7XG4gICAgICAgICAgICAgICAgaWYoYXR0ciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHBfbm9kZSwgXCJjaHVua1wiKTtcbiAgICAgICAgICAgICAgICBpZihhdHRyICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXR0ciA9IHBfbm9kZS5pc01hdGhKYXg7XG4gICAgICAgICAgICAgICAgaWYoYXR0ciAhPSBudWxsICYmIGF0dHIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGFnTmFtZSA9PSBcImFjcm9ueW1cIiB8fCB0YWdOYW1lID09IFwiYWJiclwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gcF9ub2RlLmdldEF0dHJpYnV0ZShcInRpdGxlXCIpO1xuICAgICAgICAgICAgICAgIGlmKGF0dHIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGFnTmFtZSA9PSBcImNodW5rXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRhZ05hbWUgPT0gXCJpbWdcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocF9ub2RlLCBcIm1zZ1wiKTtcbiAgICAgICAgICAgICAgICBpZihhdHRyICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRhZ05hbWUgPT0gXCJtYXRoXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpc1NwZWNpYWxDYXNlSGlnaGxpZ2h0YWJsZSAocF9ub2RlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgaWYocF9ub2RlLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gcF9ub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmKHRhZ05hbWUgPT0gXCJzcGFuXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHBfbm9kZSwgXCJwcm9uXCIpO1xuICAgICAgICAgICAgICAgIGlmKGF0dHIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShwX25vZGUsIFwiY2h1bmtcIik7XG4gICAgICAgICAgICAgICAgaWYoYXR0ciAhPSBudWxsICYmIGF0dHIgPT0gXCIxXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXR0ciA9IHBfbm9kZS5pc01hdGhKYXg7XG4gICAgICAgICAgICAgICAgaWYoYXR0ciAhPSBudWxsICYmIGF0dHIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0aCA9IG5ldyBNYXRoU3BlYWsoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck1MID0gbWF0aC5nZXRUZXh0RnJvbU1hdGhKYXgocF9ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoc3RyTUwubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRhZ05hbWUgPT0gXCJhY3JvbnltXCIgfHwgdGFnTmFtZSA9PSBcImFiYnJcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHBfbm9kZS5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKTtcbiAgICAgICAgICAgICAgICBpZihhdHRyICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRhZ05hbWUgPT0gXCJtYXRoXCIpXG4gICAgICAgICAgICB7ICAgLy8gbWF0aG1sIHdpdGhvdXQgbWF0aGpheCBpcyBub3QgaGlnaGxpZ2h0ZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGlubmVyIGVsZW1lbnQgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgY29udGFpbmluZyBlbGVtZW50LiAgUmV0dXJuIFRydWUgaWYgaXQgaXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0gcF9pbm5lckVsZW1lbnRcbiAgICAgKiBAcGFyYW0gcF9jb250YWluaW5nRWxlbWVudFxuICAgICAqL1xuICAgIGNoZWNrSWZFbGVtZW50SW5zaWRlRWxlbWVudCAocF9pbm5lckVsZW1lbnQsIHBfY29udGFpbmluZ0VsZW1lbnQpXG4gICAge1xuICAgICAgICBpZihwX2lubmVyRWxlbWVudCA9PSBudWxsIHx8IHBfY29udGFpbmluZ0VsZW1lbnQgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0bXAgPSBwX2lubmVyRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSh0bXAgIT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYodG1wID09IHBfY29udGFpbmluZ0VsZW1lbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXAgPSB0bXAucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgaXQgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIGNoaWxkIGVsZW1lbnRzIGFyZSB0byBiZSBpZ25vcmVkIHRvIHRvIHRoaXMgcGFyZW50IGVsZW1lbnRcbiAgICAgKiBoYXZpbmcgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICpcbiAgICAgKiBpLmUuXG4gICAgICogc3BhbiB3aXRoIG1hdGhqYXgsIHRleHRhcmVhLCBJbWcgd2l0aCBtc2cgYXR0cmlidXRlLiBvciBtYXRoTUxcbiAgICAgKiBAcGFyYW0gcF9ub2RlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTcGVjaWFsQ2FzZVdpdGhJZ25vcmVkQ29udGVudCAocF9ub2RlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgaWYocF9ub2RlID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZihwX25vZGUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRhZ05hbWUgPSBwX25vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYodGFnTmFtZSA9PSBcInNwYW5cIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHBfbm9kZS5pc01hdGhKYXg7XG4gICAgICAgICAgICAgICAgaWYoYXR0ciAhPSBudWxsICYmIGF0dHIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRhZ05hbWUgPT0gXCJ0ZXh0YXJlYVwiKVxuICAgICAgICAgICAgeyAgIC8vIGRvbid0IGdvIGludG8gdGV4dGFyZWFzIGNvdmVyZWQgc2VwYXJhdGUgZnJvbSBub3JtYWwgbG9naWMgZmxvdy5cbiAgICAgICAgICAgICAgICAvLyBkb250IGdvIHRvIG5leHQgYXMgd291bGQgYmUgZ29pbmcgcGFzdCBwX25vZGUgbm90IHRvIGNoaWxkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRhZ05hbWUgPT0gXCJpbWdcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocF9ub2RlLCBcIm1zZ1wiKTtcbiAgICAgICAgICAgICAgICBpZihhdHRyICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRhZ05hbWUgPT0gXCJtYXRoXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlVzZSB0aGlzIHRvIGNoZWNrIGlmIHRoZSB3b3JkIGFjdHVhbGx5IGNvbnRhaW5zIGFueXRoaW5nIHRoYXQgY2FuIGJlIHNwb2tlbi5cbiAgICAgcmV0dXJucyB0cnVlIGlmIHNvLCBmYWxzZSBvdGhlcndpc2UuKi9cbiAgICByd19pc1dvcmRTcGVha2FibGUocF9zdHJXb3JkKVxuICAgIHtcbiAgICAgICAgaWYocF9zdHJXb3JkID09IG51bGwgfHwgcF9zdHJXb3JkLmxlbmd0aCA9PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0aWxpdGllcyA9IG5ldyBVdGlsaXRpZXMoKTtcblxuICAgICAgICB2YXIgdG1wV29yZCA9IHV0aWxpdGllcy50cmltKHBfc3RyV29yZCk7XG4gICAgICAgIGlmKHRtcFdvcmQubGVuZ3RoID09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0bXBDID0gdG1wV29yZC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYodG1wQyA9PSA5NiB8fCAgICAgICAgICAgIC8vICAgICAgICAgYCAgIGdyYXZlXG4gICAgICAgICAgICAgICAgdG1wQyA9PSAxODAgfHwgICAgICAvLyAgICAgICAgICcgICBhY3V0ZVxuICAgICAgICAgICAgICAgIHRtcEMgPT0gODIxNiB8fCAgICAgIC8vICAgICAgICAnICAgcXVvdGVsZWZ0XG4gICAgICAgICAgICAgICAgdG1wQyA9PSA4MjE3IHx8ICAgICAgLy8gICAgICAgICcgICBxdW90ZXJpZ2h0XG4gICAgICAgICAgICAgICAgdG1wQyA9PSA4MjIwIHx8ICAgICAgLy8gICAgICAgIFwiICAgcXVvdGVkYmxsZWZ0XG4gICAgICAgICAgICAgICAgdG1wQyA9PSA4MjIxKSAgICAgIC8vICAgICAgICAgIFwiICAgcXVvdGVkYmxyaWdodFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRpbGwgZ2V0IGNoYXJhY3RlciB0byByZWFkXG4gICAgICAgIHZhciBuTGVuID0gdG1wV29yZC5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIG5WYWw7XG4gICAgICAgIGZvcihpPTA7IGk8bkxlbjsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBuVmFsID0gdG1wV29yZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYoKG5WYWwgPiA2MyAmJiBuVmFsIDwgOTEpIHx8IChuVmFsID4gOTYgJiYgblZhbCA8IDEyMykgfHwgKG5WYWwgPiAxMjcgJiYgblZhbCAhPSAxNjApKVxuICAgICAgICAgICAgeyAgIC8vIEBBLVogYS16IGhpZ2ggYXNjaWlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoblZhbCA+IDQ2ICYmIG5WYWwgPCA1OClcbiAgICAgICAgICAgIHsgICAvLyAvIDAtOVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZigoblZhbCA+IDM1ICYmIG5WYWwgPCAzOSkgfHwgblZhbCA9PSA0MyB8fCBuVmFsID09IDYxKVxuICAgICAgICAgICAgeyAvLyAkICUgJiArID1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZWQgJyBhcyBvbmx5IHJlYWQgaWYgcGFydCBvZiBhIHdvcmQgaW4gd2hpY2ggY2FzZSB3aWxsIHBhc3Mgb24gdGhlIGNoYXJhY3Rlci4gIERvbid0IHdhbnQgJyB0byBiZSByZWFkIGJ5IGl0c2VsZi5cbiAgICAgICAgICAgIGVsc2UgaWYoLypuVmFsID09IDM5IHx8ICovblZhbCA9PSA0MiB8fCBuVmFsID09IDQ1IHx8IG5WYWwgPT0gOTIgfHxcbiAgICAgICAgICAgICAgICAoblZhbCA+IDkzICYmIG5WYWwgPCA5NykpXG4gICAgICAgICAgICB7ICAgLy8gMzkgJyAgNDIgKiAgNDUgLSAgOTIgXFwgIDk0IF4gIDk1IF8gIDk2IGBcbiAgICAgICAgICAgICAgICAvL29ubHkgaWYgbm90IFZXIEthdGVcbi8vICAgICAgICAgICAgICAgIGlmKGdfc3RyVm9pY2UgIT0gXCJWVyBLYXRlXCIpXG4vLyAgICAgICAgICAgICAgICB7ICAgLy8gTm90IHdvcnJ5aW5nIGFib3V0IHRhcmdldCBtYXliZSB1c2luZyBkaWZmZXJlbnQgdm9pY2UgYXMgcGVvcGxlIHVzaW5nIEthdGUgd2lsbCBub3QgYmUgdXNpbmcgb3B0aW9ucyB0aGF0IGFsbG93IHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuLy90b2RvXG4vLyAgICAgICAgaWYoZ19iTWF0aHNTeW1ib2xzKVxuLy8gICAgICAgIHsgICAvLyBUaGlzIG9ubHkgY2hlY2tzIGZvciBzeW1ib2wgYnkgaXRzZWxmLiAgU3ltYm9sIHdpdGggdGV4dCB3aWxsIGJlIGNhdWdodCBhYm92ZSxcbi8vICAgICAgICAgICAgLy8gbWF0aHMgc3ltYm9scyBpbW1lZGlhdGVseSBuZXh0IHRvIG90aGVyIHN5bWJvbHMgbmVlZCB0byBiZSBleHBsaWNpdGx5IGFkZGVkIHRvIGNvdW50LlxuLy8gICAgICAgICAgICBpZihyd19tYXRoc1N5bWJvbENoZWNrKHRtcFdvcmQpKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cblxuICAgIGNyZWF0ZVdyYXBwZXJFbGVtZW50ICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVPYmplY3QoQ29uc3RhbnRzLldSQVBQRVJfVEFHLCBudWxsLCBudWxsLCAoZ19iT3ZlcnJpZGVTcGFuP1widGhzcGFuXCI6bnVsbCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgb2JqZWN0IGluIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICogQHBhcmFtIHBfc3RyTmFtZSB0aGUgbmFtZSBvZiB0aGUgdGFnIHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSBwX2F0dHJMaXN0IGF0cnJpYnV0ZSBsaXN0IGluIGZvcm0gW1wia2V5XCIsXCJ2YWx1ZVwiLC4uLl1cbiAgICAgKiBAcGFyYW0gcF9zdHJJZCB0aGUgaWRcbiAgICAgKiBAcGFyYW0gcF9zdHJDbGFzcyB0aGUgY2xhc3NcbiAgICAgKi9cbiAgICBjcmVhdGVPYmplY3QocF9zdHJOYW1lLCBwX2F0dHJMaXN0LCBwX3N0cklkLCBwX3N0ckNsYXNzKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT2JqZWN0Rm9yRG9jKHBfc3RyTmFtZSwgcF9hdHRyTGlzdCwgcF9zdHJJZCwgcF9zdHJDbGFzcywgZG9jdW1lbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgb2JqZWN0IGluIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICogQHBhcmFtIHBfc3RyTmFtZSB0aGUgbmFtZSBvZiB0aGUgdGFnIHRvIGNyZWF0ZVxuICAgICAqIEBwYXJhbSBwX2F0dHJMaXN0IGF0cnJpYnV0ZSBsaXN0IGluIGZvcm0gW1wia2V5XCIsXCJ2YWx1ZVwiLC4uLl1cbiAgICAgKiBAcGFyYW0gcF9zdHJJZCB0aGUgaWRcbiAgICAgKiBAcGFyYW0gcF9zdHJDbGFzcyB0aGUgY2xhc3NcbiAgICAgKiBAcGFyYW0gcF9kb2MgZG9jdW1lbnQgdG8gdXNlXG4gICAgICovXG4gICAgY3JlYXRlT2JqZWN0Rm9yRG9jIChwX3N0ck5hbWUsIHBfYXR0ckxpc3QsIHBfc3RySWQsIHBfc3RyQ2xhc3MsIHBfZG9jKVxuICAgIHtcbiAgICAgICAgdmFyIHRoZU9iaiA9IHBfZG9jLmNyZWF0ZUVsZW1lbnQocF9zdHJOYW1lKTtcbiAgICAgICAgaWYocF9zdHJJZCAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGVPYmouaWQgPSBwX3N0cklkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocF9zdHJDbGFzcyAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGVPYmouY2xhc3NOYW1lID0gcF9zdHJDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBfYXR0ckxpc3QgIT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5MZW4gPSBwX2F0dHJMaXN0Lmxlbmd0aDtcblxuLy8gICAgICAgICAgICBpZihTU0RPTS5iSUVPbGQpXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuTGVuOyBpICs9IDIpXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgaWYocF9hdHRyTGlzdFtpXSA9PSBcInN0eWxlXCIpXG4vLyAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICBTU0RPTS5zZXRTdHlsZSh0aGVPYmosIHBfYXR0ckxpc3RbaSArIDFdKTtcbi8vICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgZWxzZVxuLy8gICAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgdGhlT2JqLnNldEF0dHJpYnV0ZShwX2F0dHJMaXN0W2ldLCBwX2F0dHJMaXN0W2kgKyAxXSk7XG4vLyAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbkxlbjsgaSArPSAyKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhlT2JqLnNldEF0dHJpYnV0ZShwX2F0dHJMaXN0W2ldLCBwX2F0dHJMaXN0W2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVPYmo7XG4gICAgfTtcblxuICAgIC8qaXNTdHlsZU5vZGUgdGFrZXMgdGhlIG5vZGUgdG8gY2hlY2sgYW5kIGEgYm9vbGVhbiBhdHRyIHRvIGlnbm9yZSBzdGFydGVkIGF0dHIgaW4gbm9kZXMsIGRlZmF1bHRzIHRvIGZhbHNlICAqL1xuICAgIC8qKlxuICAgICAqIFN0eWxlIG5vZGUgaXMgb25lIHRoYXQgaXMgbm90IGEgc2VudGVuY2UgYnJlYWtlciwgc3VjaCBhcyAmbHQ7YiZndDsuICBKdXN0IGFmZmVjdHMgYXBwZWFyYW5jZSBhbmQgbm90IGEgdGVzdCBkaXZpZGVyLlxuICAgICAqIEEgc3BhbiBvciBjdXN0b20gZWxlbWVudCB1c2VkIGJ5IHRoZSB0b29sYmFyIGlzIGEgc3R5bGUgZWxlbWVudCwgdW5sZXNzIGl0IGlzIHBhcnQgb2YgaGlnaGxpZ2h0ZWQgc3BlZWNoIG9yXG4gICAgICogc3BlY2lmaWMgYXR0cmlidXRlIHNldCB0byBtYWtlIGl0IGEgYnJlYWtlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwX25vZGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc1N0eWxlTm9kZSAocF9ub2RlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgaWYgKHBfbm9kZSA9PSBudWxsKSB7ICAgLy8gaGFwcGVuZWQgZHVlIHRvIG5vZGUgYmVpbmcgb3JwaGFuZWQgYW5kIHBhc3NlZCBpbiBwYXJlbnQgd2hpY2ggd2FzIG51bGwuXG4gICAgICAgICAgICAvLyBBbHNvIGNoYW5nZWQgY2FsbGVyLCBidXQgY2hlY2sgaGVyZSBhcyB1c2VkIGZyb20gbWFueSBwb2ludC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwX25vZGUubm9kZVR5cGUgIT0gMSkgeyAgIC8vIHRleHQgbm9kZSBhbmQgY29tbWVudCB0cmVhdCBhcyBzdHlsZS5cbiAgICAgICAgICAgIHJldHVybiBwX25vZGUubm9kZVR5cGUgPT0gMyB8fCBwX25vZGUubm9kZVR5cGUgPT0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJOYW1lID0gcF9ub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKS50cmltVEgoKTtcbiAgICAgICAgaWYgKHN0ck5hbWUgPT0gQ29uc3RhbnRzLkhJR0hMSUdIVF9UQUcpICAvL3Byb2JhYmx5IHNwYW5cbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0ckF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHBfbm9kZSwgXCJzdGFydGVkXCIpO1xuICAgICAgICAgICAgaWYgKHN0ckF0dHIgIT0gbnVsbCAmJiBzdHJBdHRyID09IFwiMVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vdG9kbyBpcyB0aGlzIG5lZWRlZFxuLy8gICAgICAgIGlmICh0aGlzLnJ3X2dldEF0dHJpYnV0ZShwX25vZGUsIFJXVEhfU0tJUF9DT05USU5VT1VTKSAhPSBudWxsKSB7XG4vLyAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbi8vICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJblN0eWxlTGlzdChzdHJOYW1lKTtcbiAgICB9XG5cbiAgICBpc0luU3R5bGVMaXN0IChwX3N0ck5hbWUpXG4gICAge1xuICAgICAgICB2YXIgc3RyU3R5bGVMaXN0ID1cIn5lbX5zdHJvbmd+Yn5pfnV+dHR+Zm9udH5rYmR+ZGZufmNpdGV+c3VwfnN1Yn5hfmVtYmVkfnNwYW5+c21hbGx+bm9icn53YnJ+YWNyb255bX5cIiArXG4gICAgICAgICAgICBcImFiYnJ+Y29kZX5zfmNodW5rfnRoOnByb25+aW1nfi90aDpwcm9ufnd+L3d+bGljL2xpY35icmVha35zaWxlbmNlfnRoc3Bhbn5iZWVsaW5lcmVhZGVyfmJlZWxpbmVzcGFuflwiK1xuICAgICAgICAgICAgQ29uc3RhbnRzLkhJR0hMSUdIVF9UQUcrXCJ+XCIrQ29uc3RhbnRzLldSQVBQRVJfVEFHK1wiflwiO1xuXG4gICAgICAgIHJldHVybiBzdHJTdHlsZUxpc3QuaW5kZXhPZihcIn5cIitwX3N0ck5hbWUrXCJ+XCIpID4gLTE7XG4gICAgfTtcbiAgICAvL0NoZWNrcyBpZiBub2RlIGlzIGludmFsaWQgZm9yIGJlaW5nIHJlYWQuICByZXR1cm5zIHRydWUgaWYgaW52YWxpZC5cbiAgICBpc0ludmFsaWROb2RlIChwX25vZGUpXG4gICAge1xuICAgICAgICBpZihwX25vZGUgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwX25vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYocF9ub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNJbnZhbGlkTm9kZShwX25vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cjtcbi8vdG9kbyBpcyB0aGlzIG5lZWRlZFxuICAgICAgICAvL2F0dHIgPSB0aGlzLnJ3X2dldEF0dHJpYnV0ZShwX25vZGUsIFJXVEhfU0tJUF9DT05USU5VT1VTKTtcbi8vICAgICAgICBpZihhdHRyICE9IG51bGwgJiYgZmFsc2UpLy9TU0RBVC5jb250cm9sRGF0YS5iSWdub3JlU2tpcFNlY3Rpb24pXG4vLyAgICAgICAge1xuLy8gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgICAgICB9XG5cbiAgICAgICAgLy9Tb21lIHVzZXJzIG1heSB3aXNoIHRvIGNhY2hlIGV2ZW4gaGlkZGVuIHRleHQsIGJ1dCB0eXBpY2FsbHkgc2hvdWxkIGlnbm9yZSBoaWRkZW4gaXRlbXMuXG4gICAgICAgIC8vdG9kbyBpcyB0aGlzIG5lZWRlZFxuICAgICAgICBpZih0cnVlICkvLyYmIGdfYklnbm9yZUhpZGRlbilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgY29tcHV0ZWQgc3R5bGUgcmF0aGVyIHRoYW4gbm9ybWFsIHN0eWxlIGFzIGNzcyBub3QgdGFrZW4gaW50byBhY2NvdW50IG90aGVyd2lzZVxuICAgICAgICAgICAgdmFyIGNvbXBTdHlsZSA9IHRoaXMuZ2V0Q29tcHV0ZWRTdHlsZShwX25vZGUpO1xuICAgICAgICAgICAgaWYoY29tcFN0eWxlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoY29tcFN0eWxlLnZpc2liaWxpdHkgPT0gXCJoaWRkZW5cIiB8fCBjb21wU3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJOYW1lID0gcF9ub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICByZXR1cm4gc3RyTmFtZSA9PSBcImxpbmtcIiB8fFxuICAgICAgICAgICAgc3RyTmFtZSA9PSBcImFyZWFcIiB8fFxuICAgICAgICAgICAgc3RyTmFtZSA9PSBcInNjcmlwdFwiIHx8XG4gICAgICAgICAgICBzdHJOYW1lID09IFwibm9zY3JpcHRcIiB8fFxuICAgICAgICAgICAgc3RyTmFtZSA9PSBcImFubm90YXRpb25cIiB8fFxuICAgICAgICAgICAgc3RyTmFtZSA9PSBcInN0eWxlXCIgfHxcbiAgICAgICAgICAgIHN0ck5hbWUgPT0gXCIhLS1cIiB8fFxuICAgICAgICAgICAgc3RyTmFtZSA9PSBcInRpdGxlXCIgfHxcbiAgICAgICAgICAgIHN0ck5hbWUgPT0gXCJodG1sOnNjcmlwdFwiOyAgLy8gbGFzdCBpcyBmcm9tIGZpcmVidWdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgdG8gZ2V0IHRoZSBjb21wdXRlZCBzdHlsZSwgdGhlIG1hbm9yIGRpZmZlcnMgYmV0d2VlbiBJRSBhbmQgb3RoZXJzLlxuICAgICAqIEBwYXJhbSBwX2VsZW1cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFN0eWxlIChwX2VsZW0pXG4gICAge1xuICAgICAgICBpZihwX2VsZW0gPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwX2VsZW0ubm9kZVR5cGUgPT0gMylcbiAgICAgICAge1xuICAgICAgICAgICAgcF9lbGVtID0gcF9lbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZihwX2VsZW0gPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4vLyAgICAgICAgaWYoU1NET00uYklFT2xkKVxuLy8gICAgICAgIHtcbi8vICAgICAgICAgICAgcmV0dXJuIHBfZWxlbS5jdXJyZW50U3R5bGU7XG4vLyAgICAgICAgfVxuLy8gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBfZWxlbSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2hlY2sgaWYgbmVzdGVkIGluIGludmFsaWQgbm9kZVxuLy8gQ2hlY2tzIGlmIGluIGlnbm9yZSBhdHRyaWJ1dGUgbm9kZVxuLy8gb3IgaWYgaW4gYnV0dG9uIHdoZW4gaWdub3JlIGJ1dHRvbiBpcyBvbi5cbi8vIEFkZGl0aW9uIGFkZGVkIGZvciAnYWxsb3cnICBhbHNvIGZvciBkZWZhdWx0IGNhc2UgdG8gYWx3YXlzIGlnbm9yZSB1bmxlc3MgYWxsb3cuXG4gICAgaXNJZ25vcmVkIChwX25vZGUpXG4gICAge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSgpO1xuICAgICAgICAvL3RvZG8gaXMgdGhpcyBuZWVkZWRcbi8vICAgICAgICBpZihTU0RPTS5iT3ZlcnJpZGVJZ25vcmUpXG4vLyAgICAgICAge1xuLy8gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4vLyAgICAgICAgfVxuXG4gICAgICAgIHZhciBiRGVmYXVsdCA9IGZhbHNlOy8vU3BlZWNoU3RyZWFtLnRvb2xzLmdldFBhZ2VDb250cm9sKCkuaXNJZ25vcmVQYWdlRGVmYXVsdCgpO1xuXG4gICAgICAgIGlmKHBfbm9kZSAhPSBudWxsICYmIHBfbm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICB7XG4gICAgICAgICAgICBwX25vZGUgPSBwX25vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBfbm9kZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdGUgdGhpcyBzZWFyY2hlcyBmb3IgYmFzZSBtYXRjaCBvZiBpZ25vcmUsIHBsdXMgaWdub3JlIHdpdGggcHJlZml4LlxuXG4gICAgICAgIHZhciBzdHJJZ25vcmVBdHRyID1cImlnbm9yZVwiOy8vIFNTREFULmdldEF0dHJpYnV0ZURhdGEoKS5JR05PUkVfQVRUUjtcbiAgICAgICAgdmFyIHN0ckFsbG93QXR0ciA9IFwiYWxsb3dcIjsvL1NTREFULmdldEF0dHJpYnV0ZURhdGEoKS5BTExPV19BVFRSO1xuXG4gICAgICAgIHZhciBib2QgPSBwX25vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuXG4gICAgICAgIHZhciB0bXBOb2RlID0gcF9ub2RlO1xuICAgICAgICB3aGlsZSh0bXBOb2RlICE9IG51bGwgJiYgdG1wTm9kZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRtcE5vZGUsIHN0cklnbm9yZUF0dHIpICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRtcE5vZGUsIHN0ckFsbG93QXR0cikgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RvZG8gaXMgdGhpcyBuZWVkZWQgaWYoZ19iSWdub3JlQnV0dG9ucylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZih0bXBOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImJ1dHRvblwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodG1wTm9kZT09Ym9kKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG1wTm9kZSA9IHRtcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYkRlZmF1bHQ7XG4gICAgfTtcblxuICAgIC8qIFJldHVybnMgdGV4dCBmcm9tIHBhc3NlZCBub2RlXG4gICAgIFRoaXMgb25seSBnaXZlcyB0ZXh0IGZyb20gdGV4dCBub2RlcyBhbmQgaWdub3JlcyBvdGhlciB0eXBlcy5cbiAgICAgQXNzdW1lcyBhbGwgdGV4dCBpcyB0byBiZSBpbmNsdWRlZCwgd2hpdGVzcGFjZSBmb3IgcGFkZGluZyBiZXR3ZWVuIG5vZGVzIHdvdWxkIGJlIGluY2x1ZGVkLCBzb1xuICAgICBvbmx5IHVzZSB0aGlzIG1ldGhvZCB3aGVuIHN1cmUgdGhhdCB3aWxsIG5vdCBiZSBhbiBpc3N1ZS4gKi9cbiAgICBhbGxUZXh0RnJvbU5vZGVUSCAoYU5vZGUpXG4gICAge1xuICAgICAgICB2YXIgdHh0ID0gXCJcIjtcbiAgICAgICAgaWYgKGFOb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR4dCA9IGFOb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhTm9kZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYUNoaWxkID0gYU5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChhQ2hpbGQgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoYUNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eHQgKz0gYUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYUNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eHQgKz0gdGhpcy5hbGxUZXh0RnJvbU5vZGVUSChhQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhQ2hpbGQgPSBhQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4dDtcbiAgICB9O1xuICAgIC8qTWVyZ2VzIHRleHQgbm9kZXMgYXJvdW5kIHBhc3NlZCBub2RlLlxuICAgICBpLmUuXG4gICAgIDxzcGFuPjxUZXh0Tm9kZSB0ZXh0Q29udGVudD1cImFhYVwiPjxUZXh0Tm9kZSB0ZXh0Q29udGVudD1cImJiYlwiPjwvc3Bhbj5cblxuICAgICBiZWNvbWVzXG4gICAgIDxzcGFuPjxUZXh0Tm9kZSB0ZXh0Q29udGVudD1cImFhYWJiYlwiPjwvc3Bhbj5cblxuICAgICBSZXR1cm5zIHRoZSByZXN1bHRpbmcgdGV4dCBub2RlLiBUaGlzIHdpbGwgYmUgdGhlIG9yaWdpbmFsIG5vZGUgaWYgaXQgaXMgdW5jaGFuZ2VkLlxuXG4gICAgICovXG4gICAgbWVyZ2VUZXh0Tm9kZXMgKHBfbm9kZSlcbiAgICB7XG4gICAgICAgIGlmKHBfbm9kZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcF9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhck5vZGUgPSBwX25vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICBpZihwYXJOb2RlICE9IG51bGwgJiYgcF9ub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBwX25vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIHdoaWxlKHBfbm9kZS5wcmV2aW91c1NpYmxpbmcgIT0gbnVsbCAmJiBwX25vZGUucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHR4dCA9IHBfbm9kZS5wcmV2aW91c1NpYmxpbmcubm9kZVZhbHVlICsgcF9ub2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdHh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0eHQpO1xuICAgICAgICAgICAgICAgIHBhck5vZGUucmVtb3ZlQ2hpbGQocF9ub2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgcGFyTm9kZS5yZXBsYWNlQ2hpbGQodHh0Tm9kZSwgcF9ub2RlKTtcbiAgICAgICAgICAgICAgICBwX25vZGUgPSB0eHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUocF9ub2RlLm5leHRTaWJsaW5nICE9IG51bGwgJiYgcF9ub2RlLm5leHRTaWJsaW5nLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHR4dCA9IHBfbm9kZS5ub2RlVmFsdWUgKyBwX25vZGUubmV4dFNpYmxpbmcubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciB0eHROb2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHR4dCk7XG4gICAgICAgICAgICAgICAgcGFyTm9kZS5yZW1vdmVDaGlsZChwX25vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIHBhck5vZGUucmVwbGFjZUNoaWxkKHR4dE5vZGUsIHBfbm9kZSk7XG4gICAgICAgICAgICAgICAgcF9ub2RlID0gdHh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcF9ub2RlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2Ugc2VsZWN0aW9uIGZvciBub24gc3BlZWNoIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKi9cbiAgICByd19yZWR1Y2VTZWxlY3Rpb25Gb3JOb25TcGVlY2hDaGFyKHBfY2FyZXRSYW5nZSlcbiAgICB7XG4gICAgICAgIHZhciBkb21OYXYgPSBuZXcgRG9tTmF2aWdhdGlvbigpO1xuICAgICAgICB2YXIgYkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJpZ2h0Tm9kZSA9IHBfY2FyZXRSYW5nZS5yaWdodENhcmV0Lm5vZGU7XG4gICAgICAgIHZhciBuUmlnaHRPZmZzZXQgPSBwX2NhcmV0UmFuZ2UucmlnaHRDYXJldC5vZmZzZXQ7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IHBfY2FyZXRSYW5nZS5sZWZ0Q2FyZXQubm9kZTtcbiAgICAgICAgdmFyIG5MZWZ0T2Zmc2V0ID0gcF9jYXJldFJhbmdlLmxlZnRDYXJldC5vZmZzZXQ7XG5cbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0bXBOb2RlO1xuICAgICAgICAgICAgdmFyIHRtcENoYXI7XG5cbiAgICAgICAgICAgIGlmKCFwX2NhcmV0UmFuZ2UucmlnaHRDYXJldC5pc1NwZWNpYWxDYXNlKCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0VGV4dCA9IHJpZ2h0Tm9kZS5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSh0cnVlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoblJpZ2h0T2Zmc2V0ID09IDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcE5vZGUgPSBkb21OYXYuZ2V0UHJldmlvdXNUZXh0Tm9kZShyaWdodE5vZGUsIGZhbHNlLCBsZWZ0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0bXBOb2RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gZG9uJ3QgbW92ZSBhbnkgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0bXBOb2RlLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gbW92ZSB0byBpbWFnZSB0aGVuIGRvbid0IG1vdmUgYW55IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodE5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5SaWdodE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodE5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRUZXh0ID0gcmlnaHROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5SaWdodE9mZnNldCA9IHJpZ2h0VGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihyaWdodE5vZGUgPT0gbGVmdE5vZGUgJiYgblJpZ2h0T2Zmc2V0ID09IG5MZWZ0T2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB7ICAgLy8gcmlnaHQgcmVkdWNlZCB0byByZWFjaCBsZWZ0IHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihuUmlnaHRPZmZzZXQgPiAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBDaGFyID0gcmlnaHRUZXh0LmNoYXJBdChuUmlnaHRPZmZzZXQgLSAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5yd19pc1doaXRlU3BhY2UodG1wQ2hhcikpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1uUmlnaHRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFwX2NhcmV0UmFuZ2UubGVmdENhcmV0LmlzU3BlY2lhbENhc2UoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFRleHQgPSBsZWZ0Tm9kZS5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbkxlbiA9IGxlZnRUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSh0cnVlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYobkxlZnRPZmZzZXQgPT0gbkxlbilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wTm9kZSA9IGRvbU5hdi5nZXROZXh0VGV4dE5vZGUobGVmdE5vZGUsIGZhbHNlLCByaWdodE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG1wTm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGRvbid0IG1vdmUgYW55IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG1wTm9kZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8vIG1vdmUgdG8gaW1hZ2UgdGhlbiBkb24ndCBtb3ZlIGFueSBmdXJ0aGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdE5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5MZWZ0T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTGVuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnROb2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRUZXh0ID0gbGVmdE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkxlZnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbkxlbiA9IGxlZnRUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJpZ2h0Tm9kZSA9PSBsZWZ0Tm9kZSAmJiBuUmlnaHRPZmZzZXQgPT0gbkxlZnRPZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvLyBsZWZ0IHJlZHVjZWQgdG8gcmVhY2ggcmlnaHQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKG5MZWZ0T2Zmc2V0IDwgbkxlbilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wQ2hhciA9IGxlZnRUZXh0LmNoYXJBdChuTGVmdE9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMucndfaXNXaGl0ZVNwYWNlKHRtcENoYXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbkxlZnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIWJDaGFuZ2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcF9jYXJldFJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIChuZXcgVEhDYXJldFJhbmdlKG5ldyBUSENhcmV0KGxlZnROb2RlLCBuTGVmdE9mZnNldCwgdHJ1ZSksIG5ldyBUSENhcmV0KHJpZ2h0Tm9kZSwgblJpZ2h0T2Zmc2V0LCBmYWxzZSkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiB3aGl0ZXNwYWNlLCBzaG91bGQgcGFzcyBzaW5nbGUgY2hhcmFjdGVyIG9ubHkgdG8gdGhpc1xuICAgIHJ3X2lzV2hpdGVTcGFjZShwX2NoYXIpXG4gICAge1xuICAgICAgICByZXR1cm4gKHBfY2hhci5zZWFyY2goL1tcXHNcXHhhMF0vKSA+IC0xKTtcbiAgICB9XG5cbiAgICAvL3RvZG8gbW92ZSB0aGlzIHRvIHJpZ2h0IGNsYXNzXG4gICAgLyogUmV0dXJucyBUSENhcmV0UmFuZ2UgZm9yIHRoZSBmaXJzdCBzZW50ZW5jZSBpbiB0aGUgcGFnZSBmb3IgYSBnaXZlbiBib2R5XG4gICAgICovXG4gICAgZ2V0U2VudGVuY2VGcm9tUG9pbnRCeUxhbmcgKHBfdGhDYXJldClcbiAgICB7XG4gICAgICAgIHZhciBkb21TZW50ICA9IG5ldyBEb21TZW50ZW5jZXMoKTtcbiAgICAgICAgdmFyIHJpZ2h0Q2FyZXQgPSBkb21TZW50LmdldFNlbnRlbmNlQnJlYWtUb1JpZ2h0KHBfdGhDYXJldCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgbGFuZ3VhZ2UgY2hhbmdlZCBvdmVyIG1vdmVcbiAgICAgICAgLy92YXIgc3RyVm9pY2UgPSByd19nZXRWb2ljZVNldEZvck5vZGUocF90aENhcmV0Lm5vZGUpO1xuLy8gICAgICAgIHZhciBuZXdSaWdodENhcmV0ID0gcndfY2hlY2tGb3JWb2ljZUNoYW5nZShwX3RoQ2FyZXQubm9kZSwgcmlnaHRDYXJldC5ub2RlLCBzdHJWb2ljZSk7XG4vLyAgICAgICAgaWYobmV3UmlnaHRDYXJldCAhPSBudWxsKVxuLy8gICAgICAgIHtcbi8vICAgICAgICAgICAgcmlnaHRDYXJldCA9IG5ld1JpZ2h0Q2FyZXQ7XG4vLyAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZW4gbmVlZCB0byBjaGVjayB0aGF0IG5vIGxhbmd1YWdlIGNoYW5nZXMgYmV0d2VlbiBsZWZ0IGFuZCByaWdodCwgY291bGQgYmUgbXVsdGlwbGUgY2hhbmdlc1xuICAgICAgICB2YXIgbGVmdENhcmV0ID0gZG9tU2VudC5nZXRTZW50ZW5jZUJyZWFrVG9MZWZ0KHJpZ2h0Q2FyZXQpO1xuXG4vLyAgICAgICAgc3RyVm9pY2UgPSByd19nZXRWb2ljZVNldEZvck5vZGUobGVmdENhcmV0Lm5vZGUpO1xuLy8gICAgICAgIHZhciBuZXdMZWZ0Q2FyZXQgPSByd19jaGVja0ZvclZvaWNlQ2hhbmdlUmlnaHRUb0xlZnQobGVmdENhcmV0Lm5vZGUsIHJpZ2h0Q2FyZXQubm9kZSwgc3RyVm9pY2UpO1xuLy8gICAgICAgIGlmKG5ld0xlZnRDYXJldCAhPSBudWxsKVxuLy8gICAgICAgIHtcbi8vICAgICAgICAgICAgbGVmdENhcmV0ID0gbmV3TGVmdENhcmV0O1xuLy8gICAgICAgIH1cbi8vXG4vLyAgICAgICAgaWYobGVmdENhcmV0ID09IG51bGwgfHwgcmlnaHRDYXJldCA9PSBudWxsKVxuLy8gICAgICAgIHtcbi8vICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4vLyAgICAgICAgfVxuICAgICAgICB2YXIgY2FyZXRSYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UoKTtcbiAgICAgICAgY2FyZXRSYW5nZS5zZXRDYXJldFJhbmdlKGxlZnRDYXJldCwgcmlnaHRDYXJldCk7XG5cbiAgICAgICAgcmV0dXJuIGNhcmV0UmFuZ2U7XG4gICAgfTtcblxuXG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGlzIHNwZWNpYWwgb3IgbmVzdGVkIGluIHNwZWNpYWwgY2FzZS5cbiAgICAgKiBAcGFyYW0gcF9ub2RlXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIGlzU3BlY2lhbENhc2VOZXN0ZWQgKHBfbm9kZSlcbiAgICB7XG4gICAgICAgIGlmKHBfbm9kZSAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYm9kID0gdGhpcy5nZXRCb2R5KHBfbm9kZSk7XG4gICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHBfbm9kZTtcbiAgICAgICAgICAgIHdoaWxlKHRtcE5vZGUgIT0gbnVsbCAmJiB0bXBOb2RlICE9IGJvZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzU3BlY2lhbENhc2UodG1wTm9kZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG1wTm9kZSA9IHRtcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qQ2hlY2sgZm9yIHRleHQgY2hhcmFjdGVyIGFzIG9wcG9zc2VkIHRvIHdoaXRlc3BhY2Ugb3Igc3ltYm9sLiAgVXNlZCB0b1xuICAgICBjaGVjayBpZiBjaGFyYWN0ZXIgc3Vycm91bmRpbmcgLiBtYWtlcyB0aGUgLiBwYXJ0IG9mIHRoZSB3b3JkIHJhdGhlciB0aGFuIHNlbnRlbmNlIGJyZWFrLFxuICAgICBoZW5jZSBAIGFuZCBfIGluY2x1ZGVkIGhlcmUuXG4gICAgIGNoZWNrIGlmIGFzY2lpIGNvZGUgaWYgZm9yIGxldHRlciBkaWdpdCBvciBAICBfIGBcbiAgICAgQCAwLTkgYS16IEEtWiBfIGBcbiAgICAgKG5vdGUgaW5sY3VkZSBgIGFuZCBub3QgJyBhcyBjYW4ndCBpbmNsdWRlICcgYXMgd291bGQgdGhlbiBmYWlsIG9uIHNlbnRlbmNlIGluc2lkZSBzaW5nbGUgcXVvdGVzLCBhbmQgYCBkb2Vzbid0IHJlYWxseSBuZWVkIHRvIGJlIGhlcmUgYnV0IHdoZW4gaW5jbHVkaW5nIF8gZWFzaWVyIHRvIGluY2x1ZGUgaXQgdGhhbiBub3QgdG8uKVxuICAgICAqL1xuICAgIHJ3X2lzVGV4dENoYXIocF9uQ29kZSlcbiAgICB7XG4gICAgICAgIHJldHVybiAgKHBfbkNvZGUgPiA0NyAmJiBwX25Db2RlIDwgNTgpIHx8XG4gICAgICAgICAgICAocF9uQ29kZSA+IDYzICYmIHBfbkNvZGUgPCA5MSkgfHxcbiAgICAgICAgICAgIChwX25Db2RlID4gOTQgJiYgcF9uQ29kZSA8IDEyMyk7XG5cbiAgICB9XG5cbiAgICAvKipUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgd2hldGhlciB0aGUgZnVsbCBzdG9wIGlzIHNlbnRlbmNlIGJyZWFrIG9yIG5vdC5cbiAgICAgQ2hlY2sgaWYgZm9sbG93ZWQgYnkgbGV0dGVyIG9yIG51bWJlclxuICAgICBvciBpZiBpcyBhYmJyZXZpYXRpb24gdGhhdCB3ZSByZWNvZ25pc2UuXG4gICAgIENhbiBsb29wIGJhY2sgb24gaXRzZWxmIHRvIGNoZWNrIHByZXZpb3VzIG5vZGUsIGJ1dCBpbiB0aGlzIGNhc2UgcF9ub2RlIGlzIG51bGwgYW5kIGp1c3QgY2hlY2tpbmcgcHJldmlvdXMgdGV4dCBmb3IgZHIgZXRjLlxuXG4gICAgICogQHBhcmFtIHBfdHh0XG4gICAgICogQHBhcmFtIHBfblBvcyBQb3NpdGlvbiBpbiBub2RlIHRoYXQgaXMgZnVsbCBzdG9wIChvciAhPylcbiAgICAgKiBAcGFyYW0gcF9ub2RlXG4gICAgICovXG4gICAgcndfaXNGdWxsU3RvcChwX3R4dCwgcF9uUG9zLCBwX25vZGUpXG4gICAge1xuICAgICAgICB2YXIgZG9tTmF2ID0gbmV3IERvbU5hdmlnYXRpb24oKTtcbiAgICAgICAgdmFyIGJGUyA9IHRydWU7XG4gICAgICAgIHZhciBuTGVuID0gcF90eHQubGVuZ3RoO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIG5leHQgY2hhciBhIGxldHRlciBvciBudW1iZXJcbiAgICAgICAgaWYobkxlbiA+IHBfblBvcyArIDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IHBfdHh0LmNoYXJDb2RlQXQocF9uUG9zICsgMSk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMucndfaXNUZXh0Q2hhcihuZXh0Q2hhcikpXG4gICAgICAgICAgICB7ICAgLy8gZG8gbm90IG5lZWQgdG8gc3BsaXQgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgIC8vIGxvb2sgdG8gbmV4dCBwb2ludFxuICAgICAgICAgICAgICAgIGJGUyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuLy90b2RvIG1hdGhzXG4vLyAgICAgICAgICAgIC8vIGNoZWNrIGZvciAhPVxuLy8gICAgICAgICAgICBpZihnX2JNYXRoc1N5bWJvbHMgJiYgbmV4dENoYXIgPT0gNjEpXG4vLyAgICAgICAgICAgIHsgICAvLyBuZXh0IGNoYXIgaXMgPVxuLy8gICAgICAgICAgICAgICAgaWYocndfbWF0aHNTeW1ib2xDaGVjayhcIiE9XCIpKVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgaXMgXCIhXCJcbi8vICAgICAgICAgICAgICAgICAgICBpZihwX25vZGUgIT0gbnVsbCAmJiBwX25vZGUubm9kZVZhbHVlLmNoYXJBdChwX25Qb3MpID09ICchJylcbi8vICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGJGUyA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoYkZTKVxuICAgICAgICB7ICAgLy8gaWYgYXQgdGhpcyBwb2ludCB0aGUgb3JpZ2luYWwgd2FzIHNvbWV0aGluZyBvdGhlciB0aGFuIC4gc3VjaCBhcyAhID8gIHRoZW4ganVzdCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmKHBfbm9kZSAhPSBudWxsICYmIHBfbm9kZS5ub2RlVmFsdWUuY2hhckF0KHBfblBvcykgIT0gJy4nKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBpZihiRlMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHBfblBvcyA+IDEpXG4gICAgICAgICAgICB7ICAgLy8gY2hlY2sgZm9yIERyIGV0Yy5cbiAgICAgICAgICAgICAgICB2YXIgc3RyMiA9IHBfdHh0LnN1YnN0cmluZyhwX25Qb3MgLSAyLCBwX25Qb3MpO1xuXG4gICAgICAgICAgICAgICAgaWYoXG4gICAgICAgICAgICAgICAgICAgIChzdHIyLmNoYXJBdCgwKSA9PSAnICcgfHwgc3RyMi5jaGFyQXQoMCkgPT0gJ1xcbicgfHwgc3RyMi5jaGFyQXQoMCkgPT0gJ1xccicgfHwgc3RyMi5jaGFyQXQoMCkgPT0gJ1xcdCcpICYmXG4gICAgICAgICAgICAgICAgICAgIHN0cjIuY2hhckNvZGVBdCgxKSA+IDYzICYmXG4gICAgICAgICAgICAgICAgICAgIHN0cjIuY2hhckNvZGVBdCgxKSA8IDkxKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgYW4gaW5pdGlhbCBpLmUuICBNci4gUy4gTWNXaWxsaWFtcyB0aGlzIHdpbGwgc3RvcCBicmVha3MgYXQgdGhlIFMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdpbGwgZ2V0IHNvbWUgbWlzcyBoaXRzIG9uIHRoaXMgYnV0IGNvbnNpZGVyZWQgbW9yZSBpbXBvcnRhbnQgdG8gY2F0Y2ggdGhpcyBjYXNlIHRoYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9jY2Fzc2lvbmFsIG1lcmdlZCBzZW50ZW5jZXMgdGhhdCBpdCB3aWxsIGNhdXNlLlxuICAgICAgICAgICAgICAgICAgICBiRlMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdHIyLmNoYXJBdCgwKSA9PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yd19pc1RleHRDaGFyKHN0cjIuY2hhckNvZGVBdCgxKSkpXG4gICAgICAgICAgICAgICAgeyAgIC8vIGlzIC54LiB3aXRoIHggYmVpbmcgYW55IHRleHQgY2hhci4gIE1vc3QgbGlrZWx5IHRoaXMgaXMgcGFydCBvZiBhbiBhY3JvbnltXG4gICAgICAgICAgICAgICAgICAgIGJGUyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihzdHIyID09IFwiRHJcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyMiA9PSBcIk1yXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cjIgPT0gXCJNc1wiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIyID09IFwiQXZcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyMiA9PSBcIlN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cjIgPT0gXCJlZ1wiKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiRlMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHBfblBvcyA+IDIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHIzID0gcF90eHQuc3Vic3RyaW5nKHBfblBvcyAtIDMsIHBfblBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzdHIzID09IFwiTXJzXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIzID09IFwiZXRjXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIzID09IFwiaS5lXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIzID09IFwiUC5PXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIzID09IFwiUGhEXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkZTID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHBfblBvcyA+IDMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0cjQgPSBwX3R4dC5zdWJzdHJpbmcocF9uUG9zIC0gNCwgcF9uUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzdHI0ID09IFwiUGguRFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYkZTID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgeyAgIC8vIGZpcnN0IGNoYXIgaW4gdHh0LlxuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYocF9ub2RlICE9IG51bGwgJiYgcF9uUG9zID09IDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBsYXN0IHRleHQgbm9kZSBvZiBhbnkga2luZCwgYnV0IG5vdCBwYXN0IGFueSBicmVha3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gZG9tTmF2LmdldFByZXZpb3VzVGV4dE5vZGUocF9ub2RlLCB0cnVlLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRtcE5vZGUgIT0gbnVsbCAmJiB0bXBOb2RlLm5vZGVUeXBlID09MyAmJiB0bXBOb2RlICE9IHBfbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBSZWR1bmRhbnRJZlN0YXRlbWVudEpTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMucndfaXNGdWxsU3RvcCh0bXBOb2RlLm5vZGVWYWx1ZSArIHBfdHh0LCB0bXBOb2RlLm5vZGVWYWx1ZS5sZW5ndGgsIG51bGwpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlYmFfYWJicl9hcnJheT0gbnVsbDtcbiAgICAgICAgaWYoYkZTICYmIGViYV9hYmJyX2FycmF5ICE9IG51bGwgJiYgdHlwZW9mKGViYV9hYmJyX2FycmF5KSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZihlYmFfYWJicl9hcnJheS5sZW5ndGgpID09IFwibnVtYmVyXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuSXRlbXMgPSBlYmFfYWJicl9hcnJheS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBzdHJBYmJyO1xuICAgICAgICAgICAgZm9yKGk9MDsgaTwgbkl0ZW1zOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RyQWJiciA9IGViYV9hYmJyX2FycmF5W2ldO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihzdHJBYmJyKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYocF9uUG9zIC0gc3RyQWJici5sZW5ndGggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocF90eHQuc3Vic3RyaW5nKHBfblBvcyAtIHN0ckFiYnIubGVuZ3RoLCBwX25Qb3MpID09IHN0ckFiYnIpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkZTID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYkZTO1xuICAgIH1cblxuICAgIC8qXG4gICAgIFRoaXMgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBzcGVha2FibGUgdGV4dCBpbiB0aGUgcmFuZ2UuICBSZXR1cm5zIHRydWUgYXMgc29vbiBhcyBtYXRjaCBmb3VuZFxuICAgICBzYXZlcyBwcm9jZXNzaW5nIHdob2xlIHJhbmdlLjxicj5cbiAgICAgdGFrZXMgcF90aENhcmV0UmFuZ2UuXG4gICAgICovXG4gICAgcndfY2FyZXRSYW5nZUlzU3BlYWthYmxlKHBfdGhDYXJldFJhbmdlKVxuICAgIHtcbiAgICAgICAgdmFyIGRvbU5hdiA9IG5ldyBEb21OYXZpZ2F0aW9uKCk7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihwX3RoQ2FyZXRSYW5nZSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgcF90aENhcmV0UmFuZ2UubGVmdENhcmV0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBwX3RoQ2FyZXRSYW5nZS5yaWdodENhcmV0ID09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBoaWRkZW5cbiAgICAgICAgICAgIGlmKHRoaXMucndfY2hlY2tGb3JIaWRkZW5QYXJlbnQocF90aENhcmV0UmFuZ2UubGVmdENhcmV0Lm5vZGUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxlZnRDYXJldCA9IHBfdGhDYXJldFJhbmdlLmxlZnRDYXJldDtcbiAgICAgICAgICAgIHZhciByaWdodENhcmV0ID0gcF90aENhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0gbGVmdENhcmV0Lm5vZGU7XG4gICAgICAgICAgICB2YXIgcmlnaHROb2RlID0gcmlnaHRDYXJldC5ub2RlO1xuXG4gICAgICAgICAgICB2YXIgYkluaXRpYWxMb29wID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBiU3BlY2lhbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGN1ck5vZGUgPSBsZWZ0Tm9kZTtcbiAgICAgICAgICAgIHZhciB0eHQgPSBcIlwiO1xuICAgICAgICAgICAgd2hpbGUoY3VyTm9kZSAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJTcGVjaWFsID0gdGhpcy5pc1NwZWNpYWxDYXNlKGN1ck5vZGUpO1xuXG4vLyAgICAgICAgICAgICAgICB0b2RvIGlmKFNwZWVjaFN0cmVhbS5wYXVzZUhhbmRsZXIuaXNQYXVzZUVsZW1lbnQoY3VyTm9kZSkpXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgYlNwZWNpYWwgPSB0cnVlO1xuLy8gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoYlNwZWNpYWwgfHwgY3VyTm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IGRvbU5hdi5nZXRUZXh0RnJvbU5vZGUoY3VyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcCAhPSBudWxsICYmIHRtcCAhPSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighYlNwZWNpYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3VyTm9kZSA9PSByaWdodE5vZGUgJiYgcmlnaHRDYXJldC5vZmZzZXQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5zdWJzdHJpbmcoMCwgcmlnaHRDYXJldC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJOb2RlID09IGxlZnROb2RlICYmIGxlZnRDYXJldC5vZmZzZXQgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLnN1YnN0cmluZyhsZWZ0Q2FyZXQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMucndfaXNXb3JkU3BlYWthYmxlKHRtcCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihiU3BlY2lhbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN1ck5vZGUgPSBkb21OYXYuZ2V0TmV4dE5vZGVJZ25vcmVDaGlsZHJlbihjdXJOb2RlLCBmYWxzZSwgcmlnaHROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoYkluaXRpYWxMb29wKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJOb2RlID0gZG9tTmF2LmdldE5leHROb2RlQWxsb3dNb3ZlVG9DaGlsZChjdXJOb2RlLCB0cnVlLCByaWdodE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyTm9kZSA9IGRvbU5hdi5nZXROZXh0Tm9kZShjdXJOb2RlLCBmYWxzZSwgcmlnaHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiSW5pdGlhbExvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBwbGF5IHBvaW50IGNvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYSBwb2ludCBpbiB0aGUgcGFnZSB0aGF0IGlzIGhpZGRlbiBidXQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCByZXBvcnQgYXMgaGlkZGVuLlxuICAgICAqIGkuZS4gaWYgYSBoaWdoZXIgZWxlbWVudCBpcyBzZXQgdG8gZGlzcGxheSBub25lIGluIGNzcyB0aGVuIG5lc3RlZCBlbGVtZW50cyBkbyBub3QgcmVwb3J0IHRoaXMgZXZlbiB0aHJvdWdoXG4gICAgICogY29tcHV0ZWQgc3R5bGUuICAoU291bmRzIGxpa2UgYnJvd3NlciBidWcgYnV0IGV4aXN0cyBhY3Jvc3MgYnJvd3NlcnMgc28gbWF5YmUgZGVsaWJlcmF0ZSBmb3Igc29tZSByZWFzb24uKVxuICAgICAqIE5lZWQgdG8gY2hlY2sgY29tcHV0ZWQgc3R5bGUgb24gYWxsIHBhcmVudHMgYXMgd2VsbFxuICAgICAqXG4gICAgICogQHBhcmFtIHBfbm9kZSBzdGFydCBwb2ludFxuICAgICAqIHJldHVybnMgdHJ1ZSBmb3IgaGlkZGVuIGZvdW5kLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcndfY2hlY2tGb3JIaWRkZW5QYXJlbnQocF9ub2RlKVxuICAgIHtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSBwYXJlbnQgaXMgZGlzcGxheSBub25lLlxuICAgICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB0aGlzLmdldENvbXB1dGVkU3R5bGUocF9ub2RlKTtcbiAgICAgICAgICAgIGlmKGNvbXB1dGVkU3R5bGUgIT0gbnVsbCAmJiAoY29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiIHx8IGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSA9PSBcImhpZGRlblwiKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHBfbm9kZTtcbiAgICAgICAgICAgICAgICB2YXIgYm9kID0gdG1wTm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgd2hpbGUodG1wTm9kZSAhPSBib2QpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0bXBOb2RlID0gdG1wTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmdldENvbXB1dGVkU3R5bGUodG1wTm9kZSkuZGlzcGxheSA9PSBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSlcbiAgICAgICAgey8qKi99XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyogUmV0dXJucyB0aGUgVEhEb21SZWZQdCB0byB0aGUgcGFyZW50IHRoYXQgY29udGFpbnMgdGhlIHRhcmdldCBub2RlIGFuZFxuICAgICBpcyBub3QgbGlrZWx5IHRvIGJlIHJlbW92ZWQgYnkgcndvbmxpbmUgYmFyLiAgaS5lLiBza2lwcyBlbGVtZW50IGFkZGVkXG4gICAgIGZvciBzcGVlY2ggYW5kIGhpZ2hsaWdodGluZyBhcyBjYW4gYmUgcmVtb3ZlZCBhdCBhbnkgdGltZS5cbiAgICAgSWYgcF9ub2RlIGlzIGFuIGVsZW1lbnQgcmF0aGVyIHRoYW4gYSB0ZXh0IG5vZGUgdGhlIG9mZnNldCBpcyB1c2VkIGRpcmVjdGx5LCBpZiBkb250XG4gICAgIHdhbnQgaXQgdG8gZ28gZG93biB0byB0ZXh0IHdoZW4gcmVzb2x2aW5nIGl0IHBhc3MgYSBuZWdhdGl2ZSBudW1iZXJcbiAgICAgKi9cbiAgICByd19nZXRSZWZQdChwX25vZGUsIHBfbk9mZnNldClcbiAgICB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKCk7XG4gICAgICAgIHZhciBSV1RIX0dFTkVSQVRFRCA9IFwicndUSGdlblwiK1wiXCIgO1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gaWYgdGV4dCBub2RlIHdhbnQgcmVmIHRvIHBhcmVudCB3aXRoIG9mZnNldCB0byBnZXQgdG8gcmlnaHQgcG9pbnRcbiAgICAgICAgICAgIC8vIGlmIHBhc3NlZCBlbGVtZW50IHdhbnQgZGlyZWN0IHJlZiB0byBpdCBhbmQgb2Zmc2V0IGlzIGlycmVsZXZhbnRcbiAgICAgICAgICAgIGlmKHBfbm9kZSA9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihwX25vZGUubm9kZVR5cGUgPT0gMSB8fCBwX25vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0ZXh0IGlzIGluc2lkZSBzcGVjaWFsIGNhc2VcblxuICAgICAgICAgICAgICAgIHZhciB0bXBQYXIgPSB0aGlzLmNoZWNrRm9yU3BlY2lhbFBhcmVudChwX25vZGUpO1xuICAgICAgICAgICAgICAgIGlmKHRtcFBhciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHsgICAvLyBpcyBpbiBzcGVjaWFsIGNhc2Ugc28gbmVlZCB0byBleHRlbmQgcmFuZ2UgdG8gaW5jbHVkZSB3aG9sZSBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhEb21SZWZQdCh0aGlzLmdldFBvc2l0aW9uSW5Eb20odG1wUGFyKSwgcF9uT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgb2Zmc2V0IG9mIHBhc3NlZCBub2RlXG4gICAgICAgICAgICAgICAgdmFyIG5PZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGhlUGFyZW50O1xuXG4gICAgICAgICAgICAgICAgaWYocF9ub2RlLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhlUGFyZW50ID0gcF9ub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXVzZXMgYSBwcm9ibGVtIGluIHRpbnltY2UsIG5vdCBzdXJlIHdoeSB0aGlzIGlzIHRoZXJlLCBidXQgYmVlbiBsb25nIHRpbWUgc28gcmlzayBvZiBzb21lXG4gICAgICAgICAgICAgICAgICAgIC8vIGJpemFycmUgc2lkZSBhZmZlY3QgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgLy90b2RvIGNoZWNrIGhvdyB0aGlzIGFmZmVjdHMgc3RpY2t5IG5vdGVzLlxuLy8gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjaGVjayBmb3Igc2VsZWN0aW5nIG5vZGUgd2hlcmUgaXMgaW4gd2hpdGVzcGFjZSBvbmx5IGVsZW1lbnQsIG1pZ2h0IG9ubHkgZXhpc3Qgb25cbi8vICAgICAgICAgICAgICAgIC8vIGZpcmVmb3hcbi8vICAgICAgICAgICAgICAgIGlmKHBfbm9kZS5ub2RlVmFsdWUudHJpbVRIKCkubGVuZ3RoID09IDApXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICBwX25PZmZzZXQgPSAwO1xuLy8gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgPSB0aGlzLnJ3X2dldE5vZGVPZmZzZXQocF9ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhlUGFyZW50ID0gcF9ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRoZVBhcmVudCwgXCJyd3N0YXRlXCIpO1xuICAgICAgICAgICAgICAgIHZhciB0aGdlbkF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRoZVBhcmVudCwgUldUSF9HRU5FUkFURUQpO1xuICAgICAgICAgICAgICAgIHdoaWxlKCAoYXR0ciAhPSBudWxsICYmIGF0dHIubGVuZ3RoID4gMCkgfHwgdGhnZW5BdHRyIT0gbnVsbCApXG4gICAgICAgICAgICAgICAgeyAgIC8vIEl0IGlzIGEgcndvbmxpbmUgYWRkZWQgZWxlbWVudCBtb3ZlIHVwIGFnYWluICggc3Mgc3Agb3IgY3NwKVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpcyBhdXRvZ2VuZXJhdGUgc3BhbiB0YWcgZm9yIHNwbGl0IHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBmb250IGVsZW1lbnQgYXMgdGhpcyBhZGRlZCBieSBJRSBmb3IgaGlnaGxpZ2h0aW5nXG4gICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgKz0gdGhpcy5yd19nZXROb2RlT2Zmc2V0KHRoZVBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoZVBhcmVudCA9IHRoZVBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZSh0aGVQYXJlbnQsIFwicndzdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhnZW5BdHRyID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZSh0aGVQYXJlbnQsIFJXVEhfR0VORVJBVEVEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYocF9uT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgIHsgICAvLyBjYXNlIG9mIHRleHQgbm9kZSBpbiBhIHNwZWNpYWwgY2FzZSAoYWJicilcbiAgICAgICAgICAgICAgICAgICAgbk9mZnNldCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIRG9tUmVmUHQodGhpcy5nZXRQb3NpdGlvbkluRG9tKHRoZVBhcmVudCksIG5PZmZzZXQgKyBwX25PZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGlnbm9yZSlcbiAgICAgICAgeyAgIC8vIGxpa2VseSBpbnZhbGlkIG5vZGUgcGFzc2VkIGdpdmluZyBudWxsIHBhcmVudFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIHRleHQgb2Zmc2V0IG9mIHRoZSBub2RlIGZyb20gYWxsIHRleHQgY29udGFpbmVkIGJ5IHRoZSBwYXJlbnQuXG4gICAgcndfZ2V0Tm9kZU9mZnNldChwX25vZGUpXG4gICAge1xuICAgICAgICBpZihwX25vZGUgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5PZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBwX25vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZihsZWZ0Tm9kZSAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBuT2Zmc2V0ID0gdGhpcy5yd19nZXROb2RlT2Zmc2V0SW1wbChsZWZ0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5PZmZzZXQ7XG4gICAgfVxuXG4gICAgZ2V0UG9zaXRpb25JbkRvbSAocF90aGVOb2RlKVxuICAgIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgdmFyIHN0clBvcyA9IFwiXCI7XG4gICAgICAgIHZhciBuTGVmdENvdW50ID0gMDtcbiAgICAgICAgdmFyIHByZWZpeCA9IFwiXCI7XG4gICAgICAgIGlmKHBfdGhlTm9kZSAhPSBudWxsICYmIHBfdGhlTm9kZS5vd25lckRvY3VtZW50ICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBiV2FzTGFzdFRleHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBiSXNUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYm9kID0gcF90aGVOb2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIHdoaWxlKHBfdGhlTm9kZSAhPSBudWxsICYmIHBfdGhlTm9kZSAhPSBib2QpXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzU3BlY2lhbENhc2UocF90aGVOb2RlKSlcbiAgICAgICAgICAgICAgICB7ICAgLy8gcmVzZXQgcGF0aCBzbyBkaXJlY3RzIHN0cmFpZ2h0IHRvIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgc3RyUG9zID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYldhc0xhc3RUZXh0ID0gKHBfdGhlTm9kZS5ub2RlVHlwZSA9PSAzKSB8fFxuICAgICAgICAgICAgICAgICAgICAocF90aGVOb2RlLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBfdGhlTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gQ29uc3RhbnRzLkhJR0hMSUdIVF9UQUcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocF90aGVOb2RlLCBcInJ3c3RhdGVcIikgIT0gbnVsbCk7ICAvLyBzZXQgdHJ1ZSBpZiB0ZXh0IGZvciBvcmlnLlxuICAgICAgICAgICAgICAgIHZhciBhTm9kZSA9IHBfdGhlTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgd2hpbGUoYU5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJJc1RleHQgPSAoYU5vZGUubm9kZVR5cGUgPT0gMykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChhTm9kZS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IENvbnN0YW50cy5ISUdITElHSFRfVEFHICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShhTm9kZSwgXCJyd3N0YXRlXCIpICE9IG51bGwpOyAvLyBzZXQgZm9yIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBpZihiV2FzTGFzdFRleHQgJiYgYklzVGV4dClcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGRvbnQgaW5jcmVtZW50IGZvciB0d28gdGV4dCBub2RlcyB0b2dldGhlclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytuTGVmdENvdW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFOb2RlID0gYU5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBiV2FzTGFzdFRleHQgPSBiSXNUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJQb3MgPSBzdHJQb3MgKyBuTGVmdENvdW50ICsgXCJ+XCI7XG4gICAgICAgICAgICAgICAgbkxlZnRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgcF90aGVOb2RlID0gcF90aGVOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYocF90aGVOb2RlICE9IG51bGwgJiYgcF90aGVOb2RlLmdldEF0dHJpYnV0ZSAhPSBudWxsICYmIHBfdGhlTm9kZS50YWdOYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHRtcCA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocF90aGVOb2RlLCBcImNodW5rXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZihwX3RoZU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3BhblwiICYmIHR0bXAgPT0gXCIxXCIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lclBvcyA9IHRoaXMuZ2V0UG9zaXRpb25JbkRvbShwX3RoZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCIjXnRoKlwiICsgaW5uZXJQb3MgKyBcIiNedGgqXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHN0clBvcztcbiAgICB9O1xuXG5cblxuXG5cbiAgICAvLyByZXR1cm4gcG9zIG9mIHdvcmQgYnJlYWsgaW4gdGV4dFxuICAgIHJ3X2dldEJyZWFrSW5DdXJyZW50V29yZChwX3R4dClcbiAgICB7ICAgLy8gbG9vayBmb3Igbm9uIGNoYXJhY3RlciBvciBkaWdpdCBvciBfXG4gICAgICAgIGlmKHBfdHh0ID09IG51bGwgfHwgcF90eHQubGVuZ3RoID09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwX3R4dC5zZWFyY2goXCJbXCIrU3RyaW5nLmZyb21DaGFyQ29kZSggODIxMikrXCJcXFxcc1xcXCJdXCIpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgaWYgYXNjaWkgY29kZSBpZiBmb3IgbGV0dGVyXG4gICAgcndfaXNMZXR0ZXIocF9uQ29kZSlcbiAgICB7XG4gICAgICAgIHJldHVybiAgKHBfbkNvZGUgPiA2NCAmJiBwX25Db2RlIDwgOTEpIHx8XG4gICAgICAgICAgICAocF9uQ29kZSA+IDk2ICYmIHBfbkNvZGUgPCAxMjMpO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgdGV4dCBvZmZzZXQgb2YgdGhlIG5vZGUgZnJvbSBhbGwgdGV4dCBjb250YWluZWQgYnkgdGhlIHBhcmVudC5cbiAgICByd19nZXROb2RlT2Zmc2V0SW1wbChwX25vZGUpXG4gICAge1xuICAgICAgICB2YXIgbk9mZnNldCA9IDA7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IHBfbm9kZTtcbiAgICAgICAgdmFyIHRtcFR4dDtcbiAgICAgICAgd2hpbGUobGVmdE5vZGUgIT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYobGVmdE5vZGUubm9kZVR5cGUgPT0gMyAmJiAhdGhpcy5pc0lnbm9yZWQobGVmdE5vZGUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcFR4dCA9IGxlZnROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICBuT2Zmc2V0ICs9IHRtcFR4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKGxlZnROb2RlLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuaXNJbnZhbGlkTm9kZShsZWZ0Tm9kZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmlzU3BlY2lhbENhc2UobGVmdE5vZGUpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuT2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihsZWZ0Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT0gXCJ0ZXh0YXJlYVwiKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuT2Zmc2V0ICs9IHRoaXMucndfZ2V0Tm9kZU9mZnNldEltcGwobGVmdE5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgKz0gMTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBpZiBvdGhlciBub24gZWxlbWVudCB0eXBlIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGxlZnROb2RlID0gbGVmdE5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuT2Zmc2V0O1xuICAgIH1cblxuICAgIHJ3X2dldENhcmV0RnJvbVJlZlB0KHBfYm9keSwgcF9yZWZQdClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhcmV0RnJvbURvbVBvc2l0aW9uKHBfYm9keSwgcF9yZWZQdC5wYXRoLCBwX3JlZlB0Lm9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLypUaGlzIHVzZXMgYSBwb3NpdGlvbiBpbiB0aGUgZG9tIHRvIGdldCB0aGUgdGV4dCBub2RlIHJlZmVycmVkIHRvLlxuICAgICBUaGUgb2Zmc2V0IGlzIHVzZWQgdG8gaGFuZGxlIGNhc2Ugd2VyZSB0aGUgdGFyZ2V0IG5vZGUgaGFzIGJlZW4gc3BsaXQgYW5kXG4gICAgIHRoZSB0YXJnZXQgd29yZCBpcyBub3QgaW4gdGhlIGZpcnN0IHBhcnQuICBTZXQgdG8gcF9uUG9zIHRvIDAgdG8gYWx3YXlzIGdldCB0aGVcbiAgICAgZmlyc3QgdGV4dCBub2RlIHJlZ2FyZGxlc3Mgb2Ygc3BsaXQuICBTZXQgcF9uUG9zIHRvIC0xIHRvIGdldCB0aGUgdGFyZ2V0IG5vZGVcbiAgICAgZXZlbiBpZiBpdCBpcyBub3cgYW4gZWxlbWVudCBhbmQgbm90IGEgdGV4dCBub2RlLlxuICAgICA8cD5cbiAgICAgTkIgY291bnQgbXVsdGlwbGUgdGV4dCBub2RlcyB0b2dldGhlciBhcyBzaW5nbGUgaXRlbS4gIFRleHQgY291bGQgYmUgc3BsaXRcbiAgICAgc2luY2UgdGhlIGNvdW50IG1hZGUuICBBbHNvIHRvIG1hdGNoIHRoaXMgd2hlbiBjb3VudGluZyB0YWtlIGFkamFjZW50IHRleHQgbm9kZXMgYXMgb25lLlxuICAgICA8cD5cbiAgICAgRm9yIHNwZWNpYWwgY2FzZSwgZGlyZWN0cyB0byBlbGVtZW50IG5vZGUgbm90IHRleHQgbm9kZSwgaGVyZSBuZWVkIHRvIHRha2UgZWl0aGVyIHN0YXJ0IG9yIGVuZCBvZiBjb250YWluZWQgdGV4dCBiYXNlZCBvbiBwX2JGb3J3YXJkQmlhc1xuICAgICA8cD5cbiAgICAgcF90aGVCb2R5IHRvIGJvZHkgY29udGFpbmluZyB0aGUgbm9kZSB0aGF0IHBhdGggaXMgcmVmZXJlbmNlZCBmcm9tXG4gICAgIHBfc3RyUGF0aCB0aGUgcGF0aCBmcm9tIHRoZSBib2R5XG4gICAgIHBfblBvcyB0aGUgb2Zmc2V0XG4gICAgIHBfYkZvcndhcmRCaWFzIHNldCB0cnVlIGlmIGNhcmV0IGlzIHRvIHJlZmVyIHRvIGNoYXJhY3RlciBhZnRlciBpdHNlbGYsIGZhbHNlIGlmIGlzIHRvIHJlZmVyIHRvIGNoYXJhY3RlciBiZWZvcmUgaXRcbiAgICAgPHA+IFJldHVybnMgVEhDYXJldCBvYmplY3QgY29udGFpbmluZyB0aGUgbm9kZSBhbmQgb2Zmc2V0LlxuICAgICAqL1xuICAgIGdldENhcmV0RnJvbURvbVBvc2l0aW9uIChwX3RoZUJvZHksIHBfc3RyUGF0aCwgcF9uUG9zLCBwX2JGb3J3YXJkQmlhcywgcF9iRm9yY2VTcGVjaWFsKVxuICAgIHtcbiAgICAgICAgdmFyIGRvbU5hdiA9IG5ldyBEb21OYXZpZ2F0aW9uKCk7XG4gICAgICAgIGlmKHR5cGVvZihwX2JGb3JjZVNwZWNpYWwpID09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBfYkZvcmNlU3BlY2lhbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHBfdGhlQm9keSA9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBub2RlIGZyb20gdGhlIHBvc2l0aW9uIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRoZU5vZGUgPSBkb21OYXYuZ2V0Tm9kZUZyb21Qb3NpdGlvbihwX3RoZUJvZHksIHBfc3RyUGF0aCk7XG5cbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIGl0IGlzIGEgc3BlY2lhbCBjYXNlXG5cbiAgICAgICAgICAgIGlmKHBfYkZvcmNlU3BlY2lhbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wQ2FyZXQgPSBuZXcgVEhDYXJldCh0aGVOb2RlLCAwLCBwX2JGb3J3YXJkQmlhcyk7XG4gICAgICAgICAgICAgICAgdG1wQ2FyZXQuc2V0U3BlY2lhbENhc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcENhcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHRoaXMuY2hlY2tGb3JTcGVjaWFsUGFyZW50KHRoZU5vZGUpO1xuXG4gICAgICAgICAgICBpZih0bXBOb2RlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhlTm9kZSA9IHRtcE5vZGU7XG5cbiAgICAgICAgICAgICAgICAvL2lmIG5vdCBhIGhpZ2hsaWdodGFibGUgb25lIHNob3VsZCBqdXN0IHJldHVybiB0aGUgaXRlbVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNTcGVjaWFsQ2FzZUhpZ2hsaWdodGFibGUodG1wTm9kZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihwX2JGb3J3YXJkQmlhcylcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGdldCBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGRvbU5hdi5nZXRGaXJzdENoaWxkVGV4dE5vZGUodGhlTm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnROb2RlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHN0YXJ0Tm9kZSwgMCwgcF9iRm9yd2FyZEJpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyZWF0IGFzIG5vbiBoaWdobGlnaHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHRoZU5vZGUsIDAsIHBfYkZvcndhcmRCaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHsgICAvL2dldCBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gZG9tTmF2LmdldExhc3RDaGlsZFRleHROb2RlKHRoZU5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVuZE5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlbmROb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIQ2FyZXQoZW5kTm9kZSwgZW5kTm9kZS5sZW5ndGgsIHBfYkZvcndhcmRCaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgICAvLyBpcyBpbWcgd2l0aCBtc2csIG5vdCBoaWdobGlnaHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhDYXJldChlbmROb2RlLCAwLCBwX2JGb3J3YXJkQmlhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8vIHRyZWF0IGFzIG5vbiBoaWdobGlnaHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHRoZU5vZGUsIDAsIHBfYkZvcndhcmRCaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIQ2FyZXQodG1wTm9kZSwgMCwgcF9iRm9yd2FyZEJpYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgbk9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZighcF9iRm9yd2FyZEJpYXMpXG4gICAgICAgICAgICB7ICAgLy8gTG9va2luZyBmb3IgY2FyZXQgcG9zaXRpb24ganVzdCBiZWZvcmUgdGhlIHBfblBvcyBwb2ludCBzbyBuZWVkIHRvIGJlIGNvbXBhcmluZyB0byArMSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICsrbk9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocF9uUG9zID4gLTEpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gZm91bmQgbm9kZSwgYnV0IG1heSBoYXZlIGJlZW4gc3Vic2VxdWVudGx5IHNwbGl0LCBzbyBuZWVkIHRvIGNoZWNrIHBhc3NlZCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIGlzIGluc2lkZSBpdFxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBkb2VzbnQgZ28gcGFzdCBwYXJlbnRcbiAgICAgICAgICAgICAgICBpZih0aGVOb2RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgeyAgIC8vZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiTWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gdGhlTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0U2FmZU5vZGUgPSB0aGVOb2RlO1xuICAgICAgICAgICAgICAgIHZhciB0bXBUeHQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSghYk1hdGNoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhlTm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBUeHQgPSB0aGVOb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjaGVjayBpZiBpbiBcIiArIHRoZU5vZGUubm9kZVZhbHVlICsgXCIgIHdoZXJlIG9mZnNldCBpcyBcIiArIG5PZmZzZXQgKyBcIiBhbmQgcG9zIFwiICsgcF9uUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBfblBvcyA8IChuT2Zmc2V0ICsgdG1wVHh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7IC8vIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInllc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2FmZU5vZGUgPSB0aGVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbk9mZnNldCArPSB0aGVOb2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZU5vZGUgPSBkb21OYXYuZ2V0TmV4dE5vZGUodGhlTm9kZSwgZmFsc2UsIGVuZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodGhlTm9kZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICB7ICAgLy8gY2hlY2sgaWYgc3BlY2lhbCBjYXNlIG9mIG5vZGUsIGkuZS4gZWxlbWVudCB0aGF0IGNhbiBiZSBzcG9rZW4gKGltZyB3aXRoIG1zZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcE5vZGUgPSB0aGlzLmNoZWNrRm9yU3BlY2lhbFBhcmVudCh0aGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRtcE5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVOb2RlID0gdG1wTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaWdodCBoYXZlIGZvdW5kIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBvZmZzZXQgc2hvdWxkIG5vdCB0YWtlIGl0IG9uIHBhc3QgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHBfblBvcyBtYXRjaGVzIG5PZmZzZXQgdGhlbiBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuRGlmZiA9IHBfblBvcyAtIG5PZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihuRGlmZiA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNhcnJ5IG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGNoaWxkcmVuIHNvIGRvIG5vdCBpbmNsdWRlIHRleHQgb2Ygc3BlY2lhbCBub2RlIGFuZCBhbHNvIGluY2x1ZGUgdGhlICsxIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVOb2RlID0gZG9tTmF2LmdldE5leHROb2RlSWdub3JlQ2hpbGRyZW4odGhlTm9kZSwgZmFsc2UsIGVuZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZU5vZGUgPSBkb21OYXYuZ2V0TmV4dE5vZGUodGhlTm9kZSwgZmFsc2UsIGVuZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGVOb2RlICsgXCIgXCIgKyB0aGVOb2RlLnRhZ05hbWUgKyBcIiBcIiArIHRoZU5vZGUubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhlTm9kZSA9PSBudWxsIHx8IHRoZU5vZGUgPT0gZW5kTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgeyAgICAgICAgICAgIC8vIGFsZXJ0KFwiIFwiICsgcF9zdHJQYXRoICsgXCIgPD0+IFwiICsgcF9uUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2hvdWxkbnQgcmVhbGx5IGhhcHBlbiwgYnV0IGRvbnQgYWx3YXlzIGhhdmUgdmFsaWQgZGF0YSBzbyB0aGlzIGNhdGNoZXMgdGhlIGRvZGd5IGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbiBoYXBwZW4gZHVlIHRvIG9mZnNldCBjYWxjdWxhdGlvbiBiZWluZyB3cm9uZywgc29tZSBlbGVtZW50cyBjYW4gZ2l2ZSB1bmV4cGVjdGVkIG9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzIGRvIG5vdCBrbm93IGV4YWN0bHkgaG93IHRoZSBkaWZmZXJlbnQgYnJvd3NlcnMgd29yayBpdCBvdXQgZm9yIHRoZW1zZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0luIHRoaXMgY2FzZSB1c2UgbGFzdCBzYWZlIG9mZnNldCwgbW9zdCBsaWtlbHkgd29yayBvciBhdCBsZWFzdCBoaWdobGlnaHQgbW9zdCBvZiB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihsYXN0U2FmZU5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVOb2RlID0gbGFzdFNhZmVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoZU5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBvZiBuT2Zmc2V0IHNldCBiZWxvdyBpcyBwdXJlbHkgZG9uZSB0byBjYW5jZWwgb3V0IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0aW9uIGZ1cnRoZXIgZG93biBmb3IgbmV3IFRIQ2FyZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk9mZnNldCA9IHBfblBvcyAtIHRoZU5vZGUubm9kZVZhbHVlLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8vIHN1Y2ggYXMgaW1nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFwX2JGb3J3YXJkQmlhcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbk9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidGhlTm9kZSBcIiArIHRoZU5vZGUgKyBcIiAgIFwiICsgdGhlTm9kZS5ub2RlVmFsdWUgKyBcIiAgZnJvbSBcIiArIHBfc3RyUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYocF9iRm9yd2FyZEJpYXMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIQ2FyZXQodGhlTm9kZSwgcF9uUG9zIC0gbk9mZnNldCwgcF9iRm9yd2FyZEJpYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeyAgIC8vIHJlbWVtYmVyIHRvIHJlbW92ZSB0aGUgZXh0cmEgcGFydCBhZGRlZCBvbiB0byBzdG9wIGdvaW5nIHRvIG5leHQgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHRoZU5vZGUsIHBfblBvcyAtIChuT2Zmc2V0IC0gMSksIHBfYkZvcndhcmRCaWFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHRoZU5vZGUsIHBfblBvcywgcF9iRm9yd2FyZEJpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycilcbiAgICAgICAgeyAgIC8vIExpa2VseSB0aGF0IHBhdGggaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImdldENhcmV0RnJvbURvbVBvc2l0aW9uIGVycm9yOiBcIiArIGVycik7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdmFsaWQgbm9kZXMgb3ZlciBhIHJhbmdlIChpbmNsdXNpdmUpLiAgVGhpcyB3aWxsIHNraXAgaW52YWxpZCBhbmQgaWdub3JlZCBub2Rlcy5cbiAgICAgKiBJdCB3aWxsIGdvIG92ZXIgcmFuZ2UgcmVnYXJkbGVzcyBvZiBzZW50ZW5jZSBicmVha3MuXG4gICAgICpcbiAgICAgKiBJZiBubyB2YWxpZCBub2RlcyBsaXN0IGlzIGVtcHR5LlxuICAgICAqIEBwYXJhbSBwX3N0YXJ0Tm9kZVxuICAgICAqIEBwYXJhbSBwX2VuZE5vZGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0Tm9kZXNPdmVyUmFuZ2UgKHBfc3RhcnROb2RlLCBwX2VuZE5vZGUpXG4gICAge1xuICAgICAgICB2YXIgZG9tTmF2ID0gbmV3IERvbU5hdmlnYXRpb24oKTtcbiAgICAgICAgdmFyIHJlc3VsdExpc3QgPSBbXTtcblxuICAgICAgICBpZihwX3N0YXJ0Tm9kZSA9PSBudWxsIHx8IHBfZW5kTm9kZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJOb2RlID0gcF9zdGFydE5vZGU7XG5cbiAgICAgICAgd2hpbGUoY3VyTm9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYodGhpcy5pc0ludmFsaWROb2RlKGN1ck5vZGUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGN1ck5vZGUgPSBkb21OYXYuZ2V0QWN0dWFsTmV4dE5vZGVJZ25vcmVDaGlsZHJlbihjdXJOb2RlLCBwX2VuZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmlzSWdub3JlZChjdXJOb2RlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdExpc3QucHVzaChjdXJOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyTm9kZSA9IGRvbU5hdi5nZXRBY3R1YWxOZXh0Tm9kZShjdXJOb2RlLCBwX2VuZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdExpc3Q7XG4gICAgfTtcblxuXG5cblxuLy9nZXQgd2luZG93IGZyb20gbm9kZVxuICAgIGdldFdpbmRvdyAocF9ub2RlKVxuICAgIHtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHBfbm9kZSA9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHRvcC5mcmFtZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7ICAgLy8gY2hlY2sgZnJhbWVzXG4gICAgICAgICAgICAgICAgdmFyIGN1ckJvZHkgPSBwX25vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVCb2R5ID0gd2luZG93LmRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgaWYoY3VyQm9keSA9PT0gYWN0aXZlQm9keSlcbiAgICAgICAgICAgICAgICB7ICAgLy8gU2FtZSB3aW5kb3cgdGhhdCBoYXMgdGhlIHRvb2xiYXIuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgICAgICBpZighZ19iSWdub3JlRnJhbWVzKSB0b2RvIGlzIHRoaXMgbmVlZGVkXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTsgdmFyIG5MZW4gPSB0b3AuZnJhbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpPG5MZW47IGkrKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBlcnJvciBkdWUgdG8gY3Jvc3MgZG9tYWluIGlzc3Vlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBCb2QgPSB0b3AuZnJhbWVzW2ldLmRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodG1wQm9kID09PSBjdXJCb2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvcC5mcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmFtZXMgZXhpc3Qgd2l0aCBkaWZmZXJlbnQgZG9tYWluIHNvIGNhbm5vdCBhY2Nlc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVycm9yIGdldFdpbmRvdzogXCIgKyBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9ubyBtYXRjaCBkZWZhdWx0IHRvIG1haW4gd2luZG93IHJhdGhlciB0aGFuIG51bGw7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfTtcblxuICAgIHJ3X2dldFRleHRSYW5nZUFzVEhSYW5nZShwX2JvZHksIHBfdGV4dFJhbmdlKVxuICAgIHtcbiAgICAgICAgdmFyIHRtcFJhbmdlID0gcF90ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgIHRtcFJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICB2YXIgc3RhcnRSZWZQdCA9IHJ3X2dldFRleHRSYW5nZUFzUmVmUHRJRShwX2JvZHksIHRtcFJhbmdlKTtcblxuICAgICAgICB0bXBSYW5nZSA9IHBfdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICB0bXBSYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgIHZhciBlbmRSZWZQdCA9IHJ3X2dldFRleHRSYW5nZUFzUmVmUHRJRShwX2JvZHksIHRtcFJhbmdlKTtcblxuXG4gICAgICAgIHJldHVybiBuZXcgVEhSYW5nZShwX2JvZHksIHN0YXJ0UmVmUHQsIGVuZFJlZlB0KTtcbiAgICB9XG5cbiAgICAvL2dldCBhcyBpZSB0ZXh0cmFuZ2Ugb2JqZWN0XG4gICAgcndfZ2V0QXNUZXh0UmFuZ2UocF9ib2R5LCBwX3N0ckxlZnRQYXRoLCBwX25MZWZ0T2Zmc2V0LCBwX3N0clJpZ2h0UGF0aCwgcF9uUmlnaHRPZmZzZXQpXG4gICAge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlT2JqZWN0KHBfYm9keSk7XG5cbiAgICAgICAgdmFyIGNhcmV0UmFuZ2UgPSAgbmV3IFRIQ2FyZXRSYW5nZShwX2JvZHksIHBfc3RyTGVmdFBhdGgsIC0xLCBwX3N0clJpZ2h0UGF0aCwgLTEpO1xuICAgICAgICB2YXIgbGVmdENhcmV0ID0gY2FyZXRSYW5nZS5sZWZ0Q2FyZXQ7XG4gICAgICAgIHZhciByaWdodENhcmV0ID0gY2FyZXRSYW5nZS5yaWdodENhcmV0O1xuXG4gICAgICAgIGlmKGxlZnRDYXJldCAhPSBudWxsICYmIGxlZnRDYXJldC5ub2RlICE9IG51bGwgJiYgcmlnaHRDYXJldCAhPSBudWxsICYmIHJpZ2h0Q2FyZXQubm9kZSAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbE5vZGUgPSBsZWZ0Q2FyZXQubm9kZTtcbiAgICAgICAgICAgIGlmKGxOb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIG5PZmZzZXQgPSB0aGlzLnJ3X2dldE5vZGVPZmZzZXQobE5vZGUpO1xuXG4gICAgICAgICAgICAgICAgbE5vZGUgPSBsTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHBfbkxlZnRPZmZzZXQgKz0gbk9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJOb2RlID0gcmlnaHRDYXJldC5ub2RlO1xuICAgICAgICAgICAgaWYock5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgbk9mZnNldCA9IHRoaXMucndfZ2V0Tm9kZU9mZnNldChyTm9kZSk7XG4gICAgICAgICAgICAgICAgck5vZGUgPSByTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHBfblJpZ2h0T2Zmc2V0ICs9IG5PZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KGxOb2RlKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICByd19tb3ZlRW5kKHJhbmdlLCBwX25MZWZ0T2Zmc2V0KTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UyID0gdGhpcy5nZXRSYW5nZU9iamVjdChwX2JvZHkpO1xuICAgICAgICAgICAgcmFuZ2UyLm1vdmVUb0VsZW1lbnRUZXh0KHJOb2RlKTtcbiAgICAgICAgICAgIHJhbmdlMi5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgcndfbW92ZUVuZChyYW5nZTIsIHBfblJpZ2h0T2Zmc2V0KTtcbiAgICAgICAgICAgIHJhbmdlMi5jb2xsYXBzZShmYWxzZSk7XG5cbiAgICAgICAgICAgIHJhbmdlLnNldEVuZFBvaW50KFwiRW5kVG9FbmRcIiwgcmFuZ2UyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRXJyb3Igd2l0aCByd19nZXRBc1RleHRSYW5nZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuXG4gICAgLypSZW1vdmUgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHRoZSBwYWdlLiovXG4gICAgcndfY29sbGFwc2VTZWxlY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uT2JqZWN0KCk7XG4gICAgICAgIGlmKHNlbCA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VsLmNvbGxhcHNlVG9TdGFydClcbiAgICAgICAge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlVG9TdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc2VsLmV4ZWNDb21tYW5kKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWwuZXhlY0NvbW1hbmQoXCJVblNlbGVjdFwiLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlRoaXMgZ2V0cyB0aGUgc2VsZWN0aW9uIG9iamVjdCBpbiB0aGUgcGFnZSwgbnVsbCBpZiBubyBzZWxlY3Rpb24uKi9cbiAgICBnZXRTZWxlY3Rpb25PYmplY3QgKClcbiAgICB7XG4gICAgICAgIHZhciB0aGVSYW5nZSA9IG51bGw7XG4gICAgICAgIHZhciBnX2lwYWRTZWxlY3Rpb25SYW5nZT0gZmFsc2U7XG4gICAgICAgIGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pXG4gICAgICAgIHsgIC8qZmlyZSBmb3ggYW5kIHNhZmFyaSAgaWU5Ki9cbiAgICAgICAgICAgIGlmKGdfaXBhZFNlbGVjdGlvblJhbmdlIT1udWxsKVxuICAgICAgICAgICAgeyAgIC8vIHdvcmthcm91bmQgZm9yIGlwYWQgSU9TNSBidWcsIGxvc2VzIHNlbGVjdGlvbiBvbiBhbnkgYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vZ19pcGFkU2VsZWN0aW9uV2luZG93LmdldFNlbGVjdGlvbigpLmFkZFJhbmdlKGdfaXBhZFNlbGVjdGlvblJhbmdlKTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgd29ya2Fyb3VuZCBmb3IgaW9zNSBicm9rZW5lc3NcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgIC8vICoqKiAgSWYgdXNhZ2Ugb2YgU1NET00uZ2V0U2VsZWN0aW9uT2JqZWN0IGNoYW5nZXMgdGhpcyBtaWdodCBub3QgYmUgc3VpdGFibGUsIGhhY2sgYmFzZWQgb24gY3VycmVudCB0b29sYmFyIGFuZCBpb3M1IGJyb2tlbmVzcy5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgdG1wU2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIGZvdW5kU2VsID0gbnVsbDtcbiAgICAgICAgICAgIGlmKCF0bXBTZWwuaXNDb2xsYXBzZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm91bmRTZWwgPSB0bXBTZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wU2VsID0gdGhpcy5nZXRGcmFtZVNlbGVjdGlvblNGRih3aW5kb3cpO1xuICAgICAgICAgICAgICAgIGlmKHRtcFNlbC5mb3VuZFNlbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU2VsID0gdG1wU2VsLmZvdW5kU2VsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGZvdW5kU2VsID09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoZVJhbmdlID0gZm91bmRTZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihkb2N1bWVudC5zZWxlY3Rpb24pXG4gICAgICAgIHsvKmllKi9cbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzZWxlY3Rpb24gaW5zaWRlIGEgZnJhbWVcbiAgICAgICAgICAgIGlmKHJhbmdlLnRleHQubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGVXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgdGhlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gdGhpcy5nZXRGcmFtZVNlbGVjdGlvbk9sZElFKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgaWYodG1wLnRoZVJhbmdlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhlUmFuZ2UgPSB0bXAudGhlUmFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoZVJhbmdlO1xuICAgIH07XG5cbi8vIGdldCBzZWxlY3Rpb24gZnJvbSBzdWJmcmFtZXMgZnJvbSBzdGFydCBwb2ludCwgbm90IGdvaW5nIHRvIHRvcCBhbmQgdG9wIG1pZ2h0IG5vdCBiZSBhY2Nlc3NpYmxlIG9yIGFib3ZlXG4vLyB0b29sYmFyIHN0YXJ0IHBvaW50LlxuICAgIGdldEZyYW1lU2VsZWN0aW9uT2xkSUUgKHBfZnJhbWUpXG4gICAge1xuXG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgdmFyIHJhbmdlO1xuICAgICAgICB2YXIgZ19iSWdub3JlRnJhbWVzPSBmYWxzZTtcbiAgICAgICAgLy8gY2hlY2sgaWYgc2VsZWN0aW9uIGluc2lkZSBhIGZyYW1lXG4gICAgICAgIGlmKCFnX2JJZ25vcmVGcmFtZXMgJiYgcF9mcmFtZS5mcmFtZXMgJiYgcF9mcmFtZS5sZW5ndGg+MClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGk7IHZhciBuTGVuID0gcF9mcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGk8bkxlbjsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcEZyYW1lID0gcF9mcmFtZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0bXBGcmFtZS5kb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYocmFuZ2UgIT0gbnVsbCAmJiByYW5nZS50ZXh0ICE9IG51bGwgJiYgcmFuZ2UudGV4dC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMudGhlV2luZG93ID0gdG1wRnJhbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMudGhlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG1wRnJhbWUubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wUmVzID0gdGhpcy5nZXRGcmFtZVNlbGVjdGlvbk9sZElFKHRtcEZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0bXBSZXMudGhlUmFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB0bXBSZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJhbWVzIGV4aXN0IHdpdGggZGlmZmVyZW50IGRvbWFpbiBzbyBjYW5ub3QgYWNjZXNzLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbi8vIGdldCBzZWxlY3Rpb24gZnJvbSBzdWJmcmFtZXMgZnJvbSBzdGFydCBwb2ludCwgbm90IGdvaW5nIHRvIHRvcCBhbmQgdG9wIG1pZ2h0IG5vdCBiZSBhY2Nlc3NpYmxlIG9yIGFib3ZlXG4vLyB0b29sYmFyIHN0YXJ0IHBvaW50LlxuICAgIGdldEZyYW1lU2VsZWN0aW9uU0ZGIChwX2ZyYW1lKVxuICAgIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmdldEZyYW1lU2VsZWN0aW9uKHBfZnJhbWUpO1xuICAgICAgICBpZih0bXAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXMudGhlV2luZG93ID0gdG1wO1xuICAgICAgICAgICAgcmVzLmZvdW5kU2VsID0gdG1wLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8vIGdldCBzZWxlY3Rpb24gZnJvbSBzdWJmcmFtZXMgZnJvbSBzdGFydCBwb2ludCwgbm90IGdvaW5nIHRvIHRvcCBhbmQgdG9wIG1pZ2h0IG5vdCBiZSBhY2Nlc3NpYmxlIG9yIGFib3ZlXG4vLyB0b29sYmFyIHN0YXJ0IHBvaW50LlxuICAgIGdldEZyYW1lU2VsZWN0aW9uIChwX2ZyYW1lKVxuICAgIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgc2VsZWN0aW9uIGluc2lkZSBhIGZyYW1lXG4gICAgICAgIGlmKCFnX2JJZ25vcmVGcmFtZXMgJiYgcF9mcmFtZS5mcmFtZXMgJiYgcF9mcmFtZS5sZW5ndGg+MClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGk7IHZhciBuTGVuID0gcF9mcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGk8bkxlbjsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRtcCBvYmplY3QgYXMgZ2V0IHNlbGVjdGlvbiBjb3VsZCByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wT2JqID0gcF9mcmFtZVtpXS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodG1wT2JqICE9IG51bGwgJiYgIXRtcE9iai5pc0NvbGxhcHNlZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBfZnJhbWVbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwX2ZyYW1lW2ldLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcFJlcyA9IHRoaXMuZ2V0RnJhbWVTZWxlY3Rpb24ocF9mcmFtZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodG1wUmVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcFJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZyYW1lcyBleGlzdCB3aXRoIGRpZmZlcmVudCBkb21haW4gc28gY2Fubm90IGFjY2Vzcy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDI2LzA1LzIwMTYuXG4gKi9cblxubGV0IGluc3RhbmNlID0gbnVsbDtcblxuZXhwb3J0IGNsYXNzIEV2ZW50QnVze1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBpZighaW5zdGFuY2Upe1xuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzPSBuZXcgQXJyYXkoKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgdW5TdWJzY3JpYmUoZXZlbnQsY2FsbGJhY2spe1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50c1tpXS5ldmVudD09ZXZlbnQgJiYgdGhpcy5ldmVudHNbaV0uY2FsbGJhY2sgPT0gY2FsbGJhY2spe1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN1YnNjcmliZShldmVudCxjYWxsYmFjayl7XG4gICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1wiZXZlbnRcIjpldmVudCxcImNhbGxiYWNrXCI6Y2FsbGJhY2t9KVxuICAgIH1cblxuICAgIHB1Ymxpc2ggKGV2ZW50LGRhdGEpe1xuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8dGhpcy5ldmVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2ldLmV2ZW50PT1ldmVudCl7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNbaV0uY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbn0iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW5tbCBvbiAwMy8wNS8yMDE2LlxuICovXG5pbXBvcnQge1NTRE9NfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9TU0RPTSdcbmltcG9ydCB7VEhSZXR1cm5PYmplY3R9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhSZXR1cm5PYmplY3QnXG5pbXBvcnQge1V0aWxpdGllc30gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9VdGlsaXRpZXMvVXRpbGl0aWVzJ1xuaW1wb3J0IHtEb21OYXZpZ2F0aW9ufSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9Eb21OYXZpZ2F0aW9uJ1xuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL0F0dHJpYnV0ZSdcbmltcG9ydCAqIGFzIENvbnN0YW50cyBmcm9tICdzcmMvQ29uc3RhbnRzL0NvbnN0YW50cydcblxuXG5leHBvcnQgY2xhc3MgSGlnaGxpZ2h0QmFzZUNvbnRyb2xsZXJ7XG4gICAgY29uc3RydWN0b3IoKXtcblxuICAgIH1cblxuICAgIGhpZ2hsaWdodFJhbmdlKCl7XG5cbiAgICB9XG4gICAgXG4gICAgdW5IaWdobGlnaHRSYW5nZSgpe1xuXG4gICAgfVxuXG4gICAgLypcbiAgICAgdGFyZ2V0IG5vZGUsIGEgdGV4dCBub2RlIHRvIGdpdmUgaGlnaGxpZ2h0IHRvLlxuICAgICBwX25TdGFydFB0LCB0aGUgb2Zmc2V0IHRvIHN0YXJ0IGhpZ2hsaWdodCBhdFxuICAgICBwX25FbmRQdCwgdGhlIG9mZnNldCB0byBlbmQgaGlnaGxpZ2h0IGF0XG4gICAgIHBfc3RhdGUsIGVpdGhlciBzcy1zdHVkeSBza2lsbHMgc3Atc3BlZWNoIGhpZ2hnbGlnaHQgY3NwLWN1cnJlbnQgd29yZCBzcGVlY2ggaGlnaGxpZ2h0LlxuICAgICByZXR1cm5zIG9iamVjdCB3aXRoIHtOb2RlLCBvZmZzZXR9Ki9cbiAgICByd19zZXROb2RlQmFja2dyb3VuZChwX3RleHROb2RlLCBwX25TdGFydFB0LCBwX25FbmRQdCwgcF9zdGF0ZSwgcF9zdHJDb2wpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgdmFyIGRvbU5hdiA9IG5ldyBEb21OYXZpZ2F0aW9uKCk7XG4gICAgICAgIC8vYWxlcnQocF90ZXh0Tm9kZS5ub2RlVmFsdWUgKyBcIiB8XCIgKyBwX25TdGFydFB0ICsgXCIgfCBcIiArIHBfbkVuZFB0ICsgXCIgIHwgXCIgKyBwX3N0YXRlICtcIiB8IFwiICsgcF9zdHJDb2wpO1xuICAgICAgICB2YXIgcmVzID0gbmV3IFRIUmV0dXJuT2JqZWN0KCk7XG4gICAgICAgIHJlcy5ub2RlID0gcF90ZXh0Tm9kZTtcbiAgICAgICAgcmVzLm9mZnNldCA9IHBfblN0YXJ0UHQ7XG4gICAgICAgIGlmIChwX3RleHROb2RlLm5vZGVUeXBlICE9IDMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGlzIHNwZWNpYWwgZWxlbWVudCB0aGF0IGNhbiBiZSBoaWdobGlnaHRlZFxuICAgICAgICAgICAgaWYocF90ZXh0Tm9kZS5ub2RlVHlwZSA9PSAxICYmIHNzZG9tLmlzU3BlY2lhbENhc2VIaWdobGlnaHRhYmxlKHBfdGV4dE5vZGUpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKHBfdGV4dE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwibWF0aFwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhck5vZGUgPSBwX3RleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJ3X3NldE5vZGVCYWNrZ3JvdW5kSW1wbChwYXJOb2RlLCBwX3RleHROb2RlLCBwX25TdGFydFB0LCBwX25FbmRQdCwgcF9zdGF0ZSwgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYocF90ZXh0Tm9kZS5pc01hdGhKYXgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyTm9kZSA9IHBfdGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcndfc2V0Tm9kZUJhY2tncm91bmRJbXBsKHBhck5vZGUsIHBfdGV4dE5vZGUsIHBfblN0YXJ0UHQsIHBfbkVuZFB0LCBwX3N0YXRlLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hbGxvdy4gIE1heSBjb250YWluIG11bHRpcGxlIGhpZ2hsaWdodGFibGUgdGV4dCBpdGVtcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGV4dE5vZGUgPSBkb21OYXYuZ2V0Rmlyc3RDaGlsZFRleHROb2RlKHBfdGV4dE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFRleHROb2RlID0gZG9tTmF2LmdldExhc3RDaGlsZFRleHROb2RlKHBfdGV4dE5vZGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGlzIGdldHMgdmFsaWQgaXRlbXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBpZiBzcGVjaWFsIGNhc2UgSGlnaGxpZ2h0YWJsZSBub2RlIGNvbnRhaW5zIGEgc3BlY2lhbCBjYXNlIEhpZ2hsaWdodGFibGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyAgaXQgd2lsbCBjYXVzZSBlcnJvciBvbiB0aGUgcGFnZS5cbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnRUZXh0Tm9kZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRleHROb2RlLm5vZGVUeXBlID09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRleHROb2RlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRleHROb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucndfc2V0U3BlZWNoUmFuZ2VJbXBsKHN0YXJ0VGV4dE5vZGUsIDAsIGVuZFRleHROb2RlLCBlbmRUZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoLCBwX3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5ub2RlID0gc3RhcnRUZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGdvdCBpbnZhbGlkIHRleHQgZnJvbSBzcGVjaWFsIGNhc2Ugc28gZG8gbm90IGhpZ2hsaWdodC5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGZhaWwgbm90IGhpZ2hsaWdodGFibGVcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyBjaGVjayBpZiBzaG91bGQgaGlnaGxpZ2h0XG4gICAgICAgIC8vIGlmIGlzIHRleHQgbm9kZSB3aXRoIG9ubHkgd2hpdGUgc3BhY2UgYW5kIGlzIGluIGEgdGFibGUgYmV0d2VlbiA8dGQ+IGVsZW1lbnRzLCBkbyBub3Qgd2FudCB0byBhZGQgaGlnaGxpZ2hpbmcuXG4gICAgICAgIGlmKHBfdGV4dE5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHR4dCA9IHBfdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgdmFyIHV0aWxpdGllcyA9IG5ldyBVdGlsaXRpZXMoKTtcbiAgICAgICAgICAgIHR4dCA9IHV0aWxpdGllcy50cmltKHR4dCk7XG4gICAgICAgICAgICBpZih0eHQubGVuZ3RoID09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gQXQgc29tZSBwb2ludCB3b3VsZCB3YW50IHRvIGNoZWNrIGZvciB1bm5lY2Vzc2FyeSB3aGl0ZSBzcGFjZSBhdCBhbnkgcG9pbnQgKHRob3VnaCBydWxlcyBvZiB3aGF0IGlzIGFjdHVhbGx5IGRpc3BsYXllZCBub3QgY2xlYXIgYXMgbm90IGJhc2VkIG9uIGEgc3RhbmRhcmQgYnV0IGJyb3dzZXIgZGVwZW5kYW50KSxcbiAgICAgICAgICAgICAgICAvLyBidXQgdG8gYXZvaWQgY2hhbmdpbmcgYmVoYXZpb3VyIHRvbyBtdWNoIEknbSBsaW1pdGluZyB0aGlzIHRvIHRhYmxlc1xuICAgICAgICAgICAgICAgIHZhciB0bXBQYXIgPSBwX3RleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYodG1wUGFyICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wVHh0ID0gdXRpbGl0aWVzLnRyaW0odG1wUGFyLnRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcFR4dCA9PSBcInRyXCIgfHwgdG1wVHh0ID09IFwidGFibGVcIilcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGRvbid0IGhpZ2hsaWdodC4gIChBZGRlZCBmb3IgRkxWUyBidXQgaXNzdWUgZm9yIGFueSB0YWJsZSBpbiBGRiBTYWZhcmkgQ2hyb21lKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJOb2RlID0gcF90ZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgcGFyZW50U3RhdGUgPSBudWxsO1xuICAgICAgICBpZihwYXJOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBDb25zdGFudHMuSElHSExJR0hUX1RBRyApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhcmVudFN0YXRlID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShwYXJOb2RlLCBcInJ3c3RhdGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsb2dpYyBiYXNlZCBvbiBzdGF0ZSB0eXBlXG4gICAgICAgIGlmKHBfc3RhdGUgPT1cInNwZWxsXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHBhcmVudFN0YXRlID09IG51bGwgfHwgcGFyZW50U3RhdGUgPT0gXCJcIilcbiAgICAgICAgICAgIHsgLy8gYWRkIG5ldyBub2RlIHRvIHBhcmVudE5vZGUgY29udGFpbmluZyB0ZXh0bm9kZSBpbiBpdFxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucndfc2V0Tm9kZUJhY2tncm91bmRJbXBsKHBhck5vZGUsIHBfdGV4dE5vZGUsIHBfblN0YXJ0UHQsIHBfbkVuZFB0LCBwX3N0YXRlLCBwX3N0ckNvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7IC8vZXJyb3IsIGxpa2VseSBpbnNpZGUgc3BlZWNoLCBsZWF2ZSBhcyBpc1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihwX3N0YXRlID09XCJob21cIilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYocGFyZW50U3RhdGUgPT0gbnVsbCB8fCBwYXJlbnRTdGF0ZSA9PSBcIlwiKVxuICAgICAgICAgICAgeyAvLyBhZGQgbmV3IG5vZGUgdG8gcGFyZW50Tm9kZSBjb250YWluaW5nIHRleHRub2RlIGluIGl0XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5yd19zZXROb2RlQmFja2dyb3VuZEltcGwocGFyTm9kZSwgcF90ZXh0Tm9kZSwgcF9uU3RhcnRQdCwgcF9uRW5kUHQsIHBfc3RhdGUsIHBfc3RyQ29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHsgLy9lcnJvciwgbGlrZWx5IGluc2lkZSBzcGVlY2gsIGxlYXZlIGFzIGlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHBfc3RhdGUgPT1cImdyYW1tYXJcIilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYocGFyZW50U3RhdGUgPT0gbnVsbCB8fCBwYXJlbnRTdGF0ZSA9PSBcIlwiKVxuICAgICAgICAgICAgeyAvLyBhZGQgbmV3IG5vZGUgdG8gcGFyZW50Tm9kZSBjb250YWluaW5nIHRleHRub2RlIGluIGl0XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5yd19zZXROb2RlQmFja2dyb3VuZEltcGwocGFyTm9kZSwgcF90ZXh0Tm9kZSwgcF9uU3RhcnRQdCwgcF9uRW5kUHQsIHBfc3RhdGUsIHBfc3RyQ29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHsgLy9lcnJvciwgbGlrZWx5IGluc2lkZSBzcGVlY2gsIGxlYXZlIGFzIGlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHBfc3RhdGUgPT0gXCJzc1wiKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihwYXJlbnRTdGF0ZSA9PSBudWxsIHx8IHBhcmVudFN0YXRlID09IFwiXCIpXG4gICAgICAgICAgICB7IC8vIGFkZCBuZXcgbm9kZSB0byBwYXJlbnROb2RlIGNvbnRhaW5pbmcgdGV4dG5vZGUgaW4gaXRcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnJ3X3NldE5vZGVCYWNrZ3JvdW5kSW1wbChwYXJOb2RlLCBwX3RleHROb2RlLCBwX25TdGFydFB0LCBwX25FbmRQdCwgcF9zdGF0ZSwgcF9zdHJDb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50U3RhdGUgPT0gXCJzc1wiKVxuICAgICAgICAgICAgeyAvLyBjdXJyZW50bHkgZG9udCByZXBsYWNlIG9yIHNwbGl0IHBhcmVudCBub2RlLCBqdXN0IGxlYXZlIGFzIGlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHsgLy9lcnJvciwgbGlrZWx5IGluc2lkZSBzcGVlY2gsIGxlYXZlIGFzIGlzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwX3N0YXRlID09IFwic3BcIilcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlID09IFwiY3NwXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgaW52YWxpZCBoaWdobGlnaHRpbmdcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImZhaWwgaW4gcndfc2V0Tm9kZUJhY2tncm91bmQgc2V0dGluZyBzcCB0byBjc3BcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlID09IFwic3BcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBpbnZhbGlkIGhpZ2hsaWdodGluZ1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZmFpbCBpbiByd19zZXROb2RlQmFja2dyb3VuZCBzZXR0aW5nIHNwIHRvIHNwXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdoYXRldmVyIHBhcmVudCBpcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAvLyBhZGQgbmV3IG5vZGUgdG8gcGFyZW50IG5vZGUgY29udGFpbmluZyB0ZXh0bm9kZSBpbiBpdFxuICAgICAgICAgICAgcmVzID0gdGhpcy5yd19zZXROb2RlQmFja2dyb3VuZEltcGwocGFyTm9kZSwgcF90ZXh0Tm9kZSwgcF9uU3RhcnRQdCwgcF9uRW5kUHQsIHBfc3RhdGUsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBfc3RhdGUgPT0gXCJjc3BcIilcbiAgICAgICAge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImlzIGNzcCBwYXJlbnRzdGF0ZVwiICsgcGFyZW50U3RhdGUgKyBcIiAgcGFyZW50dHlwZT1cIiArIHBhck5vZGUudGFnTmFtZSk7XG4gICAgICAgICAgICBpZiAocGFyZW50U3RhdGUgPT0gXCJjc3BcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBpbnZhbGlkIGhpZ2hsaWdodGluZ1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZmFpbCBwYXJlbnQgaXMgY3NwIGZvciBjc3BcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudFN0YXRlID09IFwic3BcIilcbiAgICAgICAgICAgIHsvLyBhZGQgbmV3IG5vZGUgdG8gcGFyZW50IG5vZGUgY29udGFpbmluZyB0ZXh0bm9kZSBpbiBpdFxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucndfc2V0Tm9kZUJhY2tncm91bmRJbXBsKHBhck5vZGUsIHBfdGV4dE5vZGUsIHBfblN0YXJ0UHQsIHBfbkVuZFB0LCBwX3N0YXRlLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHsgLy9mYWlsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7IC8vIGZhaWxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qYXNzaXN0YW5jZSB0byByd19zZXROb2RlQmFja2dyb3VuZFxuICAgICB0aGlzIHdpbGwgbW9kaWZ5IGEgcGFyZW50IHRvIGFkZCBhcHByb3ByaWF0ZSBoaWdobGlnaHRpbmcuICAgPHA+XG4gICAgIHJldHVybnMge05vZGUsIG9mZnNldH0qL1xuICAgIHJ3X3NldE5vZGVCYWNrZ3JvdW5kSW1wbChwX3BhcmVudE5vZGUsIHBfdGV4dE5vZGUsIHBfblN0YXJ0UHQsIHBfbkVuZFB0LCBwX3N0YXRlLCBwX3N0ckNvbClcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSgpO1xuICAgICAgICB2YXIgYlNwZWVjaCA9IHBfc3RhdGU9PT1cInNwXCIgfHwgcF9zdGF0ZT09PVwiY3NwXCI7XG5cblxuICAgICAgICAvKmlmIHBfblN0YXJ0IGFuZCBwX25FbmQgPSAtMSB0aGVuIGFjdCBvbiBmdWxsIG5vZGUsIG90aGVyd2lzZSBuZWVkIHRvIHNwbGl0IHRvIHRleHQgbm9kZSB0ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGFnTmFtZSA9XCJcIjtcblxuICAgICAgICBpZihwX3RleHROb2RlLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRhZ05hbWUgPSBwX3RleHROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKChwX3RleHROb2RlLm5vZGVUeXBlID09IDMgJiYgKHBfbkVuZFB0ID09IC0xIHx8IHBfbkVuZFB0ID4gcF9uU3RhcnRQdCkpIHx8IHRhZ05hbWUgPT1cIm1hdGhcIiB8fCBwX3RleHROb2RlLmlzTWF0aEpheCkgeyAgIC8vIG9ubHkgYWN0IGlmIGVuZCBhZnRlciBzdGFydFxuXG4gICAgICAgICAgICB2YXIgc3RyQ29sO1xuICAgICAgICAgICAgaWYgKHBfc3RhdGUgPT0gXCJzc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBfc3RyQ29sID09IFwic3RyaWtldGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ckNvbCA9IFwidGV4dC1kZWNvcmF0aW9uOmxpbmUtdGhyb3VnaFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyQ29sID0gXCJiYWNrZ3JvdW5kOlwiICsgcF9zdHJDb2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocF9zdGF0ZSA9PSBcInNwXCIpIHtcbiAgICAgICAgICAgICAgICBzdHJDb2wgPSBDb25zdGFudHMuU1BFRUNIX1JBTkdFX0NPTE9VUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBfc3RhdGUgPT0gXCJjc3BcIikge1xuICAgICAgICAgICAgICAgIHN0ckNvbCA9IENvbnN0YW50cy5TUEVFQ0hfV09SRF9DT0xPVVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwX3N0YXRlID09IFwic3BlbGxcIikge1xuICAgICAgICAgICAgICAgIC8vIGNoYW5nZWQgdG8gd2F2ZXkgbGluZVxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYXBwbGllcyB0byB0aW55IG1jZSBhbmQgbmVlZHMgbGluZSAudGhzcGVsbCB7YmFja2dyb3VuZDp1cmwoXCJpbWcvd2xpbmUuZ2lmXCIpIHJlcGVhdC14IGJvdHRvbSBsZWZ0OyBjdXJzb3I6ZGVmYXVsdDt9XG4gICAgICAgICAgICAgICAgLy8gYWRkZWQgdG8gdGhlIGNvbnRlbnQuY3NzIGF0IFxccmVzb3VyY2VzXFxmaWxlc1xcdGlueV9tY2VcXHRoZW1lc1xcYWR2YW5jZXNcXHNraW5zXFxkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3bGluZS5naWYgdG8gdGhlIGltZyBzdWJmb2xkZXJcblxuICAgICAgICAgICAgICAgIC8vIENIQU5HRUQgRk9SIFRJTllNQ0UgVjRcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGFwcGxpZXMgdG8gdGlueSBtY2UgYW5kIG5lZWRzIGxpbmUgLnRoc3BlbGwge2JhY2tncm91bmQ6dXJsKFwiaW1nL3dsaW5lLmdpZlwiKSByZXBlYXQteCBib3R0b20gbGVmdDsgY3Vyc29yOmRlZmF1bHQ7fVxuICAgICAgICAgICAgICAgIC8vIGFkZGVkIHRvIHRoZSBjb250ZW50LmNzcyBhdCBcXHRpbnlfbWNlXFxza2luc1xcbGlnaHRncmF5XG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3bGluZS5naWYgdG8gdGhlIGltZyBzdWJmb2xkZXJcblxuICAgICAgICAgICAgICAgIHN0ckNvbCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwX3N0YXRlID09IFwiaG9tXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VkIHRvIHdhdmV5IGxpbmVcbiAgICAgICAgICAgICAgICBzdHJDb2wgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocF9zdGF0ZSA9PSBcImdyYW1tYXJcIikge1xuICAgICAgICAgICAgICAgIC8vIGNoYW5nZWQgdG8gd2F2ZXkgbGluZVxuICAgICAgICAgICAgICAgIHN0ckNvbCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJDb2wgPSBcImNvbG9yOiNmZjAwMDsgYmFja2dyb3VuZDojMDBmZjAwXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09IFwibWF0aFwiIHx8IHBfdGV4dE5vZGUuaXNNYXRoSmF4KSB7ICAgLy8gTm90IHRleHQgbm9kZSwgaGFuZGxlZCBzZXBhcmF0ZWx5LlxuICAgICAgICAgICAgICAgIC8vIGRvbnQgc3VwcG9ydCBcInNzXCIgeWV0XG4gICAgICAgICAgICAgICAgaWYgKGJTcGVlY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yd19oaWdobGlnaHRNYXRoRWxlbWVudChwX3RleHROb2RlLCBwX3N0YXRlLCBzdHJDb2wsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuTGVuID0gcF90ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLy9JRTkgYnVnIHdvcmthcm91bmQgIGluIElFOSBub2RlIHdpdGgganVzdCBcXG4gd2lsbCBiZSByZW1vdmVkIGlmIGdpdmVuIGJhY2tncm91bmQgY29sb3VyLlxuICAgICAgICAgICAgICAgIGlmICgobkxlbiA9PSAxICYmIChwX3RleHROb2RlLm5vZGVWYWx1ZSA9PSBcIlxcblwiIHx8IHBfdGV4dE5vZGUubm9kZVZhbHVlID09IFwiXFxyXCIpICkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG5MZW4gPT0gMiAmJiBwX3RleHROb2RlLm5vZGVWYWx1ZSA9PSBcIlxcclxcblwiICkpIHsgICAvLyByZXR1cm4gd2l0aG91dCBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gbmV3IFRIUmV0dXJuT2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5ub2RlID0gcF90ZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBfblN0YXJ0UHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5vZmZzZXQgPSBwX25TdGFydFB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IHBfcGFyZW50Tm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgICAgIC8vIFVzZSBhbGwgdG8gZGV0ZXJtaW5lIGlmIGFsbCBvZiB0aGUgbm9kZSBuZWVkcyB0byBiZSBoaWdobGlnaHRlZCBvciBpZiBpdCBpcyB0byBiZSBzcGxpdC5cbiAgICAgICAgICAgICAgICB2YXIgYkFsbCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBfblN0YXJ0UHQgPT0gLTEgJiYgcF9uRW5kUHQgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYkFsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBfbkVuZFB0ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBfbkVuZFB0ID0gbkxlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocF9uU3RhcnRQdCA9PSAwICYmIHBfbkVuZFB0ID49IG5MZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYkFsbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB2YXIgdG1wRWwgPSBkb2MuY3JlYXRlRWxlbWVudChDb25zdGFudHMuSElHSExJR0hUX1RBRyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocF9zdGF0ZSA9PSBcInNwZWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcndfc2V0QXR0cmlidXRlKHRtcEVsLCBcInNwZWxsbnVtXCIsIHBfc3RyQ29sKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhbHNlIC8qU1NITC5kYXQuYnJvd3Nlci5iSUUqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wRWwuc2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIsIFwidGhzcGVsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIGJ1Zy4gIElFIGNhbm5vdCBjaGFuZ2UgY2xhc3NlcyBkeW5hbWljYWxseS4gIEl0IHN0b3JlcyB0aGUgY2xhc3NuYW1lIHNldCwgYnV0IGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3R1YWxseSB1cGRhdGUgdGhlIHBhZ2UgdG8gdGhlIHN0eWxlcyBvZiB0aGUgbmV3IGNsYXNzLiAgU28gcG9pbnRsZXNzIGFuZCBicm9rZW4gY2xhc3MgbG9naWNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYW5zIGV4dHJhIGNvZGUgbmVlZGVkIGFnYWluIHRvIHdvcmthcm91bmQgSUUgZmxhd3MuICAoTWVhbnMgbmVlZCB0byBoYXJkIGNvZGUgdXJsISlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ckNvbCA9IFwiYmFja2dyb3VuZDp1cmwoXFxcIlwiICsgcndfZ2V0U3dhRmlsZUxvY2F0aW9uKCkgKyBcIndsaW5lLmdpZlxcXCIpICByZXBlYXQteCBib3R0b20gbGVmdFwiO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBFbC5jbGFzc05hbWUgPSBcInRoc3BlbGxcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwX3N0YXRlID09IFwiaG9tXCIpIHtcbi8vICAgICAgICAgICAgICAgICAgIHRvZG8gdmFyIHN0ckNsYXNzID0gU3BlZWNoU3RyZWFtLmhpZ2hsaWdodGVyLmdldEhvbUNsYXNzKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgcndfc2V0QXR0cmlidXRlKHRtcEVsLCBcImhvbW51bVwiLCBwX3N0ckNvbCk7XG4vLyAgICAgICAgICAgICAgICAgICAgaWYgKFNTSEwuZGF0LmJyb3dzZXIuYklFKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHRtcEVsLnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiLCBzdHJDbGFzcyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIGJ1Zy4gIElFIGNhbm5vdCBjaGFuZ2UgY2xhc3NlcyBkeW5hbWljYWxseS4gIEl0IHN0b3JlcyB0aGUgY2xhc3NuYW1lIHNldCwgYnV0IGRvZXMgbm90XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IHVwZGF0ZSB0aGUgcGFnZSB0byB0aGUgc3R5bGVzIG9mIHRoZSBuZXcgY2xhc3MuICBTbyBwb2ludGxlc3MgYW5kIGJyb2tlbiBjbGFzcyBsb2dpY1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZWFucyBleHRyYSBjb2RlIG5lZWRlZCBhZ2FpbiB0byB3b3JrYXJvdW5kIElFIGZsYXdzLiAgKE1lYW5zIG5lZWQgdG8gaGFyZCBjb2RlIHVybCEpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHN0ckNvbCA9IFwiYmFja2dyb3VuZDp1cmwoXFxcIlwiICsgcndfZ2V0U3dhRmlsZUxvY2F0aW9uKCkgKyBcIndsaW5lYmx1ZS5naWZcXFwiKSAgcmVwZWF0LXggYm90dG9tIGxlZnRcIjtcbi8vICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHRtcEVsLmNsYXNzTmFtZSA9IHN0ckNsYXNzO1xuLy8gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocF9zdGF0ZSA9PSBcImdyYW1tYXJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQ2xhc3MgPSBcInRoZ3JhbW1hclwiO1xuICAgICAgICAgICAgICAgICAgICByd19zZXRBdHRyaWJ1dGUodG1wRWwsIFwiZ3JhbW1hcm51bVwiLCBwX3N0ckNvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSAvKlNTSEwuZGF0LmJyb3dzZXIuYklFKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcEVsLnNldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiLCBcInRoZ3JhbW1hclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIGJ1Zy4gIElFIGNhbm5vdCBjaGFuZ2UgY2xhc3NlcyBkeW5hbWljYWxseS4gIEl0IHN0b3JlcyB0aGUgY2xhc3NuYW1lIHNldCwgYnV0IGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3R1YWxseSB1cGRhdGUgdGhlIHBhZ2UgdG8gdGhlIHN0eWxlcyBvZiB0aGUgbmV3IGNsYXNzLiAgU28gcG9pbnRsZXNzIGFuZCBicm9rZW4gY2xhc3MgbG9naWNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lYW5zIGV4dHJhIGNvZGUgbmVlZGVkIGFnYWluIHRvIHdvcmthcm91bmQgSUUgZmxhd3MuICAoTWVhbnMgbmVlZCB0byBoYXJkIGNvZGUgdXJsISlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ckNvbCA9IFwiYmFja2dyb3VuZDp1cmwoXFxcIlwiICsgcndfZ2V0U3dhRmlsZUxvY2F0aW9uKCkgKyBcIndsaW5lZ3JlZW4uZ2lmXFxcIikgIHJlcGVhdC14IGJvdHRvbSBsZWZ0XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBFbC5jbGFzc05hbWUgPSBzdHJDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgaWYgKGJBbGwpIHtcbi8vICAgICAgICAgICAgICAgICAgICBpZihTU0hMLmRhdC5icm93c2VyLmJJRU9sZClcbi8vICAgICAgICAgICAgICAgICAgICB7ICAgLy93b3JrYXJvdW5kIGZvciBJRSBidWcgb2Ygc2V0QXR0cmlidXRlIG5vdCB3b3JraW5nIGZvciBzdHlsZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICB0bXBFbC5zdHlsZS5zZXRBdHRyaWJ1dGUoXCJjc3NUZXh0XCIsIHN0ckNvbCwgMCk7ICAgICAgICAgIC8vIEFTIGZvciBvbGQgYnJvd3NlcnMgb25seSBwcmUgaHRtbDUgbm90IG1ha2luZyBodG1sNSBkYXRhLSBjaGFuZ2UgdG8gdGhpcy5cbi8vICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBFbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBzdHJDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19zZXRBdHRyaWJ1dGUodG1wRWwsIFwicndzdGF0ZVwiLCBwX3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJTcGVlY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19zZXRBdHRyaWJ1dGUodG1wRWwsIFwic3RhcnRlZFwiLCBcIjFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2FzZSBub3JtYWwgYnJvd3NlYWxvdWQgKG1hYykgdXNlZCBvbiBwYWdlIGF0IHNhbWUgdGltZVxuICAgICAgICAgICAgICAgICAgICBwX3BhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRtcEVsLCBwX3RleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wRWwuYXBwZW5kQ2hpbGQocF90ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHh0ID0gcF90ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eHRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHh0TWlkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHh0UmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwX3BhcmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3BhblwiICYmIGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocF9wYXJlbnROb2RlLCBcInByb25cIikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHh0TGVmdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eHRNaWQgPSB0eHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eHRSaWdodCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eHRMZWZ0ID0gdHh0LnN1YnN0cmluZygwLCBwX25TdGFydFB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4dE1pZCA9IHR4dC5zdWJzdHJpbmcocF9uU3RhcnRQdCwgcF9uRW5kUHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHh0UmlnaHQgPSB0eHQuc3Vic3RyaW5nKHBfbkVuZFB0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgIGlmKFNTSEwuZGF0LmJyb3dzZXIuYklFT2xkKVxuLy8gICAgICAgICAgICAgICAgICAgIHsgICAvL3dvcmthcm91bmQgZm9yIElFIGJ1ZyBvZiBzZXRBdHRyaWJ1dGUgbm90IHdvcmtpbmcgZm9yIHN0eWxlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHRtcEVsLnN0eWxlLnNldEF0dHJpYnV0ZShcImNzc1RleHRcIiwgc3RyQ29sLCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBFbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBzdHJDb2wpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19zZXRBdHRyaWJ1dGUodG1wRWwsIFwicndzdGF0ZVwiLCBwX3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJTcGVlY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19zZXRBdHRyaWJ1dGUodG1wRWwsIFwic3RhcnRlZFwiLCBcIjFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdHh0Tm9kZUxlZnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHh0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR4dE5vZGVSaWdodCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4dExlZnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHh0Tm9kZUxlZnQgPSBkb2MuY3JlYXRlVGV4dE5vZGUodHh0TGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0eHRNaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHh0UmlnaHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHh0Tm9kZVJpZ2h0ID0gZG9jLmNyZWF0ZVRleHROb2RlKHR4dFJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0bXBFbC5hcHBlbmRDaGlsZCh0eHROb2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBwX3BhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRtcEVsLCBwX3RleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4dE5vZGVMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBfcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHh0Tm9kZUxlZnQsIHRtcEVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHh0Tm9kZVJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBFbC5uZXh0U2libGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcF9wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0eHROb2RlUmlnaHQsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBudWxsIGluIGluc2VydEJlZm9yZSB0byBpbnNlcnQgYXQgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwX3BhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHR4dE5vZGVSaWdodCwgdG1wRWwubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwX3RleHROb2RlID0gdHh0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgdmFyIHJlcyA9IG5ldyBUSFJldHVybk9iamVjdCgpO1xuICAgICAgICByZXMubm9kZSA9IHBfdGV4dE5vZGU7XG4gICAgICAgIGlmIChwX25TdGFydFB0IDwgMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVzLm9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXMub2Zmc2V0ID0gcF9uU3RhcnRQdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIElmIHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBzcGVlY2ggaGlnaGxpZ2h0aW5nIHRvIG1hdGggZWxlbWVudCBjYWxsIHRoaXMuXG4gICAgICogRG9lc250IGhhbmRsZSBzcyB5ZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcF9tYXRoTm9kZSBNdXN0IGJlIG1hdGggZWxlbWVudFxuICAgICAqIEBwYXJhbSBwX3J3c3RhdGVcbiAgICAgKiBAcGFyYW0gcF9zdHJTdHlsZVxuICAgICAqIEBwYXJhbSBwX2JTdGFydGVkIHRydWUgaWYgYWRkaW5nIHNwZWVjaCAsIGZhbHNlIHRvIHJlbW92ZVxuICAgICAqL1xuICAgICAgICByd19oaWdobGlnaHRNYXRoRWxlbWVudChwX21hdGhOb2RlLCBwX3J3c3RhdGUsIHBfc3RyU3R5bGUsIHBfYlN0YXJ0ZWQpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgaWYocF9tYXRoTm9kZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyVGFnID0gQ29uc3RhbnRzLkhJR0hMSUdIVF9UQUdcblxuICAgICAgICAvLyBBcyBwZXIgZWNraW4gdXN1YWwgbmVlZCB0byBkbyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgZm9yIElFLCBjYXVzZSBpdCBkb2Vzbid0IHN1cHBvcnQgc2V0dGluZ1xuICAgICAgICAvLyBzdHlsZSBkYXRhIGludG8gdGhlIG1hdGggbWwgb2JqZWN0LlxuICAgICAgICAvLyAoQWxzbyBub3RlIGZvciBmIGZpcmVmb3gsIGlmIHRoZSBtYXRobWwgdXNlcyBkaXNwbGF5OmJsb2NrIGl0IGRvZXNuJ3QgaW5oZXJpdCBiYWNrZ3JvdW5kIHN0eWxlLCBzbyBmaXJlZm94IGJ1Z2dlZCBhcyB3ZWxsKVxuICAgICAgICB2YXIgYklFID0gZmFsc2U7XG4gICAgICAgIGlmKGJJRSlcbiAgICAgICAgeyAgIC8vIGlmIHBhcmVudCBpcyBmb250L3NwYW4gd2l0aCBzdHlsZVxuICAgICAgICAgICAgdmFyIHBhck5vZGUgPSBwX21hdGhOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZihwYXJOb2RlID09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihwYXJOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBzdHJUYWcgJiYgcndfZ2V0QXR0cmlidXRlKHBhck5vZGUsIFwic3RhcnRlZFwiKSAhPSBudWxsKVxuICAgICAgICAgICAgeyAgIC8vIHVzZSBvciByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICBpZihwX2JTdGFydGVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyTm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUoXCJjc3NUZXh0XCIsIHBfc3RyU3R5bGUsIDApO1xuICAgICAgICAgICAgICAgICAgICByd19zZXRBdHRyaWJ1dGUocGFyTm9kZSwgXCJyd3N0YXRlXCIsIHBfcndzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7ICAgLy8gcmVtb3ZlIGl0XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmFuZHBhck5vZGUgPSBwYXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmKGdyYW5kcGFyTm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JhbmRwYXJOb2RlLnJlcGxhY2VDaGlsZChwX21hdGhOb2RlLCBwYXJOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHsgICAvLyBuZWVkIHRvIGFkZCBmb250L3NwYW5cbiAgICAgICAgICAgICAgICBpZihwX2JTdGFydGVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsRm9udCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoc3RyVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxGb250LnN0eWxlLnNldEF0dHJpYnV0ZShcImNzc1RleHRcIiwgcF9zdHJTdHlsZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJ3X3NldEF0dHJpYnV0ZShlbEZvbnQsIFwic3RhcnRlZFwiLCBcIjFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJ3X3NldEF0dHJpYnV0ZShlbEZvbnQsIFwicndzdGF0ZVwiLCBwX3J3c3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJOb2RlLnJlcGxhY2VDaGlsZChlbEZvbnQsIHBfbWF0aE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBlbEZvbnQuYXBwZW5kQ2hpbGQocF9tYXRoTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2Ugbm8gbmVlZCB0byByZW1vdmUgaWYgbm90IHRoZXJlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdG1wRWwgPSBwX21hdGhOb2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIHdoaWxlKHRtcEVsICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYodG1wRWwubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICB7IC8vIGNvdWxkIGJlIG1yb3cgb3IgbXN1cCBvciBtc3R5bGUgKGFzIG1pZ2h0IGJlIG1vcmUganVzdCBhc3N1bWUgYW55IGVsZW1lbnQgaXMgdmFsaWQuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYocF9iU3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgeyAvLyBhZGRpbmcgc3BlZWNoIGhpZ2hsaWdoaW5nXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGhhcyBzdGFydGVkIHRoZW4gY2FuIGNoYW5nZSBzdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaGFzIG5vIHN0eWxlIHRoZW4gYWRkIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgbGVhdmUgc28gYXMgdG8gbm90IGRlc3Ryb3kgcGFnZSBzZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUodG1wRWwsIFwic3RhcnRlZFwiKSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHBfc3RyU3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19zZXRBdHRyaWJ1dGUodG1wRWwsIFwicndzdGF0ZVwiLCBwX3J3c3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUodG1wRWwsIFwic3R5bGVcIikgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHBfc3RyU3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucndfc2V0QXR0cmlidXRlKHRtcEVsLCBcInJ3c3RhdGVcIiwgcF9yd3N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnJ3X3NldEF0dHJpYnV0ZSh0bXBFbCwgXCJzdGFydGVkXCIsIFwiMVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Vsc2UgbGVhdmUgd2VsbCBhbG9uZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vcmVtb3ZlIHNwZWVjaCBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUodG1wRWwsIFwic3RhcnRlZFwiKSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcEVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19yZW1vdmVBdHRyaWJ1dGUodG1wRWwsIFwic3RhcnRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucndfcmVtb3ZlQXR0cmlidXRlKHRtcEVsLCBcInJ3c3RhdGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0bXBFbCA9IHRtcEVsLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypSZXR1cm5zIGFsbCB0aGUgdGV4dCBub2RlcyBpbiB0aGUgcmFuZ2UgaW5jbHVzaXZlLlxuICAgICBPbmx5IGluY2x1ZGVzIHRleHQgbm9kZXMsIG5vdCBpbWcgZWxlbWVudHMgd2l0aCBzcGVha2FibGUgdGV4dC5cblxuICAgICBUaGlzIGlzIGN1cnJlbnRseSBvbmx5IHVzZWQgZm9yIHJlbW92aW5nIGhpZ2hsaWdodGluZyEuXG5cbiAgICAgSGFzIGNvZGUgdG8gaGFuZGxlIGNhc2Ugb2YgaGlkZGVuIGVsZW1lbnRzIGFzIGV2ZW4gaWYgaGlkZGVuIGFmdGVyIGhpZ2hsaWdodGVkIHN0aWxsIHdhbnQgdG8gcmVtb3ZlIGhpZ2hsaWdodGluZy5cblxuICAgICBJZiBldmVyIHVzZSB0aGlzIGZvciBhZGRpbmcgaGlnaGxpZ2h0aW5nIG5lZWQgdG8gcGFzcyB2YXJpYWJsZSB0byBzcGVjaWZ5IGRpZmZlcmVuY2UuXG5cbiAgICAgcF9zdGFydENhcmV0IHRoZSBzdGFydCBwb2ludFxuICAgICBwX2VuZENhcmV0IHRoZSBlbmQgcG9pbnRcbiAgICAgKi9cbiAgICBnZXRMaXN0T2ZIaWdobGlnaHRhYmxlTm9kZXMocF9zdGFydENhcmV0LCBwX2VuZENhcmV0KVxuICAgIHtcbiAgICAgICAgLy9zcGVjaWFsIGNhc2UsIHRoZXJlIGlzIGNoYW5jZSB0aGF0IGFyZWEgaGlnaGxpZ2h0ZWQgaGFzIGJlZW4gaGlkZGVuIGJ5IGNvZGUgaW4gcGFnZSBzbyB3b3VsZFxuICAgICAgICAvLyBmYWlsIHRoZSBpbnZhbGlkIG5vZGUgdGVzdCBhbmQgbm90IHVuaGlnaGxpZ2h0LiAgQWRkIGNvZGUgaGVyZSB0byBjb3VudGVyIHRoaXNcbiAgICAgICAgdmFyIHRtcElnbm9yZUZsYWcgPSBmYWxzZTsvL2dfYklnbm9yZUhpZGRlbjtcbiAgICAgICAgLy9nX2JJZ25vcmVIaWRkZW4gPSBmYWxzZTtcblxuICAgICAgICAvLyBjb250aW51ZXMgYmVmb3JlIGZvciBsb29wIGFuZCBhZnRlciBjYXRjaC5cbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIHZhciBkb21OYXYgPSBuZXcgRG9tTmF2aWdhdGlvbigpO1xuICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBwX3N0YXJ0Q2FyZXQubm9kZTtcbiAgICAgICAgICAgIHZhciBlbmROb2RlID0gcF9lbmRDYXJldC5ub2RlO1xuXG4gICAgICAgICAgICBpZihzdGFydE5vZGUubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihzdGFydE5vZGUubm9kZVR5cGUgPT0gMSAmJiBzdGFydE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwibWF0aFwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goc3RhcnROb2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihzdGFydE5vZGUgPT0gZW5kTm9kZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IGRvbU5hdi5nZXROZXh0VGV4dE5vZGUoc3RhcnROb2RlLCBmYWxzZSwgZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihnX2JJRSAmJiBzdGFydE5vZGUubm9kZVR5cGUgPT0gMSAmJiBzdGFydE5vZGUuZmlyc3RDaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlLmZpcnN0Q2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09XCJtYXRoXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChzdGFydE5vZGUuZmlyc3RDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnROb2RlID09IGVuZE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IGRvbU5hdi5nZXROZXh0VGV4dE5vZGUoc3RhcnROb2RlLCBmYWxzZSwgZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdGFydE5vZGUubm9kZVR5cGUgPT0gMSAmJiBzdGFydE5vZGUuaXNNYXRoSmF4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goc3RhcnROb2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihzdGFydE5vZGUgPT0gZW5kTm9kZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IGRvbU5hdi5nZXROZXh0VGV4dE5vZGUoc3RhcnROb2RlLCBmYWxzZSwgZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihnX2JJRSAmJiBzdGFydE5vZGUubm9kZVR5cGUgPT0gMSAmJiBzdGFydE5vZGUuZmlyc3RDaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZS5maXJzdENoaWxkLmlzTWF0aEpheClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHN0YXJ0Tm9kZS5maXJzdENoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICBpZihzdGFydE5vZGUgPT0gZW5kTm9kZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlID0gZG9tTmF2LmdldE5leHRUZXh0Tm9kZShzdGFydE5vZGUsIGZhbHNlLCBlbmROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBkb21OYXYuZ2V0Rmlyc3RDaGlsZFRleHROb2RlKHN0YXJ0Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZihzdGFydE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc3RhcnROb2RlID09IGVuZE5vZGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoc3RhcnROb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHh0ID0gc3RhcnROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYodHh0Lmxlbmd0aCA+IDAgJiYgcF9zdGFydENhcmV0Lm9mZnNldCA8IHR4dC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBfZW5kQ2FyZXQub2Zmc2V0ID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcF9lbmRDYXJldC5vZmZzZXQgPiBwX3N0YXJ0Q2FyZXQub2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChzdGFydE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZpcnN0IG5vZGVcbiAgICAgICAgICAgICAgICBpZihzdGFydE5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eHQgPSBzdGFydE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZih0eHQubGVuZ3RoID4gMCAmJiBwX3N0YXJ0Q2FyZXQub2Zmc2V0IDwgdHh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goc3RhcnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihzdGFydE5vZGUubm9kZVR5cGUgPT0gMSAmJiBzdGFydE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwibWF0aFwiKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChzdGFydE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnX2JJRSAmJiBzdGFydE5vZGUubm9kZVR5cGUgPT0gMSAmJiBzdGFydE5vZGUuZmlyc3RDaGlsZCAhPSBudWxsICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09IDEgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlLmZpcnN0Q2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09XCJtYXRoXCIpXG4vLyAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUuZmlyc3RDaGlsZDtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goc3RhcnROb2RlKTtcbi8vICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3RhcnROb2RlLm5vZGVUeXBlID09IDEgJiYgc3RhcnROb2RlLmlzTWF0aEpheClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goc3RhcnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZ19iSUUgJiYgc3RhcnROb2RlLm5vZGVUeXBlID09IDEgJiYgc3RhcnROb2RlLmZpcnN0Q2hpbGQgIT0gbnVsbCAmJlxuLy8gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUuZmlyc3RDaGlsZC5pc01hdGhKYXgpXG4vLyAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBzdGFydE5vZGUuZmlyc3RDaGlsZDtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goc3RhcnROb2RlKTtcbi8vICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSBkb21OYXYuZ2V0TmV4dFRleHROb2RlTm9JbWcoc3RhcnROb2RlLCBmYWxzZSwgZW5kTm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAodG1wTm9kZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcE5vZGUgPT0gZW5kTm9kZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaW5jbHVkZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZW5kTm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eHQgPSBlbmROb2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0eHQubGVuZ3RoID4gMCAmJiBwX2VuZENhcmV0Lm9mZnNldCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChlbmROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodG1wTm9kZS5ub2RlVHlwZSA9PSAxICYmIHRtcE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwibWF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godG1wTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnX2JJRSAmJiB0bXBOb2RlLm5vZGVUeXBlID09IDEgJiYgdG1wTm9kZS5maXJzdENoaWxkICE9IG51bGwgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBOb2RlLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcE5vZGUuZmlyc3RDaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJtYXRoXCIpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godG1wTm9kZS5maXJzdENoaWxkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHRtcE5vZGUubm9kZVR5cGUgPT0gMSAmJiB0bXBOb2RlLmlzTWF0aEpheClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHRtcE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZ19iSUUgJiYgdG1wTm9kZS5ub2RlVHlwZSA9PSAxICYmIHRtcE5vZGUuZmlyc3RDaGlsZCAhPSBudWxsICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wTm9kZS5maXJzdENoaWxkLmlzTWF0aEpheClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0bXBOb2RlLmZpcnN0Q2hpbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0bXBOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRtcE5vZGUgPSBkb21OYXYuZ2V0TmV4dFRleHROb2RlTm9JbWcodG1wTm9kZSwgZmFsc2UsIGVuZE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKXsvKmNvbnNvbGUubG9nKFwiZ2V0TGlzdE9mSGlnaGxpZ2h0YWJsZU5vZGVzIGVycm9yOlwiICsgZXJyLm1lc3NhZ2UpOyovfVxuXG4gICAgICAgIC8vIHBhcnQgb2Ygc3BlY2lhbCBjYXNlIGFib3ZlXG4vLyAgICAgICAgZ19iSWdub3JlSGlkZGVuID0gdG1wSWdub3JlRmxhZztcblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDI1LzA0LzIwMTYuXG4gKi9cbmltcG9ydCB7TWF0aEpheEhpZ2hsaWdodGVyfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL01hdGhKYXgvTWF0aEpheEhpZ2hsaWdodGVyJ1xuXG5leHBvcnQgY2xhc3MgTWF0aEpheEhpZ2hsaWdodENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlbnRlbmNlKSB7XG4gICAgICAgIHRoaXMubV9zZXR1cEhhc2ggPSB7fTtcblxuICAgICAgICB0aGlzLm1fZGVmYXVsdENvbnRleHRCZyA9IHtcInJcIjoyNTUsXCJnXCI6MjU1LFwiYlwiOjB9O1xuICAgICAgICB0aGlzLm1fZGVmYXVsdENvbnRleHRGZyA9IHtcInJcIjowLFwiZ1wiOjAsXCJiXCI6MH07XG4gICAgICAgIHRoaXMubV9kZWZhdWx0V29yZEJnID0ge1wiclwiOjAsXCJnXCI6MCxcImJcIjoyNTV9O1xuICAgICAgICB0aGlzLm1fZGVmYXVsdFdvcmRGZyA9IHtcInJcIjoyNTUsIFwiZ1wiOjI1NSxcImJcIjoyNTV9O1xuICAgICAgICB0aGlzLm1fY29udGV4dEJnID0ge1wiclwiOjI1NSxcImdcIjoyNTUsXCJiXCI6MH07XG4gICAgICAgIHRoaXMubV9jb250ZXh0RmcgPSB7XCJyXCI6MCxcImdcIjowLFwiYlwiOjB9O1xuICAgICAgICB0aGlzLm1fd29yZEJnID0ge1wiclwiOjAsXCJnXCI6MCxcImJcIjoyNTV9O1xuICAgICAgICB0aGlzLm1fd29yZEZnID0ge1wiclwiOjI1NSxcImdcIjoyNTUsXCJiXCI6MjU1fTtcbiAgICAgICAgdGhpcy5tX3N0ckNvbnRleHRTdHlsZSA9IFwiaGlnaGxpZ2h0XCI7ICAgICAgICAvL2hpZ2hsaWdodCAoZmcgYmcpIG91dGxpbmUgdW5kZXJsaW5lXG4gICAgICAgIHRoaXMubV9zdHJXb3JkU3R5bGUgPSBcImhpZ2hsaWdodFwiO1xuICAgICAgICB0aGlzLnNlbnRlbmNlID0gc2VudGVuY2U7XG4gICAgICAgIHRoaXMubGFzdE1hdGhJZD1udWxsO1xuICAgIH1cblxuICAgIGhpZ2hsaWdodChwX2lkKVxuICAgIHtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocF9pZCk7XG4gICAgICAgICAgICB2YXIgamF4ID0gdGhpcy5nZXRKYXhGb3IoZWxlbSk7XG4gICAgICAgICAgICB0aGlzLmggPSBuZXcgTWF0aEpheEhpZ2hsaWdodGVyKGpheCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMubV9zdHJDb250ZXh0U3R5bGUgPT09IFwiaGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oLnNldEhpZ2hsaWdodFN0eWxlKFwiY29udGV4dFwiLCBcImJnXCIsIHRoaXMubV9jb250ZXh0QmcuciwgdGhpcy5tX2NvbnRleHRCZy5nLCB0aGlzLm1fY29udGV4dEJnLmIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaC5zZXRIaWdobGlnaHRTdHlsZShcImNvbnRleHRcIiwgXCJmZ1wiLCB0aGlzLm1fY29udGV4dEZnLnIsIHRoaXMubV9jb250ZXh0RmcuZywgdGhpcy5tX2NvbnRleHRGZy5iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5tX3N0ckNvbnRleHRTdHlsZSA9PT0gXCJvdXRsaW5lXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oLnNldEhpZ2hsaWdodFN0eWxlKFwiY29udGV4dFwiLCBcIm91dGxpbmVcIiwgdGhpcy5tX2NvbnRleHRGZy5yLCB0aGlzLm1fY29udGV4dEZnLmcsIHRoaXMubV9jb250ZXh0RmcuYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMubV9zdHJDb250ZXh0U3R5bGUgPT09IFwidW5kZXJsaW5lXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oLnNldEhpZ2hsaWdodFN0eWxlKFwiY29udGV4dFwiLCBcInVuZGVybGluZVwiLCB0aGlzLm1fY29udGV4dEZnLnIsIHRoaXMubV9jb250ZXh0RmcuZywgdGhpcy5tX2NvbnRleHRGZy5iKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodGhpcy5tX3N0cldvcmRTdHlsZSA9PT0gXCJoaWdobGlnaHRcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmguc2V0SGlnaGxpZ2h0U3R5bGUoXCJ3b3JkXCIsIFwiYmdcIiwgdGhpcy5tX3dvcmRCZy5yLCB0aGlzLm1fd29yZEJnLmcsIHRoaXMubV93b3JkQmcuYik7XG4gICAgICAgICAgICAgICAgdGhpcy5oLnNldEhpZ2hsaWdodFN0eWxlKFwid29yZFwiLCBcImZnXCIsIHRoaXMubV93b3JkRmcucix0aGlzLm1fd29yZEZnLmcsIHRoaXMubV93b3JkRmcuYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMubV9zdHJXb3JkU3R5bGUgPT09IFwib3V0bGluZVwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaC5zZXRIaWdobGlnaHRTdHlsZShcIndvcmRcIiwgXCJvdXRsaW5lXCIsIHRoaXMubV93b3JkRmcuciwgdGhpcy5tX3dvcmRGZy5nLCB0aGlzLm1fd29yZEZnLmIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLm1fc3RyV29yZFN0eWxlID09PSBcInVuZGVybGluZVwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaC5zZXRIaWdobGlnaHRTdHlsZShcIndvcmRcIiwgXCJ1bmRlcmxpbmVcIiwgdGhpcy5tX3dvcmRGZy5yLCB0aGlzLm1fd29yZEZnLmcsIHRoaXMubV93b3JkRmcuYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICB7XG4gICAgICAgICAgIC8vIGNvbnNvbGUubG9nRShlcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGhpZ2hsaWdodFJhbmdlKCl7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuc2VudGVuY2UuZ2V0U3BhbklkKCk7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih0aGlzLmxhc3RNYXRoSWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sYXN0TWF0aElkID0gaWQ7XG4gICAgICAgICAgICBpZighdGhpcy5tX3NldHVwSGFzaFtpZF0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9zZXR1cEhhc2hbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICB2YXIgamF4ID0gdGhpcy5nZXRKYXhGb3IoZWxlbSk7XG4gICAgICAgICAgICB2YXIgamF4U3BhbmlkID1qYXgucm9vdC5zcGFuSUQ/amF4LnJvb3Quc3BhbklEOmpheC5yb290LkNIVE1Mbm9kZUlEO1xuICAgICAgICAgICAgamF4U3BhbmlkID1qYXhTcGFuaWQhPW51bGwmJmpheFNwYW5pZCE9dW5kZWZpbmVkP2pheFNwYW5pZDpqYXgucm9vdC5QSFRNTHNwYW5JRDtcbiAgICAgICAgICAgIHRoaXMuaC5oaWdobGlnaHROb2RlcyhcImNvbnRleHRcIiwgamF4U3BhbmlkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnIpXG4gICAgICAgIHtcbiAgICAgICAgICAgLy8gY29uc29sZS5sb2dFKGVycik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1bkhpZ2hsaWdodFJhbmdlKCl7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcF9pZCA9IHRoaXMuc2VudGVuY2UuZ2V0U3BhbklkKCk7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBfaWQpO1xuICAgICAgICAgICAgdmFyIGpheCA9IHRoaXMuZ2V0SmF4Rm9yKGVsZW0pO1xuICAgICAgICAgICAgdGhpcy5oLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycilcbiAgICAgICAge1xuICAgICAgICAgICAvLyBjb25zb2xlLmxvZ0UoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZ2hsaWdodFdvcmQod29yZE5vKXtcbiAgICAgICAgdmFyIHBfaWQgPXRoaXMuc2VudGVuY2UuZ2V0U3BhbklkKHdvcmRObyApO1xuICAgICAgICB2YXIgcF9zcGFuSWQgPXRoaXMuc2VudGVuY2UuZ2V0V29yZFJhbmdlKHdvcmRObyApO1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoIXRoaXMubV9zZXR1cEhhc2hbcF9pZF0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQocF9pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3NldHVwSGFzaFtwX2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocF9pZCk7XG4gICAgICAgICAgICB2YXIgamF4ID0gdGhpcy5nZXRKYXhGb3IoZWxlbSk7XG4gICAgICAgICAgICB0aGlzLmguaGlnaGxpZ2h0Tm9kZXMoXCJ3b3JkXCIsIHBfc3BhbklkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnIpXG4gICAgICAgIHtcbiAgICAgICAgICAgLy8gY29uc29sZS5sb2dFKGVycik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwX3N0clN0eWxlIGhpZ2hsaWdodCwgb3V0bGluZSBvciB1bmRlcmxpbmVcbiAgICAgKiBAcGFyYW0gcF9zdHJUeXBlIGNvbnRleHQgb3Igd29yZCAgKG9wdGlvbmFsLCBhc3N1bWVzIHdvcmQgaWYgbm90IGdpdmVuLlxuICAgICAqIEBwYXJhbSBwX3JnYkZnIHIgZyBiIHZhbHVlICB7XCJyXCI6MCxcImdcIjoxMDAsXCJiXCI6MjU1fSAob3B0aW9uYWwsIGFzc3VtZSB0b29sYmFyIGRlZmF1bHRzIGlmIG5vdCBnaXZlblxuICAgICAqIEBwYXJhbSBwX3JnYkJnIHIgZyBiIHZhbHVlICB7XCJyXCI6MCxcImdcIjoxMDAsXCJiXCI6MjU1fSAob3B0aW9uYWwsIGFzc3VtZSB0b29sYmFyIGRlZmF1bHRzIGlmIG5vdCBnaXZlblxuICAgICAqL1xuICAgIHNldEhpZ2hsaWdodFN0eWxlIChwX3N0clN0eWxlLCBwX3N0clR5cGUsIHBfcmdiRmcsIHBfcmdiQmcpXG4gICAge1xuICAgICAgICAvLyBpZiBjaGFuZ2UgdGhlIHN0eWxlLCB0aGVuIHRoZSBzdG9yZWQgaGlzdG9yeSBvZiBzZXQgdXAgaXRlbXMgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICB0aGlzLm1fc2V0dXBIYXNoID0gW107XG5cbiAgICAgICAgaWYodHlwZW9mKHBfc3RyU3R5bGUpID09PSBcInN0cmluZ1wiKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih0eXBlb2YocF9zdHJUeXBlKSA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBfc3RyVHlwZSA9IFwid29yZFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYkRlZmF1bHQgPSAodHlwZW9mKHBfcmdiKSA9PSBcInVuZGVmaW5lZFwiKTtcblxuICAgICAgICAgICAgaWYocF9zdHJUeXBlID09PSBcImNvbnRleHRcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc3RyQ29udGV4dFN0eWxlID0gcF9zdHJTdHlsZTtcblxuICAgICAgICAgICAgICAgIGlmKHBfc3RyU3R5bGUgPT09IFwiaGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fY29udGV4dEJnID0gKGJEZWZhdWx0P3RoaXMubV9kZWZhdWx0Q29udGV4dEJnOnBfcmdiQmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fY29udGV4dEZnID0gKGJEZWZhdWx0P3RoaXMubV9kZWZhdWx0Q29udGV4dEZnOnBfcmdiRmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHBfc3RyU3R5bGUgPT09IFwib3V0bGluZVwiIHx8IHBfc3RyU3R5bGUgPT09IFwidW5kZXJsaW5lXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fY29udGV4dEZnID0gKGJEZWZhdWx0P3RoaXMubV9kZWZhdWx0Q29udGV4dEJnOnBfcmdiRmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYocF9zdHJUeXBlID09PSBcIndvcmRcIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc3RyV29yZFN0eWxlID0gcF9zdHJTdHlsZTtcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMubV9zdHJXb3JkU3R5bGUgPT09IFwiaGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fd29yZEJnID0gKGJEZWZhdWx0P3RoaXMubV9kZWZhdWx0V29yZEJnOnBfcmdiQmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fd29yZEZnID0gKGJEZWZhdWx0P3RoaXMubV9kZWZhdWx0V29yZEZnOnBfcmdiRmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKHBfc3RyU3R5bGUgPT09IFwib3V0bGluZVwiIHx8IHBfc3RyU3R5bGUgPT09IFwidW5kZXJsaW5lXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1fd29yZEZnID0gKGJEZWZhdWx0P3RoaXMubV9kZWZhdWx0V29yZEJnOnBfcmdiRmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwX2VsZW0gYSBET00gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgICAgICBnZXRKYXhGb3IgKHBfZWxlbSlcbiAgICB7XG4gICAgICAgIHZhciBqYXggPSBudWxsO1xuICAgICAgICB2YXIgZ19iSUU9IGZhbHNlO1xuICAgICAgICB2YXIgZ19iSUUxMT1mYWxzZTtcbiAgICAgICAgaWYoIWdfYklFIHx8IGdfYklFMTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGpheCA9IE1hdGhKYXguSHViLmdldEpheEZvcihwX2VsZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgeyAgIC8vIElFIGRvZXNuJ3Qgd29yayBhcyBtYXRoamF4IGFzc3VtZXMgYSBzdHJ1Y3R1cmUgdGhhdCBkb2VzIG5vdCBuZWNlc3NhcmlseSBleGlzdCB3aXRoIDw9SUUxMFxuICAgICAgICAgICAgaWYgKHBfZWxlbSAmJiBwX2VsZW0uaXNNYXRoSmF4KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBfZWxlbSAmJiAhcF9lbGVtLmpheElEKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcF9lbGVtID0gcF9lbGVtLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBfZWxlbSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBTdHIgPSBwX2VsZW0uaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcFN0ci5pbmRleE9mKFwiLUZyYW1lXCIpPi0xKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBTdHIgPSB0bXBTdHIuc3Vic3RyKDAsIHRtcFN0ci5pbmRleE9mKFwiLUZyYW1lXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodG1wU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpheCA9IE1hdGhKYXguSHViLmdldEpheEZvcih0bXBFbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gamF4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBmb3IgaXNzdWVzIGluIHRoZSBtYXRobWwuICBJZiBjb250YWlucyBtdGV4dCB3aXRoIGVtcHR5IGNvbnRlbnQsIHJlbW92ZSB0aGlzLlxuICAgICAqIEBwYXJhbSBwX3N0ck1hdGhNbFxuICAgICAqL1xuICAgICAgICBjaGVja1RleHQgKHBfc3RyTWF0aE1sKVxuICAgIHtcbiAgICAgICAgLy8gbG9vayBmb3IgbWF0aG1sIG10ZXh0IHdpdGggbm8gY29udGVudC5cbiAgICAgICAgdmFyIG5Qb3MgPSBwX3N0ck1hdGhNbC5pbmRleE9mKFwiPG10ZXh0PlwiKTtcbiAgICAgICAgdmFyIG5Qb3MyO1xuICAgICAgICB2YXIgc3RyVG1wO1xuXG4gICAgICAgIHdoaWxlKG5Qb3MgPiAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgblBvczIgPSBwX3N0ck1hdGhNbC5pbmRleE9mKFwiPC9tdGV4dD5cIiwgblBvcyk7XG4gICAgICAgICAgICBpZihuUG9zMj5uUG9zKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0clRtcCA9IHBfc3RyTWF0aE1sLnN1YnN0cmluZyhuUG9zICsgNywgblBvczIpO1xuICAgICAgICAgICAgICAgIHN0clRtcCA9IHN0clRtcC50cmltVEgoKTtcbiAgICAgICAgICAgICAgICBpZihzdHJUbXAubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgeyAgIC8vIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICBwX3N0ck1hdGhNbCA9IHBfc3RyTWF0aE1sLnN1YnN0cigwLCBuUG9zKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBwX3N0ck1hdGhNbC5zdWJzdHIoblBvczIrOCk7XG4gICAgICAgICAgICAgICAgICAgIG5Qb3MgPSBwX3N0ck1hdGhNbC5pbmRleE9mKFwiPG10ZXh0PlwiLCBuUG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgblBvcyA9IHBfc3RyTWF0aE1sLmluZGV4T2YoXCI8bXRleHQ+XCIsIG5Qb3MyKzgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvb2sgZm9yIG1hdGhtbCBtbiB3aXRoIG5vIGNvbnRlbnQuXG4gICAgICAgIG5Qb3MgPSBwX3N0ck1hdGhNbC5pbmRleE9mKFwiPG1uPlwiKTtcblxuICAgICAgICB3aGlsZShuUG9zID4gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5Qb3MyID0gcF9zdHJNYXRoTWwuaW5kZXhPZihcIjwvbW4+XCIsIG5Qb3MpO1xuICAgICAgICAgICAgaWYoblBvczI+blBvcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJUbXAgPSBwX3N0ck1hdGhNbC5zdWJzdHJpbmcoblBvcyArIDQsIG5Qb3MyKTtcbiAgICAgICAgICAgICAgICBzdHJUbXAgPSBzdHJUbXAudHJpbVRIKCk7XG4gICAgICAgICAgICAgICAgaWYoc3RyVG1wLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHsgICAvLyByZW1vdmUgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgcF9zdHJNYXRoTWwgPSBwX3N0ck1hdGhNbC5zdWJzdHIoMCwgblBvcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcF9zdHJNYXRoTWwuc3Vic3RyKG5Qb3MyKzUpO1xuICAgICAgICAgICAgICAgICAgICBuUG9zID0gcF9zdHJNYXRoTWwuaW5kZXhPZihcIjxtbj5cIiwgblBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5Qb3MgPSBwX3N0ck1hdGhNbC5pbmRleE9mKFwiPG1uPlwiLCBuUG9zMis1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIGxvb2sgZm9yIG1hdGhtbCBtb3ZlciB3aXRoIG5vIGNvbnRlbnQuXG4gICAgICAgIHZhciBuUG9zID0gcF9zdHJNYXRoTWwuaW5kZXhPZihcIjxtb3Zlcj5cIik7XG4gICAgICAgIHZhciBuUG9zMjtcbiAgICAgICAgdmFyIHN0clRtcDtcblxuICAgICAgICB3aGlsZShuUG9zID4gLTEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5Qb3MyID0gcF9zdHJNYXRoTWwuaW5kZXhPZihcIjwvbW92ZXI+XCIsIG5Qb3MpO1xuICAgICAgICAgICAgaWYoblBvczI+blBvcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJUbXAgPSBwX3N0ck1hdGhNbC5zdWJzdHJpbmcoblBvcyArIDcsIG5Qb3MyKTtcbiAgICAgICAgICAgICAgICBzdHJUbXAgPSBzdHJUbXAudHJpbVRIKCk7XG4gICAgICAgICAgICAgICAgaWYoc3RyVG1wLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHsgICAvLyByZW1vdmUgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgcF9zdHJNYXRoTWwgPSBwX3N0ck1hdGhNbC5zdWJzdHIoMCwgblBvcykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcF9zdHJNYXRoTWwuc3Vic3RyKG5Qb3MyKzgpO1xuICAgICAgICAgICAgICAgICAgICBuUG9zID0gcF9zdHJNYXRoTWwuaW5kZXhPZihcIjxtb3Zlcj5cIiwgblBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5Qb3MgPSBwX3N0ck1hdGhNbC5pbmRleE9mKFwiPG1vdmVyPlwiLCBuUG9zMis4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBwX3N0ck1hdGhNbDtcbiAgICB9O1xuXG5cbn1cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbiBvbiAzMC8wMy8xNi5cbiAqL1xuXG5pbXBvcnQge1RIQ2FyZXRSYW5nZX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USENhcmV0UmFuZ2UnXG5pbXBvcnQge1RIUmV0dXJuT2JqZWN0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIUmV0dXJuT2JqZWN0J1xuaW1wb3J0IHtTU0RPTX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9ET00vU1NET00nXG5pbXBvcnQge1V0aWxpdGllc30gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9VdGlsaXRpZXMvVXRpbGl0aWVzJ1xuaW1wb3J0IHtTZW50ZW5jZU9iamVjdH0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9TZW50ZW5jZS9TZW50ZW5jZU9iamVjdCdcbmltcG9ydCB7U3BlZWNoT2JqZWN0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1NwZWVjaE9iamVjdCdcbmltcG9ydCB7U2Nyb2xsSW5Ub1ZpZXd9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vU2Nyb2xsSW5Ub1ZpZXcnXG5pbXBvcnQge0hpZ2hsaWdodEJhc2VDb250cm9sbGVyfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0hpZ2hsaWdodGluZy9IaWdobGlnaHRCYXNlQ29udHJvbGxlcidcbmltcG9ydCB7RG9tTmF2aWdhdGlvbn0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9ET00vRG9tTmF2aWdhdGlvbidcbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9BdHRyaWJ1dGUnXG5pbXBvcnQgKiBhcyBDb25zdGFudHMgZnJvbSAnc3JjL0NvbnN0YW50cy9Db25zdGFudHMnXG5cbmV4cG9ydCBjbGFzcyBTcGVlY2hIaWdobGlnaHRDb250cm9sbGVyIGV4dGVuZHMgSGlnaGxpZ2h0QmFzZUNvbnRyb2xsZXJcbntcbiAgICBjb25zdHJ1Y3RvcihzZW50ZW5jZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VudGVuY2U9c2VudGVuY2U7XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0UmFuZ2UoKVxuICAgIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZW50ZW5jZS5nZXRSYW5nZSgpO1xuXG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gb25seSBoaWdobGlnaHQgaWYgaGFzIGEgcmFuZ2VcbiAgICAgICAgICAgIGlmKHJhbmdlICE9IG51bGwpXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FyZXRSYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UgKHJhbmdlLmJvZHksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0UmVmLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0UmVmLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kUmVmLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZFJlZi5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0Q2FyZXQgPSBjYXJldFJhbmdlLmxlZnRDYXJldDtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRDYXJldCA9IGNhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICAgICAgICAgIGlmKGxlZnRDYXJldCAhPSBudWxsICYmIHJpZ2h0Q2FyZXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucndfc2V0U3BlZWNoUmFuZ2VJbXBsKGxlZnRDYXJldC5ub2RlLCBsZWZ0Q2FyZXQub2Zmc2V0LCByaWdodENhcmV0Lm5vZGUsIHJpZ2h0Q2FyZXQub2Zmc2V0LCBcInNwXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW5ub3QgZGV0ZXJtaW5lIHJhbmdlIHRvIGhpZ2hsaWdodCBzbyBkbyBub3RoaW5nIGhlcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVycm9yIGluIFRISG92ZXJUYXJnZXRDbGFzczpoaWdobGlnaHRSYW5nZTogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdW5IaWdobGlnaHRSYW5nZSAoKVxuICAgIHtcbiAgICAgICAgdmFyIHJhbmdlID10aGlzLnNlbnRlbmNlLmdldFJhbmdlKCk7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYocmFuZ2UgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FyZXRSYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UocmFuZ2UuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRSZWYucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRSZWYub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmRSZWYucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kUmVmLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRDYXJldCA9IGNhcmV0UmFuZ2UubGVmdENhcmV0O1xuICAgICAgICAgICAgICAgIHZhciByaWdodENhcmV0ID0gY2FyZXRSYW5nZS5yaWdodENhcmV0O1xuXG4gICAgICAgICAgICAgICAgaWYobGVmdENhcmV0ICE9IG51bGwgJiYgcmlnaHRDYXJldCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yd19yZW1vdmVTcGVlY2hIaWdobGlnaHQodGhpcy5nZXRMaXN0T2ZIaWdobGlnaHRhYmxlTm9kZXMobGVmdENhcmV0LCByaWdodENhcmV0KSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjYW5ub3QgZGV0ZXJtaW5lIGxlZnQgYW5kIHJpZ2h0IGNhcmV0IGhlcmUgd291bGQgbm90IGhhdmUgYmVlbiBhYmxlIHRvIGRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGF0IGhpZ2hsaWdodCBzdGFnZSBlaXRoZXIgc28gbGlrZWx5IG5vdGhpbmcgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRXJyb3IgaW4gVEhIb3ZlclRhcmdldDp1bmhpZ2hsaWdodFJhbmdlOiBcIitlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaGlnaGxpZ2h0V29yZCAod29yZE5vKVxuICAgIHtcbiAgICAgICAgaWYgKHdvcmRObyA8dGhpcy5zZW50ZW5jZS5nZXRXb3JkcygpLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgICAgICBpZiAod29yZE5vID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0aFJhbmdlID0gdGhpcy5zZW50ZW5jZS5nZXRXb3JkUmFuZ2Uod29yZE5vIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoUmFuZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FyZXRSYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UodGhSYW5nZS5ib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhSYW5nZS5zdGFydFJlZi5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhSYW5nZS5zdGFydFJlZi5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aFJhbmdlLmVuZFJlZi5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhSYW5nZS5lbmRSZWYub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRDYXJldCA9IGNhcmV0UmFuZ2UubGVmdENhcmV0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHRDYXJldCA9IGNhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdENhcmV0ICE9IG51bGwgJiYgcmlnaHRDYXJldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ3X3JlbW92ZVNwZWVjaEhpZ2hsaWdodCh0aGlzLmdldExpc3RPZkhpZ2hsaWdodGFibGVOb2RlcyhsZWZ0Q2FyZXQsIHJpZ2h0Q2FyZXQpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgID0gdGhpcy5zZW50ZW5jZS5nZXRXb3JkUmFuZ2Uod29yZE5vKTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FyZXRSYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UocmFuZ2UuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRSZWYucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRSZWYub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmRSZWYucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kUmVmLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRDYXJldCA9IGNhcmV0UmFuZ2UubGVmdENhcmV0O1xuICAgICAgICAgICAgICAgIHZhciByaWdodENhcmV0ID0gY2FyZXRSYW5nZS5yaWdodENhcmV0O1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxJblRvVmlldyA9IG5ldyBTY3JvbGxJblRvVmlldygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRDYXJldCAhPSBudWxsICYmIHJpZ2h0Q2FyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yd19zZXRTcGVlY2hSYW5nZUltcGwobGVmdENhcmV0Lm5vZGUsIGxlZnRDYXJldC5vZmZzZXQsIHJpZ2h0Q2FyZXQubm9kZSwgcmlnaHRDYXJldC5vZmZzZXQsIFwiY3NwXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdCAhPSBudWxsICYmIHJlc3VsdC5ub2RlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEluVG9WaWV3LnJ3X3Njcm9sbFRvT2JqZWN0KHJlc3VsdC5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEluVG9WaWV3LnJ3X3Njcm9sbFRvT2JqZWN0KGxlZnRDYXJldC5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlJlbW92ZSBoaWdobGlnaHRpbmcgLlxuICAgICBwX2JXb3JkIGlzIHRydWUgd2hlbiBvbmx5IGxvb2tpbmcgdG8gcmVtb3ZlIGN1cnJlbnQgd29yZCBoaWdobGlnaHRpbmdcbiAgICAgKi9cbiAgICByd19yZW1vdmVTcGVlY2hIaWdobGlnaHQocF9hcnIsIHBfYldvcmQpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZihwX2JXb3JkKSA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBfYldvcmQ9ZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocF9hcnIgPT0gbnVsbCB8fCAhKHBfYXJyIGluc3RhbmNlb2YgQXJyYXkpIHx8IHBfYXJyLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwX2Fyci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gcF9hcnJbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucndfY2hlY2tOb2RlSXNTcGVlY2hUZXh0KHRtcCwgcF9iV29yZCkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyTm9kZSA9IHRtcC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZih0bXAubmV4dFNpYmxpbmcgIT0gbnVsbCB8fCB0bXAucHJldmlvdXNTaWJsaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvLyBuZWVkIHRvIG1lcmdlIG9yIHRleHQgY291bGQgYmUgbG9zdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4dCA9IHNzZG9tLmFsbFRleHRGcm9tTm9kZVRIKHBhck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHBhck5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0eHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2hlclBhcmVudE5vZGUgPSBwYXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hlclBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRtcCwgcGFyTm9kZSk7XG5cbi8vICAgICAgICAgICAgICAgIGlmKCFTU0hMLmRhdC5icm93c2VyLmJJRTYpXG4vLyAgICAgICAgICAgICAgICB7ICAgLy8gYXBwYXJhbnRseSBJRTYgY2FuIHJhbmRvbWx5IGNyYXNoIHdpdGggY2FsbCBiZWxvdy5cbi8vICAgICAgICAgICAgICAgICAgICBoaWdoZXJQYXJlbnROb2RlLm5vcm1hbGl6ZSgpO1xuLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0bXAgPSBzc2RvbS5tZXJnZVRleHROb2Rlcyh0bXApOyAgICAgICAvL3RvZFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHB1dCBiYWNrIGluIGluY2FzZSBuZWVkIHRvIGxvb3AgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgcF9hcnJbaV0gPSB0bXA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0byBjaGVjayBmb3IgbmVzdGVkIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY291bGQgYmUgcmVtb3ZpbmcgcmFuZ2UgYW5kIHdvcmQgc3RpbGwgZXhpc3RzLCBuZWVkIHRvIGxvb3AgdHdpY2UgdG8gZ2V0IGJvdGggb3V0LlxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnJ3X2NoZWNrTm9kZUlzU3BlZWNoVGV4dCh0bXAsIHBfYldvcmQpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ05hbWUgPVwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodG1wLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSB0bXAudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodGFnTmFtZT09XCJtYXRoXCIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucndfaGlnaGxpZ2h0TWF0aEVsZW1lbnQodG1wLCBudWxsLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZih0bXAuaXNNYXRoSmF4KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ3X2hpZ2hsaWdodE1hdGhFbGVtZW50KHRtcCwgbnVsbCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJ3X3JlbW92ZVNwZWVjaEhpZ2hsaWdodCBmYWlsZWQgZXJyb3I6XCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKlVzZWQgYnkgcndfcmVtb3ZlSGlnaGxpZ2h0IHRvIGNoZWNrIGlmIHZhbGlkIG5vZGUgdG8gcHJvY2Vzcy5cbiAgICAgcF9ub2RlIGlzIG5vZGUgdG8gY2hlY2tcbiAgICAgcF9iV29yZCBpcyB0cnVlIHdoZW4gb25seSBsb29raW5nIHRvIHJlbW92ZSBjdXJyZW50IHdvcmQgaGlnaGxpZ2h0aW5nKi9cbiAgICByd19jaGVja05vZGVJc1NwZWVjaFRleHQocF9ub2RlLCBwX2JXb3JkKVxuICAgIHtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGU9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgaWYgKHBfbm9kZS5ub2RlVHlwZSAhPSAzIHx8IHBfbm9kZS5wYXJlbnROb2RlID09IG51bGwgfHwgcF9ub2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50ID0gcF9ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZShwYXJlbnQsIFwicndzdGF0ZVwiKTtcblxuICAgICAgICBpZiAocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBDb25zdGFudHMuSElHSExJR0hUX1RBRyAmJiBhdHRyICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKCghcF9iV29yZCAmJiBhdHRyID09IFwic3BcIikgfHwgYXR0ciA9PSBcImNzcFwiKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qU2V0IHRoZSBiYWNrZ3JvdW5kIGhpZ2hsaWdodGluZyBmb3IgdGhlIHJhbmdlIHRvIGJlIHNwb2tlblxuXG4gICAgIFJldHVybiByZXN1bHQgaXRlbSBzcGVjaWZ5aW5nIHdoYXQgd2FzIGp1c3QgaGlnaGxpZ2h0ZWRcbiAgICAgKi9cbiAgICByd19zZXRTcGVlY2hSYW5nZUltcGwocF9zdGFydE5vZGUsIHBfc3RhcnRPZmZzZXQsIHBfZW5kTm9kZSwgcF9lbmRPZmZzZXQsIHBfc3RyU3RhdGUpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGRvbU5hdiA9IG5ldyBEb21OYXZpZ2F0aW9uKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSWYgYWxsIGluIG9uZSBub2RlXG4gICAgICAgICAgICBpZiAocF9lbmROb2RlID09IHBfc3RhcnROb2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucndfc2V0Tm9kZUJhY2tncm91bmQocF9zdGFydE5vZGUsIHBfc3RhcnRPZmZzZXQsIHBfZW5kT2Zmc2V0LCBwX3N0clN0YXRlLCBcIlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkbyBmaXJzdCBub2RlXG4gICAgICAgICAgICBpZiAocF9zdGFydE9mZnNldCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yd19zZXROb2RlQmFja2dyb3VuZChwX3N0YXJ0Tm9kZSwgcF9zdGFydE9mZnNldCwgcF9zdGFydE5vZGUubm9kZVZhbHVlLmxlbmd0aCwgcF9zdHJTdGF0ZSwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yd19zZXROb2RlQmFja2dyb3VuZChwX3N0YXJ0Tm9kZSwgLTEsIC0xLCBwX3N0clN0YXRlLCBcIlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9vcCBmb2xsb3dpbmcgbm9kZXNcbiAgICAgICAgICAgIHZhciB0bXBOb2RlID0gZG9tTmF2LmdldE5leHRUZXh0Tm9kZU5vSW1nKHJlc3VsdC5ub2RlLCBmYWxzZSwgcF9lbmROb2RlLCB0cnVlKTtcbiAgICAgICAgICAgIHdoaWxlICh0bXBOb2RlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHRtcE5vZGUgPT0gcF9lbmROb2RlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yd19zZXROb2RlQmFja2dyb3VuZCh0bXBOb2RlLCAwLCBwX2VuZE9mZnNldCwgcF9zdHJTdGF0ZSwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHRtcE5vZGUgPSByZXN1bHQubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucndfc2V0Tm9kZUJhY2tncm91bmQodG1wTm9kZSwgLTEsIC0xLCBwX3N0clN0YXRlLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wTm9kZSA9IHJlc3VsdC5ub2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRtcE5vZGUgaXMgZW5kIG5vZGUgKGZyb20gc2V0dGluZyBmcm9tIHJlc3VsdCkgd2lsbCBnZXQgbnVsbCBoZXJlIGFuZCBicmVha1xuICAgICAgICAgICAgICAgIHRtcE5vZGUgPSBkb21OYXYuZ2V0TmV4dFRleHROb2RlTm9JbWcodG1wTm9kZSwgZmFsc2UsIHBfZW5kTm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJ3X3NldFNwZWVjaFJhbmdlSW1wbCBlcnJvcjpcIisgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGtldmlubWwgb24gMjUvMDQvMjAxNi5cbiAqL1xuaW1wb3J0IHtTcGVlY2hIaWdobGlnaHRDb250cm9sbGVyfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0hpZ2hsaWdodGluZy9TcGVlY2hIaWdobGlnaHRDb250cm9sbGVyJ1xuaW1wb3J0IHtNYXRoSmF4SGlnaGxpZ2h0Q29udHJvbGxlcn0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9IaWdobGlnaHRpbmcvTWF0aEpheEhpZ2hsaWdodENvbnRyb2xsZXInXG5cbmV4cG9ydCBjbGFzcyBTcGVlY2hIaWdobGlnaHRNYW5hZ2Vye1xuICAgIGNvbnN0cnVjdG9yKHNlbnRlbmNlKXtcbiAgICAgICAgaWYgKHNlbnRlbmNlLmlzTWF0aE1MKCkpe1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRDb250cm9sbGVyID0gbmV3IE1hdGhKYXhIaWdobGlnaHRDb250cm9sbGVyKHNlbnRlbmNlKTtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRDb250cm9sbGVyPSBuZXcgU3BlZWNoSGlnaGxpZ2h0Q29udHJvbGxlcihzZW50ZW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoaWdobGlnaHRSYW5nZSgpe1xuICAgICAgICB0aGlzLmhpZ2hsaWdodENvbnRyb2xsZXIuaGlnaGxpZ2h0UmFuZ2UoKTtcbiAgICB9XG5cbiAgICB1bkhpZ2hsaWdodFJhbmdlKCl7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Q29udHJvbGxlci51bkhpZ2hsaWdodFJhbmdlKCk7XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0V29yZCh3b3JkTm8pe1xuICAgICAgICB0aGlzLmhpZ2hsaWdodENvbnRyb2xsZXIuaGlnaGxpZ2h0V29yZCh3b3JkTm8pO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDAyLzA1LzIwMTYuXG4gKi9cblxuaW1wb3J0IHtTU0RPTX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9ET00vU1NET00nXG5pbXBvcnQge1RIRG9tUmFuZ2V9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhEb21SYW5nZSdcbmltcG9ydCB7VEhDYXJldFJhbmdlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIQ2FyZXRSYW5nZSdcbmltcG9ydCB7VEhSZXR1cm5PYmplY3R9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhSZXR1cm5PYmplY3QnXG5pbXBvcnQge1V0aWxpdGllc30gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9VdGlsaXRpZXMvVXRpbGl0aWVzJ1xuaW1wb3J0IHtIaWdobGlnaHRCYXNlQ29udHJvbGxlcn0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9IaWdobGlnaHRpbmcvSGlnaGxpZ2h0QmFzZUNvbnRyb2xsZXInXG5pbXBvcnQge0RvbU5hdmlnYXRpb259IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL0RvbU5hdmlnYXRpb24nXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9ET00vQXR0cmlidXRlJ1xuaW1wb3J0ICogYXMgQ29uc3RhbnRzIGZyb20gJ3NyYy9Db25zdGFudHMvQ29uc3RhbnRzJ1xuXG5leHBvcnQgY2xhc3MgU3R1ZHlTa2lsbHNIaWdobGlnaHRpbmcgZXh0ZW5kcyBIaWdobGlnaHRCYXNlQ29udHJvbGxlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmdfYVRleHRSYW5nZT1uZXcgQXJyYXkoKTtcbiAgICAgICAgdGhpcy5nX2FIaWdobGlnaHRDb2xvdXIgPSBuZXcgQXJyYXkoKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIGxpc3Qgb2Ygd29yZHMgdG8gbG9va3VwIGluIEFycmF5XG4gICAgZmV0Y2hXb3JkcyAgKCkge1xuICAgICAgICB2YXIgZ19iSUVPbGQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHdvcmRMaXN0ID0gbmV3IEFycmF5KCk7XG5cbiAgICAgICAgdmFyIHRtcEFyciA9IG5ldyBBcnJheSgpO1xuICAgICAgICB2YXIgbkxlbiA9IHRoaXMuZ19hVGV4dFJhbmdlLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHJXb3JkO1xuXG4gICAgICAgICAgICBpZiAoZ19iSUVPbGQpIHsgICAvL0lFXG4gICAgICAgICAgICAgICAgc3RyV29yZCA9IGdfYVRleHRSYW5nZS5zbGljZShpLCBpICsgMSkucG9wKCkudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAgIC8vU0ZGXG4gICAgICAgICAgICAgICAgc3RyV29yZCA9IHRoaXMuZ19hVGV4dFJhbmdlW2ldLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHNpbmdsZSB3b3JkXG4gICAgICAgICAgICBpZiAoc3RyV29yZC50cmltVEgoKS5pbmRleE9mKFwiIFwiKSA9PSAtMSkgeyAgIC8vIG5vIGludGVybmFsIHNwYWNlc1xuICAgICAgICAgICAgICAgIHRtcEFyci5wdXNoKHRoaXMuZ19hVGV4dFJhbmdlLnNsaWNlKGksIGkgKyAxKS5wb3AoKSk7XG5cbi8vICAgICAgICAgICAgICAgIGlmICh0bXBBcnIubGVuZ3RoID49IGdfblZvY2FiTGltaXQgJiYgZ19uVm9jYWJMaW1pdCAhPSAtMSkge1xuLy8gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2JTZW50ZW5jZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnX2JJRU9sZCkgey8vSUVcbiAgICAgICAgICAgIC8vIGlmIHdhbnQgdG8gc2hvdyBieSBvcmRlciBpbiBwYWdlIGxlYXZlIGluIG5leHQgbGluZSwgaWYgd2FudCBieSBvcmRlciBzZWxlY3RlZCByZW1vdmUgbmV4dCBsaW5lXG4gICAgICAgICAgICB0bXBBcnIuc29ydCh0aGlzLnNvcnRCeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgLy8gU0ZGXG4gICAgICAgICAgICB0bXBBcnIuc29ydCh0aGlzLnNvcnRCeVNGRik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgblRtcExlbiA9IHRtcEFyci5sZW5ndGg7XG4gICAgICAgIHZhciBzdHJUbXA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgblRtcExlbjsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZ19iSUVPbGQpIHsgICAvL0lFXG4gICAgICAgICAgICAgICAgc3RyVG1wID0gdG1wQXJyLnNsaWNlKGosIGogKyAxKS5wb3AoKS50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7ICAgLy9TRkZcbiAgICAgICAgICAgICAgICBzdHJUbXAgPSB0bXBBcnJbal0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyVG1wID0gc3RyVG1wLnRyaW0oKTtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzID0gJy4sPyEnO1xuICAgICAgICAgICAgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFxbXFxdKCl7fT8qK1xcXiRcXFxcLnxcXC1dL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBcImdcIjtcbiAgICAgICAgICAgIGNoYXJhY3RlcnMgPSBlc2NhcGVSZWdleChjaGFyYWN0ZXJzKTtcblxuICAgICAgICAgICAgc3RyVG1wID0gc3RyVG1wLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5bXCIgKyBjaGFyYWN0ZXJzICsgXCJdK3xbXCIgKyBjaGFyYWN0ZXJzICsgXCJdKyRcIiwgZmxhZ3MpLCAnJyk7XG5cbiAgICAgICAgICAgIHdvcmRMaXN0LnB1c2goc3RyVG1wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3b3JkTGlzdDtcbiAgICB9O1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRleHQgaWYgYW55IGZvciB0aGUgZ2l2ZW4gY29sb3VyXG4gICAgc3R1ZHlTa2lsbHNDb2xsYXRlRm9yQ29sb3VyKHBfc3RyQ29sb3VyKVxuICAgIHtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIC8vIHRtcEFyciBjb250YWlucyBUZXh0UmFuZ2UgZm9yIElFIGFuZCBUSERvbVJhbmdlIGZvciBTRkZcbiAgICAgICAgdmFyIHRtcEFyciA9IG5ldyBBcnJheSgpO1xuXG4gICAgICAgIHZhciBuTGVuID0gdGhpcy5nX2FUZXh0UmFuZ2UubGVuZ3RoO1xuICAgICAgICB2YXIgc3RyRnVsbCA9IFwiXCI7XG4gICAgICAgIHZhciBzdHJGb3JDb2xvdXIgPSAnJztcbiAgICAgICAgdmFyIG5Db3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGlTZWdJbmRleCA9IDA7IGlTZWdJbmRleCA8IG5MZW47IGlTZWdJbmRleCsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RyTmFtZSA9IHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyW2lTZWdJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChzdHJOYW1lID09IHBfc3RyQ29sb3VyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRtcEFyci5wdXNoKHRoaXMuZ19hVGV4dFJhbmdlLnNsaWNlKGlTZWdJbmRleCwgaVNlZ0luZGV4ICsgMSkucG9wKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdfYklFT2xkKVxuICAgICAgICB7Ly9JRVxuICAgICAgICAgICAgLy8gaWYgd2FudCB0byBzaG93IGJ5IG9yZGVyIGluIHBhZ2UgbGVhdmUgaW4gbmV4dCBsaW5lLCBpZiB3YW50IGJ5IG9yZGVyIHNlbGVjdGVkIHJlbW92ZSBuZXh0IGxpbmVcbiAgICAgICAgICAgIHRtcEFyci5zb3J0KHRoaXMuc29ydEJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHsgICAvLyBTRkZcbiAgICAgICAgICAgIHRtcEFyci5zb3J0KHRoaXMuc29ydEJ5U0ZGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuVG1wTGVuID0gdG1wQXJyLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0clRtcDtcbiAgICAgICAgdmFyIHV0aWxpdGllcyA9IG5ldyBVdGlsaXRpZXMoKTtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPW5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKHZhciBpU2VnSW5kZXggPSAwOyBpU2VnSW5kZXggPCBuVG1wTGVuOyBpU2VnSW5kZXgrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNhcmV0UmFuZ2U7XG4gICAgICAgICAgICB2YXIgZ19iSUVPbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChnX2JJRU9sZClcbiAgICAgICAgICAgIHsgICAvL0lFXG4gICAgICAgICAgICAgICAgdmFyIHRtcFRleHRSYW5nZSA9IHRtcEFyci5zbGljZShpU2VnSW5kZXgsIGlTZWdJbmRleCArIDEpLnBvcCgpO1xuICAgICAgICAgICAgICAgIHZhciB0bXBUSFJhbmdlID0gc3Nkb20ucndfZ2V0VGV4dFJhbmdlQXNUSFJhbmdlKHRtcFRleHRSYW5nZS5wYXJlbnRFbGVtZW50KCkub3duZXJEb2N1bWVudC5ib2R5LCB0bXBUZXh0UmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNhcmV0UmFuZ2UgPSB0bXBUSFJhbmdlLnJ3X2dldFRIQ2FyZXRSYW5nZUZyb21USFJhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7ICAgLy9TRkZcbiAgICAgICAgICAgICAgICBjYXJldFJhbmdlID0gdG1wQXJyW2lTZWdJbmRleF0ucndfZ2V0VEhDYXJldFJhbmdlRnJvbVRIRG9tUmFuZ2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyVG1wID0gY2FyZXRSYW5nZS5nZXRUZXh0T3ZlckNhcmV0UmFuZ2UoKTtcblxuICAgICAgICAgICAgaWYgKHN0clRtcC5sZW5ndGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBmb3IgZG9kZ3kgdGV4dCAgaS5lLiA8IGFuZCA+IHRoYXQgd2lsbCBiZSB0cmVhdGVkIGFzIGh0bWwgcmF0aGVyIHRoYW4gZGlzcGxheWVkLlxuXG4gICAgICAgICAgICAgICAgc3RyVG1wID0gdXRpbGl0aWVzLnJ3X2ZpbHRlckZvckh0bWwoc3RyVG1wKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goe1wiY29sb3JcIjpwX3N0ckNvbG91cixcInRleHRcIjpzdHJUbXB9KVxuLy8gICAgICAgICAgICAgICAgaWYobkNvdW50ID4gMCl7c3RyRm9yQ29sb3VyICs9ICc8YnI+Jzt9XG4vLyAgICAgICAgICAgICAgICBuQ291bnQrKztcbi8vICAgICAgICAgICAgICAgIHN0ckZvckNvbG91ciArPSAnJyArIG5Db3VudCArICc6ICcgKyBzdHJUbXAgKyAnPGJyPic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihuQ291bnQgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdHJGdWxsICs9ICc8cD48L3A+JztcbiAgICAgICAgICAgIHN0ckZ1bGwgKz0gJzxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kOicgKyBwX3N0ckNvbG91ciArICdcIj4nO1xuICAgICAgICAgICAgc3RyRnVsbCArPSBzdHJGb3JDb2xvdXI7XG4gICAgICAgICAgICBzdHJGdWxsICs9ICc8L2Rpdj48cD48L3A+JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cblxuICAgIC8vIERldGVybWluZSB0ZXh0IGlmIGFueSBmb3IgdGhlIGdpdmVuIGNvbG91clxuICAgIHN0dWR5U2tpbGxzQ29sbGF0ZUZvckNvbG91cihjb2xvcnMpIHtcbiAgICAgICAgLy8gdG1wQXJyIGNvbnRhaW5zIFRleHRSYW5nZSBmb3IgSUUgYW5kIFRIRG9tUmFuZ2UgZm9yIFNGRlxuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIHRtcEFyciA9IG5ldyBBcnJheSgpO1xuICAgICAgICB2YXIgdG1wQ29sb3JBcnIgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdmFyIGNvbG9yVGV4dEFycmF5ID0gW107XG5cbiAgICAgICAgdmFyIG5MZW4gPSB0aGlzLmdfYVRleHRSYW5nZS5sZW5ndGg7XG4gICAgICAgIHZhciBzdHJGdWxsID0gXCJcIjtcbiAgICAgICAgdmFyIHN0ckZvckNvbG91ciA9ICcnO1xuICAgICAgICB2YXIgbkNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaVNlZ0luZGV4ID0gMDsgaVNlZ0luZGV4IDwgbkxlbjsgaVNlZ0luZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzdHJOYW1lID0gdGhpcy5nX2FIaWdobGlnaHRDb2xvdXJbaVNlZ0luZGV4XTtcblxuICAgICAgICAgICAgaWYgKGNvbG9ycy5pbmRleE9mKHN0ck5hbWUpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5nX2FUZXh0UmFuZ2Uuc2xpY2UoaVNlZ0luZGV4LCBpU2VnSW5kZXggKyAxKS5wb3AoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xvciA9IHN0ck5hbWU7XG4gICAgICAgICAgICAgICAgdG1wQXJyLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICB0bXBDb2xvckFyci5wdXNoKHN0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnX2JJRU9sZCA9IGZhbHNlO1xuICAgICAgICBpZiAoZ19iSUVPbGQpIHsvL0lFXG4gICAgICAgICAgICAvLyBpZiB3YW50IHRvIHNob3cgYnkgb3JkZXIgaW4gcGFnZSBsZWF2ZSBpbiBuZXh0IGxpbmUsIGlmIHdhbnQgYnkgb3JkZXIgc2VsZWN0ZWQgcmVtb3ZlIG5leHQgbGluZVxuICAgICAgICAgICAgdG1wQXJyLnNvcnQodGhpcy5zb3J0QnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgIC8vIFNGRlxuICAgICAgICAgICAgdG1wQXJyLnNvcnQodGhpcy5zb3J0QnlTRkYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5UbXBMZW4gPSB0bXBBcnIubGVuZ3RoO1xuICAgICAgICB2YXIgc3RyVG1wO1xuICAgICAgICB2YXIgdXRpbGl0aWVzID0gbmV3IFV0aWxpdGllcygpO1xuICAgICAgICBmb3IgKHZhciBpU2VnSW5kZXggPSAwOyBpU2VnSW5kZXggPCBuVG1wTGVuOyBpU2VnSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNhcmV0UmFuZ2U7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0bXBBcnJbaVNlZ0luZGV4XS5jb2xvcjtcblxuICAgICAgICAgICAgaWYgKGdfYklFT2xkKSB7ICAgLy9JRVxuICAgICAgICAgICAgICAgIHZhciB0bXBUZXh0UmFuZ2UgPSB0bXBBcnIuc2xpY2UoaVNlZ0luZGV4LCBpU2VnSW5kZXggKyAxKS5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wVEhSYW5nZSA9IHNzZG9tLnJ3X2dldFRleHRSYW5nZUFzVEhSYW5nZSh0bXBUZXh0UmFuZ2UucGFyZW50RWxlbWVudCgpLm93bmVyRG9jdW1lbnQuYm9keSwgdG1wVGV4dFJhbmdlKTtcbiAgICAgICAgICAgICAgICBjYXJldFJhbmdlID0gdG1wVEhSYW5nZS5yd19nZXRUSENhcmV0UmFuZ2VGcm9tVEhSYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7ICAgLy9TRkZcbiAgICAgICAgICAgICAgICBjYXJldFJhbmdlID0gdG1wQXJyW2lTZWdJbmRleF0ucndfZ2V0VEhDYXJldFJhbmdlRnJvbVRIRG9tUmFuZ2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyVG1wID0gY2FyZXRSYW5nZS5nZXRUZXh0T3ZlckNhcmV0UmFuZ2UoKTtcblxuICAgICAgICAgICAgaWYgKHN0clRtcC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGZvciBkb2RneSB0ZXh0ICBpLmUuIDwgYW5kID4gdGhhdCB3aWxsIGJlIHRyZWF0ZWQgYXMgaHRtbCByYXRoZXIgdGhhbiBkaXNwbGF5ZWQuXG4gICAgICAgICAgICAgICAgc3RyVG1wID0gdXRpbGl0aWVzLnJ3X2ZpbHRlckZvckh0bWwoc3RyVG1wKTtcblxuICAgICAgICAgICAgICAgIC8vICAgICAgICBpZihuQ291bnQgPiAwKXtzdHJGb3JDb2xvdXIgKz0gJzxicj4nO31cbiAgICAgICAgICAgICAgICBuQ291bnQrKztcbiAgICAgICAgICAgICAgICAvLyBzdHJGb3JDb2xvdXIgKz0gJycgKyBuQ291bnQgKyAnOiAnICsgc3RyVG1wICsgJzxicj4nO1xuXG4gICAgICAgICAgICAgICAgY29sb3JUZXh0QXJyYXkucHVzaCh7ICd0ZXh0Jzogc3RyVG1wLCAnY29sb3InOiBjb2xvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qICBpZihuQ291bnQgPiAwKVxuICAgICAgICAge1xuICAgICAgICAgc3RyRnVsbCArPSAnPHA+PC9wPic7XG4gICAgICAgICBzdHJGdWxsICs9ICc8ZGl2IHN0eWxlPVwiYmFja2dyb3VuZDonICsgcF9zdHJDb2xvdXIgKyAnXCI+JztcbiAgICAgICAgIHN0ckZ1bGwgKz0gc3RyRm9yQ29sb3VyO1xuICAgICAgICAgc3RyRnVsbCArPSAnPC9kaXY+PHA+PC9wPic7XG4gICAgICAgICB9ICAgICAgICAgICAqL1xuICAgICAgICByZXR1cm4gY29sb3JUZXh0QXJyYXk7XG4gICAgfVxuXG4gICAgLy8gU29ydCBmdW5jdGlvbiBmb3IgdGhlIHJhbmdlIG9iamVjdHNcbiAgICBzb3J0QnkoYSwgYilcbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gYS5jb21wYXJlRW5kUG9pbnRzKFwiRW5kVG9FbmRcIiwgYik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXhjKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNvcnRieSBcIiArIGV4Yy5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9maXggZm9yIGRvZGd5IGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgZGlzcGxheWVkIGluIGh0bWwgd2l0aG91dCBiZWluZyBhbHRlcmVkLlxuXG5cbiAgICAvKkEgRmlyZWZveCBzb3J0IGFsZ29yaXRobSBmb3IgdXNlIHdpdGggYW4gYXJyYXkgb2YgVEhEb21SYW5nZSBvYmplY3RzKi9cbi8vIFNvcnQgZnVuY3Rpb24gZm9yIHRoZSByYW5nZSBvYmplY3RzXG4gICAgc29ydEJ5U0ZGKGEsIGIpXG4gICAge1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoYS5lcXVhbHMoYikpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGEucmVmcmVzaCgpO1xuICAgICAgICAgICAgYi5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIHZhciBhRW5kID0gYS5nZXRFbmRBc1JhbmdlKCk7XG4gICAgICAgICAgICB2YXIgYkVuZCA9IGIuZ2V0RW5kQXNSYW5nZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gYUVuZC5jb21wYXJlQm91bmRhcnlQb2ludHMoXCJFTkRfVE9fRU5EXCIsIGJFbmQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGV4YylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJzb3J0QnlTRkYgXCIgKyBleGMubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qSGlnaGxpZ2h0cyB0aGUgYmFjayBjb2xvciBvZiBhIHNlbGVjdGlvbiBpbiBpbnRlcm5ldCBleHBsb3JlciB3aXRoIHRoZSBjb2xvciBwYXNzZWQgaW4qL1xuICAgIHN0dWR5U2tpbGxzSFRNTEhpZ2hsaWdodFJhbmdlKHBfc3RyQ29sb3VyLHNlbE9iailcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmIChzZWxPYmogPT0gbnVsbCB8fCBzZWxPYmoucmFuZ2UgPT0gbnVsbFxuICAgICAgICAgICAgICAgIHx8IHNlbE9iai5yYW5nZSBpbnN0YW5jZW9mIFN0cmluZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vVGhpcyBpcyBlaXRoZXIgVGV4dFJhbmdlIG9yIFRIRG9tUmFuZ2VcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IHNlbE9iai5yYW5nZTtcblxuICAgICAgICAgICAgdmFyIGdfYklFT2xkID0gZmFsc2U7XG4gICAgICAgICAgICBpZihnX2JJRU9sZClcbiAgICAgICAgICAgIHsgICAvLyBjb252ZXJ0IHRvIHRoUmFuZ2UgdG8gdGVzdFxuICAgICAgICAgICAgICAgIHZhciBib2QgPSBzZWxlY3Rpb25SYW5nZS5wYXJlbnRFbGVtZW50KCkub3duZXJEb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgICAgIHZhciB0aFJhbmdlID0gc3Nkb20ucndfZ2V0VGV4dFJhbmdlQXNUSFJhbmdlKGJvZCwgc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmKHRoUmFuZ2UgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FyZXRSYW5nZSA9ICBuZXcgVEhDYXJldFJhbmdlKGJvZCxcbiAgICAgICAgICAgICAgICAgICAgdGhSYW5nZS5zdGFydFJlZi5wYXRoLFxuICAgICAgICAgICAgICAgICAgICB0aFJhbmdlLnN0YXJ0UmVmLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgdGhSYW5nZS5lbmRSZWYucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgdGhSYW5nZS5lbmRSZWYub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDYXJldCA9IGNhcmV0UmFuZ2UubGVmdENhcmV0O1xuICAgICAgICAgICAgICAgIHZhciBlbmRDYXJldCA9IGNhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0Q2FyZXQgPT0gbnVsbCB8fCBlbmRDYXJldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0aERvbVJhbmdlID0gbmV3IFRIRG9tUmFuZ2Uoc3RhcnRDYXJldC5ub2RlLCBzdGFydENhcmV0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ2FyZXQubm9kZSwgZW5kQ2FyZXQub2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgIGlmKHRoRG9tUmFuZ2UgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoRG9tUmFuZ2UgPSB0aGlzLnJ3X2NoZWNrVEhSYW5nZUZvclZhbGlkSGlnaGxpZ2h0KHRoRG9tUmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgaWYodGhEb21SYW5nZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UgPSBzc2RvbS5yd19nZXRBc1RleHRSYW5nZShib2QsXG4gICAgICAgICAgICAgICAgICAgIHRoRG9tUmFuZ2Uuc3RhcnRSZWYucGF0aCwgdGhEb21SYW5nZS5zdGFydFJlZi5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHRoRG9tUmFuZ2UuZW5kUmVmLnBhdGgsIHRoRG9tUmFuZ2UuZW5kUmVmLm9mZnNldCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgeyAgIC8vU0ZGXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UgPSB0aGlzLnJ3X2NoZWNrVEhSYW5nZUZvclZhbGlkSGlnaGxpZ2h0KHNlbGVjdGlvblJhbmdlKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzZWxlY3Rpb25SYW5nZSA9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vcndfYWxlcnQoXCJGYWlsZWQgdG8gZG8gdGhlIGhpZ2hsaWdodCwgcG9zc2libHkgZHVlIHRvIHNlbGVjdGlvbiBnb2luZyBpbnRvIGEgbm9uIHRleHR1YWwgcGFydCBvZiB0aGUgcGFnZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vY29sbGFwc2UgdGhlIHNlbGVjdGlvbiBiZWZvcmUgaGlnaGxpZ2h0aW5nIGR1ZSB0byBlZGdlIGJ1Zy5cbiAgICAgICAgICAgIC8vIGlmIGRvdWJsZSBjbGljayB0byBzZWxlY3QgKG5vdCBkcmFnKSB0aGUgaGlnaGxpZ2h0aW5nIGdsaXRjaGVzIGluIGVkZ2UgYWZ0ZXIgaGlnaGxpZ2h0aW5nLCBkdWUgdG8gcmVwbGFjaW5nIGVsZW1lbnQgaW4gRE9NIHRoYXQgaGFzIHRoZSBoaWdobGlnaHRpbmcuXG4gICAgICAgICAgICAvLyBoYXMgYWxyZWFkeSBzdG9yZWQgdGhlIGhpZ2hsaWdodCByYW5nZSBmaXJzdCBzbyBjYW4gcmVtb3ZlIGJlZm9yZSBzdHVkeSBza2lsbCBoaWdobGlnaHRpbmcuXG4gICAgICAgICAgICBzc2RvbS5yd19jb2xsYXBzZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnN0dWR5U2tpbGxzSFRNTEhpZ2hsaWdodFJhbmdlSW1wbChzZWxlY3Rpb25SYW5nZSwgcF9zdHJDb2xvdXIpO1xuXG4gICAgICAgICAgICAvLyBSZXBvcnQgaXRcbiAgICAgICAgICAgIHZhciByZXBvcnRlciA9IFNwZWVjaFN0cmVhbS5hbmFseXRpY3M7XG4gICAgICAgICAgICByZXBvcnRlci5yZXBvcnQocmVwb3J0ZXIuY2F0ZWdvcmllcy5ISUdITElHSFQsIHBfc3RyQ29sb3VyKTtcblxuICAgICAgICAgICAgLy9JdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGlzIGlzIG9ubHkgY2FsbGVkIGZyb20gdGhlIHVzZXIgY2FsbGVkIGhpZ2hsaWdodGluZyBhbmQgbm90XG4gICAgICAgICAgICAvL3RoZSBjb21wdXRlciBnZW5lcmF0ZWQgY2FsbHMsIGFzIHdvdWxkIGJyZWFrIGRhdGEgd2hlbiByZXN0b3JpbmcgYnkgY2FsbGluZyBkYiB3aGlsZSByZXRyaWV2aW5nIGZyb20gaXQuXG4vLyAgdG9kbyBhZGQgaW4gbGF0ZXIgICAgICAgICAgaWYoZ19iUGVyc2lzdEFubm90YXRpb25zICYmIGdfYlBlcnNpc3RIaWdobGlnaHRzICYmXG4vLyAgICAgICAgICAgICAgICB0eXBlb2Yocndfc3RvcmVIaWdobGlnaHREYXRhKSAhPSBcInVuZGVmaW5lZFwiKSAgICAgIC8vY2hlY2sgdGhhdCB0aGUgZnVjbnRpb24gZXhpc3RzXG4vLyAgICAgICAgICAgIHsgICAvLyBjYWxsIGlmIHBrdCB3aXRoIHN0dWRlbnQgaWQgZ2l2ZW4gYW5kIG5vdCBhIHRlYWNoZXIgIChvciBmb3IgZ2VuZXJpYyBzdG9yYWdlKVxuLy8gICAgICAgICAgICAgICAgcndfc3RvcmVIaWdobGlnaHREYXRhKCk7XG4vLyAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4YylcbiAgICAgICAge1xuICAgICAgICAgICAgLy9hbGVydChcIkVycm9yIGluIG1ldGhvZDogXCIgKyBleGMubmFtZSArIFwiIFwiICsgZXhjLm1lc3NhZ2UgKyBcIiBcIiArIGV4Yy5kZXNjcmlwdGlvbiArIFwiIFwiICsgZXhjLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWJzdHJhY3Qgb3V0IHBhcnQgc28gY2FuIGhpZ2hsaWdodCBiYXNlZCBvbiBzZWxlY3Rpb24gaW4gcGFnZSBhbmRcbi8vIHByb2dyYW1tYXRpY2FsbHkgaW4gY29kZVxuLy8gcF9yYW5nZSBUaGlzIGlzIGVpdGhlciBUZXh0UmFuZ2Ugb3IgVEhEb21SYW5nZVxuICAgIHN0dWR5U2tpbGxzSFRNTEhpZ2hsaWdodFJhbmdlSW1wbChwX3JhbmdlLCBwX3N0ckNvbG91cilcbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgICAgIHZhciBiRGlzcGxheUlzc3VlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB0bXBOb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBzdG9yZWREaXNwbGF5VmFsdWUgPSBudWxsO1xuXG4gICAgICAgICAgICB2YXIgc3RyU2VsZWN0VGV4dCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgYmxuQWRkTmV3UmFuZ2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgaWYgKHBfcmFuZ2UgPT0gbnVsbCB8fCBwX3JhbmdlIGluc3RhbmNlb2YgU3RyaW5nKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTk9URSwgaWYgYW4gZXhpc3RpbmcgcmFuZ2UgaXMgZWRpdGVkLCBzdWNoIGFzIG92ZXJsYXBwaW5nIGZpcnN0LCB0aGUgZ19hVGV4dFJhbmdlIGlzIHJlbWFkZVxuICAgICAgICAgICAgLy8gYW5kIG1pZ2h0IGhhdmUgYSBkaWZmZXJlbnQgb3JkZXIsIHNvIGlmIGEgY2hhbmdlIGlzIG1hZGUsIG5lZWQgdG8gcmVzZXQgYW5kIHN0YXJ0IGFnYWluIGZyb20gdGhlIHN0YXJ0LlxuICAgICAgICAgICAgLy8gQWRkIGluIGEgc2ltcGxlIGNoZWNrIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBpbmZpbml0ZSBsb29wICh3aGVyZSB0aGVyZSBpcyBhbiBvdmVybGFwIGJ1dCBpcyBub3QgY2hhbmdlZCBmb3Igc29tZSByZWFzb24uKVxuICAgICAgICAgICAgdmFyIG5JbmZpbml0ZUNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBiQ2hhbmdlTWFkZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGRvIGJyb3dzZXIgZGV0ZWN0aW9uIHJhdGhlciB0aGFuIG9iamVjdCBkZXRlY3Rpb24sIGFzIG9iamVjdCBleGlzdHMgaW4gSUUgOCBhbmQgSUUgOSBidXQgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBiZWhhdmlvdXIgcmVxdWlyZWQuIE9iamVjdCBkZXRlY3Rpb24gZmFpbHMgd2hlbiBvYmplY3QgZXhpc3RzIGluIGJvdGggcGxhY2VzIGJ1dCBpbXBsZW1lbnRlZCBkaWZmZXJlbnRseS5cbiAgICAgICAgICAgIHZhciBnX2JJRU9sZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGdfYklFT2xkKVxuICAgICAgICAgICAgey8vSUVcbiAgICAgICAgICAgICAgICAvL2dldCB0aGUgdGV4dCBwcm9wZXJ0eSBvZiB0aGUgc2VsZWN0aW9uIHJhbmdlXG4gICAgICAgICAgICAgICAgc3RyU2VsZWN0VGV4dCA9IHBfcmFuZ2UucndfZ2V0VGV4dEZyb21SYW5nZSgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiBudWxsIHRoZXJlIGlzIG5vIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChzdHJTZWxlY3RUZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHBhcmVudCBzZXQgdG8gZGlzcGxheSBub25lXG4gICAgICAgICAgICAgICAgICAgIHRtcE5vZGUgPSBwX3JhbmdlLnBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZVN0eWxlID0gU1NET00uZ2V0Q29tcHV0ZWRTdHlsZSh0bXBOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhlU3R5bGUgIT0gbnVsbCAmJiAodGhlU3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIikpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJEaXNwbGF5SXNzdWVNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9kID0gdG1wTm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSh0bXBOb2RlICE9IGJvZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBOb2RlID0gdG1wTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNTRE9NLmdldENvbXB1dGVkU3R5bGUodG1wTm9kZSkuZGlzcGxheSA9PSBcIm5vbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJEaXNwbGF5SXNzdWVNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKGJEaXNwbGF5SXNzdWVNYXRjaClcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vIG5lZWQgdG8gbWFrZSBkaXNwbGF5ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZERpc3BsYXlWYWx1ZSA9IHRtcE5vZGUuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcE5vZGUuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZSl7LyoqKi99XG5cblxuICAgICAgICAgICAgICAgIHN0dWR5U2tpbGxzSFRNTFJlZnJlc2hSYW5nZXMoKTtcblxuICAgICAgICAgICAgICAgIC8vZW51bWVyYXRlIHRoZSBzdHJ1Y3R1cmUgdG8gc2VlIGlmIHdlIGFyZSBvdmVyd3JpdGluZyBhIGN1cnJlbnQgdGV4dCByYW5nZSBmaXJzdFxuICAgICAgICAgICAgICAgIC8vYmVmb3JlIGFkZGluZyBhIG5ldyByYW5nZVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaVJhbmdlSW5kZXggPSAwOyBpUmFuZ2VJbmRleCA8IHRoaXMuZ19hVGV4dFJhbmdlLmxlbmd0aDsgaVJhbmdlSW5kZXgrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgdGhhdCBvdXIgdGV4dCByYW5nZXMgZnJvbSB0aGUgc3RvcmVkIHRvIHRoZSBzZWxlY3Rpb24gZG8gbm90IGNvbmZsaWN0XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlZFJhbmdlID0gdGhpcy5nX2FUZXh0UmFuZ2VbaVJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIHRoYXQgd2UgYXJlIG5vdCB1c2luZyB0ZXh0IGZyb20gZGlmZmVyZW50IGZyYW1lcyBpbiB0aGUgc2FtZSBwYWdlXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGR1cEN1cnJlbnRUZXh0UmFuZ2UgPSBwX3JhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkdXBDdXJyZW50VGV4dFJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYlN0YXJ0ID0gc3RvcmVkUmFuZ2UuaW5SYW5nZShkdXBDdXJyZW50VGV4dFJhbmdlKTtcblxuICAgICAgICAgICAgICAgICAgICBkdXBDdXJyZW50VGV4dFJhbmdlID0gcF9yYW5nZS5kdXBsaWNhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZHVwQ3VycmVudFRleHRSYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiRW5kID0gc3RvcmVkUmFuZ2UuaW5SYW5nZShkdXBDdXJyZW50VGV4dFJhbmdlKTtcblxuICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlTWFkZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiU3RhcnQgJiYgYkVuZClcbiAgICAgICAgICAgICAgICAgICAgeyAgLy8gbmV3IHNlbGVjdGlvbiBlbnRpcmVseSBpbnNpZGUgYW4gZXhpc3RpbmcgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgbmV3IHNlbGVjdGlvbiBpcyBzYW1lIGNvbG91ciBhcyBleGlzdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5nX2FIaWdobGlnaHRDb2xvdXJbaVJhbmdlSW5kZXhdID09IHBfc3RyQ29sb3VyKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0cyB0aGUgc2FtZSBjb2xvdXIgYXMgZXhpc3Rpbmcgc2VsZWN0aW9uLCBubyBuZWVkIHRvIHJlcGxhY2UgYW55dGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG5BZGROZXdSYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UxSUUoaVJhbmdlSW5kZXgsIHBfcmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIG1hZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlTWFkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWJTdGFydCAmJiBiRW5kKVxuICAgICAgICAgICAgICAgICAgICB7ICAvLyBuZXcgc2VsZWN0aW9uIGJlZm9yZSBhbmQgZW5kcyBpbiBhbiBleGlzdGluZyByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZTJJRShpUmFuZ2VJbmRleCwgcF9yYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBtYWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlTWFkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYlN0YXJ0ICYmICFiRW5kKVxuICAgICAgICAgICAgICAgICAgICB7ICAvLyBuZXcgc2VsZWN0aW9uIHN0YXJ0cyBpbiBhbmQgZW5kcyBhZnRlciBhbiBleGlzdGluZyByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZTNJRShpUmFuZ2VJbmRleCwgcF9yYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBtYWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlTWFkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocF9yYW5nZS5pblJhbmdlKHN0b3JlZFJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgeyAgLy8gbmV3IHNlbGVjdGlvbiBjb250YWlucyBhbiBleGluc3RpbmcgcmFuZ2UgZW50aXJlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ19hVGV4dFJhbmdlLnNwbGljZShpUmFuZ2VJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdfYUhpZ2hsaWdodENvbG91ci5zcGxpY2UoaVJhbmdlSW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpUmFuZ2VJbmRleC0tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgbWFkZVxuICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZU1hZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoYkNoYW5nZU1hZGUpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvLyBSZXNldCB0byAwIGluIHJhbmdlIHRvIGNoZWNrIGFsbCBhZ2FpbiBhcyBjaGFuZ2UgY291bGQgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVvcmdhbmlzZWQgdGhlIG9yZGVyIG9mIGl0ZW1zIGluIHRoaXMuZ19hVGV4dFJhbmdlLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGp1c3QgaW4gY2FzZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgKytuSW5maW5pdGVDb3VudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobkluZmluaXRlQ291bnQgPCAxMDApXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gbmV4dCBsb29wIGJhY2sgdG8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlSYW5nZUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGp1c3QgY2Fycnkgb24sIHdvcnN0IGNhc2UgaXMganVzdCBoaWdobGlnaHRzIG5vdCB1cGRhdGVkIGNvcnJlY3RseSwgYmV0dGVyIHRoYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IGluZGV4IGNoYW5nZXMgaW4gaWYgY2hlY2tzIHRvIHN0YW5kXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBfcmFuZ2UudG9TdHJpbmcpXG4gICAgICAgICAgICB7ICAvLyBzYWZhcmkgRmlyZWZveFxuICAgICAgICAgICAgICAgIGlmIChwX3JhbmdlID09IG51bGwgfHwgcF9yYW5nZS50b1N0cmluZygpID09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfHwgcF9yYW5nZS50b1N0cmluZygpID09IFwiXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBfcmFuZ2UgaXMgYSBUSERvbVJhbmdlXG5cbiAgICAgICAgICAgICAgICAvL1x0c3R1ZHlTa2lsbHNIVE1MUmVmcmVzaFJhbmdlcygpO1xuICAgICAgICAgICAgICAgIC8vZW51bWVyYXRlIHRoZSBzdHJ1Y3R1cmUgdG8gc2VlIGlmIHdlIGFyZSBvdmVyd3JpdGluZyBhIGN1cnJlbnQgdGV4dCByYW5nZSBmaXJzdFxuICAgICAgICAgICAgICAgIC8vYmVmb3JlIGFkZGluZyBhIG5ldyByYW5nZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGlSYW5nZUluZGV4ID0gMDsgaVJhbmdlSW5kZXggPCB0aGlzLmdfYVRleHRSYW5nZS5sZW5ndGg7IGlSYW5nZUluZGV4KyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIHRoYXQgb3VyIHRleHQgcmFuZ2VzIGZyb20gdGhlIHN0b3JlZCB0byB0aGUgc2VsZWN0aW9uIGRvIG5vdCBjb25mbGljdFxuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wRG9tUmFuZ2UgPSB0aGlzLmdfYVRleHRSYW5nZVtpUmFuZ2VJbmRleF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayB0aGF0IHdlIGFyZSBub3Qgd29ya2luZyB3aXRoIHRleHQgZnJvbSBkaWZmZXJlbnQgZnJhbWVzIHdpdGggb25lIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYocF9yYW5nZS5ib2R5Lm93bmVyRG9jdW1lbnQgPT0gdG1wRG9tUmFuZ2UuYm9keS5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgblJlc3VsdCA9IHBfcmFuZ2UuY29tcGFyZVJhbmdlKHRtcERvbVJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG5SZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuVEhEb21SYW5nZV9FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnN0YXR1cyA9IFwiRXJyb3Igb2NjdXJyZWQgd2hlbiB0cnlpbmcgdG8gYWRkIGEgaGlnaGxpZ2h0LlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5USERvbVJhbmdlX1RBUkdFVF9TQU1FOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBleGFjdGx5IHRoZSBzYW1lIGFuZCBzYW1lIGNvbG91ciBkbyBub3RoaW5nLCBvdGhlcndpc2UgZmFsbCB0aHJvdWdoIHRvIHRhcmdldCBpbnNpZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC8vdG9kbyAgIGlmKHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyW2lSYW5nZUluZGV4XSA9PSBwX3N0ckNvbG91cilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgLy8gSXRzIHRoZSBzYW1lIGNvbG91ciBhcyBleGlzdGluZyBzZWxlY3Rpb24sIG5vIG5lZWQgdG8gcmVwbGFjZSBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgYmxuQWRkTmV3UmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuVEhEb21SYW5nZV9UQVJHRVRfSU5TSURFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXcgc2VsZWN0aW9uIGNvbnRhaW5zIGFuIGV4aXN0aW5nIHJhbmdlIGVudGlyZWx5LCByZW1vdmUgZXhpc3RpbmdcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBEb21SYW5nZS5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucndfcmVtb3ZlSGlnaGxpZ2h0KHRoaXMuZ2V0TGlzdE9mSGlnaGxpZ2h0YWJsZU5vZGVzKHRtcERvbVJhbmdlLnN0YXJ0Q2FyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBEb21SYW5nZS5lbmRDYXJldCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ19hVGV4dFJhbmdlLnNwbGljZShpUmFuZ2VJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyLnNwbGljZShpUmFuZ2VJbmRleCwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pUmFuZ2VJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwX3JhbmdlLnJlZnJlc2goKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgbWFkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlTWFkZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuVEhEb21SYW5nZV9UQVJHRVRfSU5DTFVERVNfVEhJUzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5USERvbVJhbmdlX1RBUkdFVF9JTkNMVURFU19USElTX0FUX1NUQVJUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLlRIRG9tUmFuZ2VfVEFSR0VUX0lOQ0xVREVTX1RISVNfQVRfRU5EOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXcgc2VsZWN0aW9uIGVudGlyZWx5IGluc2lkZSBhbiBleGlzdGluZyByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIG5ldyBzZWxlY3Rpb24gaXMgc2FtZSBjb2xvdXIgYXMgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5nX2FIaWdobGlnaHRDb2xvdXJbaVJhbmdlSW5kZXhdID09IHBfc3RyQ29sb3VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdHMgdGhlIHNhbWUgY29sb3VyIGFzIGV4aXN0aW5nIHNlbGVjdGlvbiwgbm8gbmVlZCB0byByZXBsYWNlIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG5BZGROZXdSYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXNlMVNGRihpUmFuZ2VJbmRleCwgcF9yYW5nZSwgblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2lSYW5nZUluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgbWFkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZU1hZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLlRIRG9tUmFuZ2VfT1ZFUkxBUFNfU1RBUlRfT0ZfVEFSR0VUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXcgc2VsZWN0aW9uIGJlZm9yZSBhbmQgZW5kcyBpbiBhbiBleGlzdGluZyByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhc2UyU0ZGKGlSYW5nZUluZGV4LCBwX3JhbmdlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgbWFkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlTWFkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLlRIRG9tUmFuZ2VfT1ZFUkxBUFNfRU5EX09GX1RBUkdFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IHNlbGVjdGlvbiBzdGFydHMgaW4gYW5kIGVuZHMgYWZ0ZXIgYW4gZXhpc3RpbmcgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXNlM1NGRihpUmFuZ2VJbmRleCwgcF9yYW5nZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIG1hZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZU1hZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLlRIRG9tUmFuZ2VfQUZURVJfVEFSR0VUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5USERvbVJhbmdlX0JFRk9SRV9UQVJHRVQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOi8vZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICBpZihiQ2hhbmdlTWFkZSlcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vIFJlc2V0IHRvIDAgaW4gcmFuZ2UgdG8gY2hlY2sgYWxsIGFnYWluIGFzIGNoYW5nZSBjb3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW9yZ2FuaXNlZCB0aGUgb3JkZXIgb2YgaXRlbXMgaW4gdGhpcy5nX2FUZXh0UmFuZ2UuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEganVzdCBpbiBjYXNlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICArK25JbmZpbml0ZUNvdW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuSW5maW5pdGVDb3VudCA8IDEwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgICAvLyBuZXh0IGxvb3AgYmFjayB0byAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVJhbmdlSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UganVzdCBjYXJyeSBvbiwgd29yc3QgY2FzZSBpcyBqdXN0IGhpZ2hsaWdodHMgbm90IHVwZGF0ZWQgY29ycmVjdGx5LCBiZXR0ZXIgdGhhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgaW5kZXggY2hhbmdlcyBpbiBjYXNlcyB0byBzdGFuZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGdfYklFTmV3PSBmYWxzZTtcbiAgICAgICAgICAgIGlmKGdfYklFTmV3KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vSUU5IG5lZWRzIGl0IGNsZWFyZWQgYmVmb3JlIG9yIG90aGVyd2lzZSBzZWxlY3RzIHRoZSB3aG9sZSBzZW50ZW5jZVxuXG4gICAgICAgICAgICAgICAgLy9jb2xsYXBzZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgc3Nkb20ucndfY29sbGFwc2VTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRG8gdGhlIGFkZCBpZiBzdGlsbCBuZWVkZWRcbiAgICAgICAgICAgIGlmIChibG5BZGROZXdSYW5nZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGNoZWNraW5nIGZvciBwb3NpdGlvbiBsYXRlciBuZWVkIHRvIGlnbm9yZSBmb250IGVsZW1lbnRzIGFuZCBlbGVtZW50cyB3aXRoIHJ3c3RhdGVcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGFzIHRoZXNlIGNhbiByZWxhdGUgdG8gdGVtcG9yYXJ5IGhpZ2hsaWdodHMgc28gbm8gdXNlIGZvciBwZXJtYW5lbnQgcG9zaXRpb24gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICBpZihwX3JhbmdlLmV4ZWNDb21tYW5kKVxuICAgICAgICAgICAgICAgIHsgLy9JRVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0dWR5U2tpbGxzQ2xlYXJSYW5nZUlFKHBfcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ3X2llU3BlY2lmaWNDYWxsVG9TZXRIaWdobGlnaHQocF9yYW5nZSwgcF9zdHJDb2xvdXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeyAvLyBTRkZcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q2FyZXQgPSBwX3JhbmdlLnN0YXJ0Q2FyZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRDYXJldCA9IHBfcmFuZ2UuZW5kQ2FyZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJ3X3NldEhpZ2hsaWdodChzdGFydENhcmV0Lm5vZGUsIHN0YXJ0Q2FyZXQub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ2FyZXQubm9kZSwgZW5kQ2FyZXQub2Zmc2V0LCBwX3N0ckNvbG91cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZ19hVGV4dFJhbmdlLnB1c2gocF9yYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nX2FIaWdobGlnaHRDb2xvdXIucHVzaChwX3N0ckNvbG91cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vY29sbGFwc2UgdGhlIHNlbGVjdGlvbiBhZnRlciB0aGUgaGlnaGxpZ2h0XG4gICAgICAgICAgICBzc2RvbS5yd19jb2xsYXBzZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICBpZihiRGlzcGxheUlzc3VlTWF0Y2gpXG4gICAgICAgICAgICB7ICAgLy9mb3IgSUUgaGFja1xuICAgICAgICAgICAgICAgIHRtcE5vZGUuc3R5bGUuZGlzcGxheSA9IHN0b3JlZERpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4YylcbiAgICAgICAge1xuICAgICAgICAgICAgLy9hbGVydChcIkVycm9yIGluIG1ldGhvZDogXCIgKyBleGMubmFtZSArIFwiIFwiICsgZXhjLm1lc3NhZ2UgKyBcIiBcIiArIGV4Yy5kZXNjcmlwdGlvbiArIFwiIFwiICsgZXhjLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLypEbyBoaWdobGlnaHRpbmcgZm9yIHN0dWR5IHNraWxscyovXG4gICAgcndfc2V0SGlnaGxpZ2h0KHBfc3RhcnROb2RlLCBwX3N0YXJ0T2Zmc2V0LCBwX2VuZE5vZGUsIHBfZW5kT2Zmc2V0LCBwX3N0ckNvbG91cilcbiAgICB7ICAgIC8vIEZvciBzYWZhcmkgYW5kIEZpcmVGb3hcbiAgICAgICAgdmFyIHJlc1N0YXJ0ID0gcF9zdGFydE5vZGU7XG4gICAgICAgIHZhciByZXNFbmQgPSBwX2VuZE5vZGU7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgZG9tTmF2ID0gbmV3IERvbU5hdmlnYXRpb24oKTtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGlmKHBfc3RhcnROb2RlLm5vZGVUeXBlICE9IDMpIGFsZXJ0KFwiYmFkIG5vZGUgc2VudCB0byByd19zZXRIaWdobGlnaHQhXCIpO1xuICAgICAgICAgICAgLy9pZihwX2VuZE5vZGUubm9kZVR5cGUgIT0gMykgYWxlcnQoXCJiYWQgbm9kZSBzZW50IHRvIHJ3X3NldEhpZ2hsaWdodCFcIik7XG4gICAgICAgICAgICAvLyBJZiBhbGwgaW4gb25lIG5vZGVcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBfZW5kTm9kZSA9PSBwX3N0YXJ0Tm9kZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJ3X3NldE5vZGVCYWNrZ3JvdW5kKHBfc3RhcnROb2RlLCBwX3N0YXJ0T2Zmc2V0LCBwX2VuZE9mZnNldCwgXCJzc1wiLCBwX3N0ckNvbG91cik7XG4gICAgICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRBc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgcmVzU3RhcnQgPSByZXN1bHQubm9kZTtcbiAgICAgICAgICAgICAgICByZXNFbmQgPSByZXN1bHQubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBmaXJzdCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKHBfc3RhcnRPZmZzZXQgPiAwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yd19zZXROb2RlQmFja2dyb3VuZChwX3N0YXJ0Tm9kZSwgcF9zdGFydE9mZnNldCwgcF9zdGFydE5vZGUubm9kZVZhbHVlLmxlbmd0aCwgXCJzc1wiLCBwX3N0ckNvbG91cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucndfc2V0Tm9kZUJhY2tncm91bmQocF9zdGFydE5vZGUsIC0xLCAtMSwgXCJzc1wiLCBwX3N0ckNvbG91cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc1N0YXJ0ID0gcmVzdWx0Lm5vZGU7XG5cbiAgICAgICAgICAgICAgICAvLyBsb29wIGZvbGxvd2luZyBub2Rlc1xuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gZG9tTmF2LmdldE5leHRUZXh0Tm9kZU5vSW1nKHJlc3VsdC5ub2RlLCBmYWxzZSwgcF9lbmROb2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodG1wTm9kZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcE5vZGUgPT0gcF9lbmROb2RlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJ3X3NldE5vZGVCYWNrZ3JvdW5kKHRtcE5vZGUsIDAsIHBfZW5kT2Zmc2V0LCBcInNzXCIsIHBfc3RyQ29sb3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcE5vZGUgPSByZXN1bHQubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc0VuZCA9IHRtcE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucndfc2V0Tm9kZUJhY2tncm91bmQodG1wTm9kZSwgLTEsIC0xLCBcInNzXCIsIHBfc3RyQ29sb3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcE5vZGUgPSByZXN1bHQubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNFbmQgPSB0bXBOb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgcmVzIGhlcmUgaW4gY2FzZSBtaXNzZXMgaGl0IG9uIGVuZCBub2RlIGFuZCBnZXQgbnVsbCBvbiBmb2xsb3dpbmcgY2FsbFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBhdCBsZWFzdCBnZXRzIGxhc3Qgbm9kZSB1c2VkIGluIHJldHVybiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdG1wTm9kZSA9IGRvbU5hdi5nZXROZXh0VGV4dE5vZGVOb0ltZyh0bXBOb2RlLCBmYWxzZSwgcF9lbmROb2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKXsvKmNvbnNvbGUubG9nKFwicndfc2V0SGlnaGxpZ2h0IGVycm9yOlwiICsgZXJyLm1lc3NhZ2UpOyovIH1cbiAgICAgICAgcmV0dXJuIHtzdGFydDogcmVzU3RhcnQsIGVuZDogcmVzRW5kfTtcbiAgICB9XG5cbiAgICAvLyBjYXNlcyB0byBoYW5kbGUgZm9yIEludGVybmV0IEV4cGxvcmVyXG5cbiAgICByd19pZVNwZWNpZmljQ2FsbFRvU2V0SGlnaGxpZ2h0KHBfcmFuZ2UsIHBfc3RyQ29sb3VyKVxuICAgIHtcbiAgICAgICAgaWYocF9zdHJDb2xvdXIgPT0gXCJzdHJpa2V0aHJvdWdoXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBfcmFuZ2UuZXhlY0NvbW1hbmQoXCJzdHJpa2V0aHJvdWdoXCIsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBfcmFuZ2UuZXhlY0NvbW1hbmQoXCJiYWNrY29sb3JcIiwgZmFsc2UsIHBfc3RyQ29sb3VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgc3R1ZHlTa2lsbHNDbGVhclJhbmdlSUUocF9yYW5nZSlcbiAgICB7XG4gICAgICAgIHBfcmFuZ2UuZXhlY0NvbW1hbmQoXCJiYWNrY29sb3JcIiwgZmFsc2UsIFwiY2xlYXJcIik7XG4gICAgICAgIGlmKCAoZ19uSWNvbnMgJiBzdHJpa2VfaWNvbikgPT0gc3RyaWtlX2ljb24gIClcbiAgICAgICAgeyAgIC8vIE9ubHkgZG8gdGhpcyBpcyBzdHJpa2UgaWNvbiBpcyBzcGVjaWZpY2FsbHkgYXNrZWQgZm9yIGFzIGRvaW5nIGZ1bGwgcmVtb3ZlZm9ybWF0IGV2ZXJ5IHRpbWUgY291bGQgY2F1c2UgaXNzdWVzXG4gICAgICAgICAgICBwX3JhbmdlLmV4ZWNDb21tYW5kKFwiUmVtb3ZlRm9ybWF0XCIsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qUmVtb3ZlIGhpZ2hsaWdodGluZyBmb3Igc3R1ZHkgc2tpbGxzLlxuICAgICAvLyBOb3Qgc3VwcG9ydGluZyBNYXRoTUwgaGVyZS5cbiAgICAgKi9cbiAgICByd19yZW1vdmVIaWdobGlnaHQocF9hcnIpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwX2FyciA9PSBudWxsIHx8ICEocF9hcnIgaW5zdGFuY2VvZiBBcnJheSkgfHwgcF9hcnIubGVuZ3RoID09IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBfYXJyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBwX2FycltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yd19jaGVja05vZGVJc0hpZ2hsaWdodGVkVGV4dCh0bXApKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhck5vZGUgPSB0bXAucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgICAgICAgICBpZih0bXAubmV4dFNpYmxpbmcgIT0gbnVsbCB8fCB0bXAucHJldmlvdXNTaWJsaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvLyBuZWVkIHRvIG1lcmdlIG9yIHRleHQgY291bGQgYmUgbG9zdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4dCA9IHNzZG9tLmFsbFRleHRGcm9tTm9kZVRIKHBhck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHBhck5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0eHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2hlclBhcmVudE5vZGUgPSBwYXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hlclBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRtcCwgcGFyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vaGlnaGVyUGFyZW50Tm9kZS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gc3Nkb20ubWVyZ2VUZXh0Tm9kZXModG1wKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBwdXQgYmFjayBpbiBpbmNhc2UgdXNlZCBmb3Igc3BlZWNoIHJlbW92YWxcbiAgICAgICAgICAgICAgICAgICAgcF9hcnJbaV0gPSB0bXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXBGb250ID0gdGhpcy5yd19nZXROZXN0ZWROb2RlRm9ySGlnaGxpZ2h0ZWRUZXh0KHRtcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRtcEZvbnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnJ3X3JlbW92ZUF0dHJpYnV0ZSh0bXBGb250LCBcInJ3c3RhdGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBGb250LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBub3Qgc3BlYWtpbmcsIGNoZWNrIHNhbWUgcmFuZ2UgZm9yIHNwZWVjaCBoaWdobGlnaHRpbmdcbiAgICAgICAgICAgIC8vIGZvciByYXJlIGNhc2Ugb2YgaGlnaGxpZ2h0aW5nIG5vdCBiZWluZyByZW1vdmVkLCB0aGlzIGdpdmVzIG1lYW5zIHRvIHJlbW92ZSBpdFxuLy8gICAgICAgICAgICB0b2RvIGlzIHRoaXMgbmVlZGVkIGlmKCFTU0RBVC5jb250cm9sRGF0YS5iU3BlYWtpbmdGbGFnKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICByd19yZW1vdmVTcGVlY2hIaWdobGlnaHQocF9hcnIsIGZhbHNlKTtcbi8vICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKXsvKmNvbnNvbGUubG9nKFwiRXJyb3IgaW4gcndfc2V0SGlnaGxpZ2h0OiBcIiArIGVyci5tZXNzYWdlKTsqL31cbiAgICB9XG5cbiAgICAvKlVzZWQgYnkgcndfcmVtb3ZlSGlnaGxpZ2h0IHRvIGNoZWNrIGlmIHZhbGlkIG5vZGUgdG8gcHJvY2Vzcy4qL1xuICAgIHJ3X2dldE5lc3RlZE5vZGVGb3JIaWdobGlnaHRlZFRleHQocF9ub2RlKVxuICAgIHtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKCk7XG4gICAgICAgIGlmIChwX25vZGUubm9kZVR5cGUgIT0gMyB8fCBwX25vZGUucGFyZW50Tm9kZSA9PSBudWxsIHx8IHBfbm9kZS5wYXJlbnROb2RlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyVGFnID0gQ29uc3RhbnRzLkhJR0hMSUdIVF9UQUc7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHBfbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocGFyZW50LCBcInJ3c3RhdGVcIik7XG5cbiAgICAgICAgaWYocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPSBzdHJUYWcgfHwgYXR0ciA9PSBudWxsIHx8IGF0dHIgIT0gXCJzc1wiKVxuICAgICAgICB7ICAgLy8gY2hlY2sgaWYgbm9kZSBhZGRlZCBpbnNpZGUgYSBoaWdobGlnaHRcbiAgICAgICAgICAgIGlmKGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUocGFyZW50LCBcInJ3dGhnZW5cIikgIT0gbnVsbClcbiAgICAgICAgICAgIHsgICAvLyBtYXkgYmUgaW4gbmVzdGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgdG1wRWxlbSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBhdHRyID0gXCIxXCI7XG5cbiAgICAgICAgICAgICAgICB3aGlsZShhdHRyICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0bXBFbGVtID0gdG1wRWxlbS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUodG1wRWxlbSwgXCJyd1N0YXRlXCIpID09IFwic3NcIiAmJiB0bXBFbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBzdHJUYWcpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXBFbGVtO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUodG1wRWxlbSwgXCJyd3RoZ2VuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIC8qVXNlZCBieSByd19yZW1vdmVIaWdobGlnaHQgdG8gY2hlY2sgaWYgdmFsaWQgbm9kZSB0byBwcm9jZXNzLlxuICAgICAqIEFsbG93IHRvIGNoZWNrIHR5cGUgMSBhbmQgMywgYXMgd2l0aCB0aW55bWNlIGNvdWxkIGhhdmUgaGlnaGxpZ2h0IHNwYW4gdGhlbiAmbHQ7YiZndDsgdGhlbiB0ZXh0LiAgKi9cbiAgICByd19jaGVja05vZGVJc0hpZ2hsaWdodGVkVGV4dChwX25vZGUpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgaWYocF9ub2RlLnBhcmVudE5vZGUgPT0gbnVsbCB8fCBwX25vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnQgPSBwX25vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHBhcmVudCwgXCJyd3N0YXRlXCIpO1xuXG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIFJlZHVuZGFudElmU3RhdGVtZW50SlNcbiAgICAgICAgLy90b2RvIGZpeFxuICAgICAgICBpZihwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9Q29uc3RhbnRzLkhJR0hMSUdIVF9UQUcgfHwgYXR0ciA9PSBudWxsIHx8IGF0dHIgPT0gXCJjc3BcIiB8fCBhdHRyID09IFwic3BcIilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5jbGFzc05hbWUgPT0gXCJ0aHNwZWxsXCIgfHwgcGFyZW50LmNsYXNzTmFtZSA9PSBcInRoaG9tXCIvKlNwZWVjaFN0cmVhbS5oaWdobGlnaHRlci5nZXRIb21DbGFzcygpKi8gfHwgcGFyZW50LmNsYXNzTmFtZSA9PSBcInRoZ3JhbW1hclwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLypDaGVjayB0aGF0IGEgVEhEb21SYW5nZSBpcyBhIHZhbGlkIGhpZ2hsaWdodCByYW5nZSovXG4gICAgcndfY2hlY2tUSFJhbmdlRm9yVmFsaWRIaWdobGlnaHQocF9yYW5nZSlcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgZG9tTmF2ID0gbmV3IERvbU5hdmlnYXRpb24oKTtcbiAgICAgICAgdmFyIHN0YXJ0Q2FyZXQgPSBwX3JhbmdlLnN0YXJ0Q2FyZXQ7XG4gICAgICAgIHZhciBlbmRDYXJldCA9IHBfcmFuZ2UuZW5kQ2FyZXQ7XG5cbiAgICAgICAgdmFyIGJDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYoc3Nkb20uaXNJbnZhbGlkTm9kZShzdGFydENhcmV0Lm5vZGUpKVxuICAgICAgICB7ICAgLy8gY2Fubm90IGhpZ2hsaWdodCBpbiBpbnZhbGlkIGFyZWEuICBOb3Qgd29ydGggZWZmb3J0IHRvIG1ha2UgaXQgbW92ZSBzdGFydCB0byBub24gaW52YWxpZCBhcmVhLlxuICAgICAgICAgICAgaWYoc3RhcnRDYXJldC5ub2RlICE9IGVuZENhcmV0Lm5vZGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSBkb21OYXYuZ2V0TmV4dFRleHROb2RlTm9JbWcoc3RhcnRDYXJldC5ub2RlLCBmYWxzZSAsZW5kQ2FyZXQubm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmKHRtcE5vZGUgIT0gbnVsbCAmJiAhc3Nkb20uaXNJbnZhbGlkTm9kZSh0bXBOb2RlKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2FyZXQubm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2FyZXQub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgd29ydGggZWZmb3J0IHRvIG1ha2UgaXQgbW92ZSBzdGFydCB0byBub24gaW52YWxpZCBhcmVhLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiRmFpbCA9IHN0YXJ0Q2FyZXQubm9kZS5ub2RlVHlwZSAhPSAzIHx8XG4gICAgICAgICAgICAoc3RhcnRDYXJldC5ub2RlLm5vZGVUeXBlID09IDMgJiZcbiAgICAgICAgICAgICAgICBzdGFydENhcmV0Lm5vZGUubm9kZVZhbHVlLnRyaW1USCgpLmxlbmd0aCA9PSAwKTtcblxuICAgICAgICBpZihiRmFpbClcbiAgICAgICAge1xuICAgICAgICAgICAgYkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUoYkZhaWwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoc3RhcnRDYXJldC5ub2RlID09IGVuZENhcmV0Lm5vZGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBwb2ludCBtb3Zpbmcgc3RhcnQgcG9pbnQgYXMgd291bGQgbW92ZSBiZXlvbmQgZW5kIHNvIG5vIHZhbGlkIGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGFydENhcmV0Lm5vZGUgPSBkb21OYXYuZ2V0TmV4dFRleHROb2RlTm9CbGFuayhzdGFydENhcmV0Lm5vZGUsIGZhbHNlLCBlbmRDYXJldC5ub2RlKTtcblxuICAgICAgICAgICAgICAgIGlmKHN0YXJ0Q2FyZXQubm9kZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYkZhaWwgPSBzdGFydENhcmV0Lm5vZGUubm9kZVR5cGUgIT0gMyB8fFxuICAgICAgICAgICAgICAgICAgICAoc3RhcnRDYXJldC5ub2RlLm5vZGVUeXBlID09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q2FyZXQubm9kZS5ub2RlVmFsdWUudHJpbVRIKCkubGVuZ3RoID09IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGFydENhcmV0Lm9mZnNldCA9IDA7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmKHNzZG9tLmlzSW52YWxpZE5vZGUoZW5kQ2FyZXQubm9kZSkpXG4gICAgICAgIHsgICAvLyBjYW5ub3QgaGlnaGxpZ2h0IGluIGludmFsaWQgYXJlYS5cbiAgICAgICAgICAgIGlmKHN0YXJ0Q2FyZXQubm9kZSAhPSBlbmRDYXJldC5ub2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gZG9tTmF2LmdldFByZXZpb3VzVGV4dE5vZGVOb0ltZyhlbmRDYXJldC5ub2RlLCBmYWxzZSAsc3RhcnRDYXJldC5ub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYodG1wTm9kZSAhPSBudWxsICYmICFzc2RvbS5pc0ludmFsaWROb2RlKHRtcE5vZGUpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ2FyZXQubm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGVuZENhcmV0Lm9mZnNldCA9IHRtcE5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgd29ydGggZWZmb3J0IHRvIG1ha2UgaXQgbW92ZSBzdGFydCB0byBub24gaW52YWxpZCBhcmVhLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJGYWlsID0gZW5kQ2FyZXQubm9kZS5ub2RlVHlwZSAhPSAzIHx8XG4gICAgICAgICAgICAoZW5kQ2FyZXQubm9kZS5ub2RlVHlwZSA9PSAzICYmXG4gICAgICAgICAgICAgICAgZW5kQ2FyZXQubm9kZS5ub2RlVmFsdWUudHJpbVRIKCkubGVuZ3RoID09IDApO1xuXG4gICAgICAgIGlmKGJGYWlsKVxuICAgICAgICB7XG4gICAgICAgICAgICBiQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZShiRmFpbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihzdGFydENhcmV0Lm5vZGUgPT0gZW5kQ2FyZXQubm9kZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHBvaW50IG1vdmluZyBlbmQgcG9pbnQgYXMgd291bGQgbW92ZSBiZWZvcmUgc3RhcnQgc28gbm8gdmFsaWQgaGlnaGxpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVuZENhcmV0Lm5vZGUgPSBkb21OYXYuZ2V0UHJldmlvdXNUZXh0Tm9kZU5vSW1nKGVuZENhcmV0Lm5vZGUsIGZhbHNlLCBzdGFydENhcmV0Lm5vZGUsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGlmKGVuZENhcmV0Lm5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJGYWlsID0gZW5kQ2FyZXQubm9kZS5ub2RlVHlwZSAhPSAzIHx8XG4gICAgICAgICAgICAgICAgICAgIChlbmRDYXJldC5ub2RlLm5vZGVUeXBlID09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZENhcmV0Lm5vZGUubm9kZVZhbHVlLnRyaW1USCgpLmxlbmd0aCA9PSAwKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihlbmRDYXJldC5ub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZW5kQ2FyZXQub2Zmc2V0ID0gZW5kQ2FyZXQubm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoc3RhcnRDYXJldC5ub2RlID09IG51bGwgfHwgZW5kQ2FyZXQubm9kZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGJDaGFuZ2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICBwX3JhbmdlID0gbmV3IFRIRG9tUmFuZ2Uoc3RhcnRDYXJldC5ub2RlLCBzdGFydENhcmV0Lm9mZnNldCwgZW5kQ2FyZXQubm9kZSwgZW5kQ2FyZXQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcF9yYW5nZTtcbiAgICB9XG5cbiAgICAvLyohXG4gICAgLypDbGVhcnMgdGhlIHNlbGVjdGlvbiBvZiBoaWdobGlnaHRzIGFkZGVkIGJ5IHRoZSBzdHVkeSBza2lsbHNcbiAgICAgKiBwYXJhbSBwX2JGb3JjZUNsZWFyIC0gaWYgdHJ1ZSBjbGVhciBhbGwgYXMgaWYgaGFkIG5vIHNlbGVjdGlvbiBhbmQgbm8gYWxlcnQuKi9cbiAgICBzdHVkeVNraWxsc0NsZWFySGlnaGxpZ2h0cyhwX2JGb3JjZUNsZWFyLHNlbE9iailcbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHNlbFdpbmRvdyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2VsT2JqICE9IG51bGwgJiYgc2VsT2JqLnJhbmdlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UgPSBzZWxPYmoucmFuZ2U7XG4gICAgICAgICAgICAgICAgc2VsV2luZG93ID0gc2VsT2JqLmZyYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc2VsZWN0aW9uUmFuZ2UgIT0gbnVsbCAmJiBzZWxlY3Rpb25SYW5nZSBpbnN0YW5jZW9mIFN0cmluZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gaW4gYSB0ZXh0IGZpZWxkLCB3b250IGJlIGhpZ2hsaWdodGVkIGFuZCBkb250IG5lY2Vzc2FyaWx5XG4gICAgICAgICAgICAgICAgLy8gd2FudCB0byByZW1vdmUgYWxsIGZyb20gaGVyZSBzbyByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgcmVtb3ZlIHRoZSBzZWxlY3Rpb24gc28gc3Vic2VxdWVudCBwcmVzcyB3aWxsIGNsZWFyIGFsbFxuICAgICAgICAgICAgICAgIHZhciBnX2xhc3RJbnB1dFNlbGVjdFNGRiA9ZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoZ19sYXN0SW5wdXRTZWxlY3RTRkYgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGdfbGFzdElucHV0U2VsZWN0U0ZGLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZ19sYXN0SW5wdXRTZWxlY3RTRkYuc2VsZWN0aW9uRW5kID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ19sYXN0SW5wdXRTZWxlY3RTRkYgPSBudWxsO1xuXG5cbiAgICAgICAgICAgICAgICBpZihwX2JGb3JjZUNsZWFyKVxuICAgICAgICAgICAgICAgIHsgICAvLyBkb24ndCByZXR1cm4gY29udGludWUgdG8gY2xlYXIgYWxsIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0clRtcCA9IFwiUmVtb3ZlIGFsbCBoaWdobGlnaHRzP1wiO1xuXG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gZG8gYnJvd3NlciBkZXRlY3Rpb24gcmF0aGVyIHRoYW4gb2JqZWN0IGRldGVjdGlvbiwgYXMgb2JqZWN0IGV4aXN0cyBpbiBJRSA4IGFuZCBJRSA5IGJ1dCBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vIGJlaGF2aW91ciByZXF1aXJlZC5cbiAgICAgICAgICAgIHZhciBnX2JJRU9sZD1mYWxzZTtcbiAgICAgICAgICAgIGlmIChnX2JJRU9sZClcbiAgICAgICAgICAgIHsgIC8vIElFXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblJhbmdlID09IG51bGwgfHwgc2VsZWN0aW9uUmFuZ2UubGVuZ3RoID09IDAgfHwgc2VsZWN0aW9uUmFuZ2UudGV4dC5sZW5ndGggPT0gMCB8fCBwX2JGb3JjZUNsZWFyKVxuICAgICAgICAgICAgICAgIHsgICAvLyBubyBzZWxlY3Rpb24gcmVtb3ZlIGFsbFxuICAgICAgICAgICAgICAgICAgICBpZighcF9iRm9yY2VDbGVhcilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFncmVlID0gZmFsc2U7Ly9jb25maXJtKHN0clRtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighYWdyZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbi8vICAgICAgICAgICAgICAgICAgICB0b2RvIGlmKGdfYlBlcnNpc3RBbm5vdGF0aW9ucylcbi8vICAgICAgICAgICAgICAgICAgICB7ICAgLy8gYWRkZWQgYXMgaWYgcGVyc2lzdGluZyBidXQgd2FudCB0byBjbGVhciBoaWdobGlnaHRzIHRvIHJlZnJlc2ggdHVybiBwZXJzaXN0ZW5jZSBvZmZcbi8vICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBhbGxvd3MgdGhpcyBkYXRhIHRvIG5vdCBiZSBsb3N0IGFzIHdlbGwgYXMgbm90IHNlbmRpbmcgYmFkIGRhdGEuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGdfc3RyU3RvcmVkSGlnaGxpZ2h0RGF0YSA9IG51bGw7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGdfc3RyU3RvcmVkSGlnaGxpZ2h0VW5wcm9jZXNzZWREYXRhID0gbnVsbDtcbi8vICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5MZW4gPSB0aGlzLmdfYVRleHRSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdCBvZiBiZWx0cyBhbmQgYnJhY2VzIGFwcHJvYWNoXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlSYW5nZUluZGV4ID0gMDsgaVJhbmdlSW5kZXggPCBuTGVuOyBpUmFuZ2VJbmRleCsrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdfYVRleHRSYW5nZVtpUmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0dWR5U2tpbGxzQ2xlYXJSYW5nZUlFKHJhbmdlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nX2FUZXh0UmFuZ2VbaVJhbmdlSW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyW2lSYW5nZUluZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdfYVRleHRSYW5nZSA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdfYUhpZ2hsaWdodENvbG91ciA9IG5ldyBBcnJheSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCFkb2N1bWVudC5jb21wYXRNb2RlLmVxdWFsc1RIKFwiQ1NTMUNvbXBhdFwiKSlcbiAgICAgICAgICAgICAgICAgICAgeyAgIC8vIHRoaXMgZG9lcyBub3Qgd29yayBpbiBub24gc3RyaWN0IG1vZGUsIGlzIGp1c3QgYW4gZXh0cmEgc2FmZSBjYXRjaCBhbGwgcmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBub3QgZXNzZW50aWFsLCBpZiBzaXRlIHdhbnRzIHRvIGZvcmNlIGEgbGVzcyBzdGFibGUgbW9kZSwgaXQgd2lsbCBiZSBsZXNzIHN0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyB3ZSBjYW4gZG8gYWJvdXQgaXRcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgc2VsZWN0aW9uIGluc2lkZSBhIGZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ19iSWdub3JlRnJhbWVzPWZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWdfYklnbm9yZUZyYW1lcyAmJiB0b3AuZnJhbWVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuTGVuRnJhbWVzID0gdG9wLmZyYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5MZW5GcmFtZXM7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wRnJhbWUgPSB0b3AuZnJhbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UgPSB0bXBGcmFtZS5kb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlLmV4cGFuZChcInRleHRlZGl0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHVkeVNraWxsc0NsZWFyUmFuZ2VJRShzZWxlY3Rpb25SYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhbWVzIGV4aXN0IHdpdGggZGlmZmVyZW50IGRvbWFpbiBzbyBjYW5ub3QgYWNjZXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UuZXhwYW5kKFwidGV4dGVkaXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHVkeVNraWxsc0NsZWFyUmFuZ2VJRShzZWxlY3Rpb25SYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgICAgICAgIHRvZG8gaWYoZ19iUGVyc2lzdEFubm90YXRpb25zICYmIGdfYlBlcnNpc3RIaWdobGlnaHRzICYmXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZihyd19zdG9yZUhpZ2hsaWdodERhdGEpICE9IFwidW5kZWZpbmVkXCIpXG4vLyAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGNhbGwgaWYgcGt0IHdpdGggc3R1ZGVudCBpZCBnaXZlbiBhbmQgbm90IGEgdGVhY2hlclxuLy8gICAgICAgICAgICAgICAgICAgICAgICByd19zdG9yZUhpZ2hsaWdodERhdGEoKTtcbi8vICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0dWR5U2tpbGxzQ2xlYXJSYW5nZUlFKHNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0dWR5U2tpbGxzSFRNTFJlZnJlc2hSYW5nZXMoKTtcblxuICAgICAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggZWFjaCBpdGVtLCBpZiBzdGFydCBvciBlbmQgb2YgaXQgaXMgaW4gcmFuZ2UgdGhlbiByZW1vdmUgaXRcblxuICAgICAgICAgICAgICAgIHZhciBuTGVuID0gdGhpcy5nX2FUZXh0UmFuZ2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBpUmFuZ2VJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHRtcFJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgZHVwUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAoaVJhbmdlSW5kZXggPSAwOyBpUmFuZ2VJbmRleCA8IG5MZW47IGlSYW5nZUluZGV4KyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0bXBSYW5nZSA9IHRoaXMuZ19hVGV4dFJhbmdlW2lSYW5nZUluZGV4XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodG1wUmFuZ2UgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGZ1bGwgcmFuZ2UgaW4gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uUmFuZ2UuaW5SYW5nZSh0bXBSYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wUmFuZ2UgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nX2FUZXh0UmFuZ2Uuc3BsaWNlKGlSYW5nZUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdfYUhpZ2hsaWdodENvbG91ci5zcGxpY2UoaVJhbmdlSW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVJhbmdlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHN0YXJ0IGluIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgZHVwUmFuZ2UgPSB0bXBSYW5nZS5kdXBsaWNhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cFJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblJhbmdlLmluUmFuZ2UoZHVwUmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZWRSYW5nZVBvc3QgPSB0bXBSYW5nZS5kdXBsaWNhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRSYW5nZVBvc3QuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdG9yZWRSYW5nZVBvc3QuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgc2VsZWN0aW9uUmFuZ2UpID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFJhbmdlUG9zdC5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0dWR5U2tpbGxzQ2xlYXJSYW5nZUlFKHRoaXMuZ19hVGV4dFJhbmdlW2lSYW5nZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nX2FUZXh0UmFuZ2VbaVJhbmdlSW5kZXhdID0gc3RvcmVkUmFuZ2VQb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucndfaWVTcGVjaWZpY0NhbGxUb1NldEhpZ2hsaWdodCh0aGlzLmdfYVRleHRSYW5nZVtpUmFuZ2VJbmRleF0sIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyW2lSYW5nZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVuZCBpbiBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBSYW5nZSA9IHRtcFJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cFJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uUmFuZ2UuaW5SYW5nZShkdXBSYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVkUmFuZ2VQcmUgPSB0bXBSYW5nZS5kdXBsaWNhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUmFuZ2VQcmUuY29sbGFwc2UodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0b3JlZFJhbmdlUHJlLmNvbXBhcmVFbmRQb2ludHMoXCJFbmRUb1N0YXJ0XCIsIHNlbGVjdGlvblJhbmdlKSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFJhbmdlUHJlLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHVkeVNraWxsc0NsZWFyUmFuZ2VJRSh0aGlzLmdfYVRleHRSYW5nZVtpUmFuZ2VJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdfYVRleHRSYW5nZVtpUmFuZ2VJbmRleF0gPSBzdG9yZWRSYW5nZVByZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yd19pZVNwZWNpZmljQ2FsbFRvU2V0SGlnaGxpZ2h0KHRoaXMuZ19hVGV4dFJhbmdlW2lSYW5nZUluZGV4XSwgdGhpcy5nX2FIaWdobGlnaHRDb2xvdXJbaVJhbmdlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHNlbGVjdGlvbiBpbiByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcFJhbmdlLmluUmFuZ2Uoc2VsZWN0aW9uUmFuZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0dWR5U2tpbGxzQ2xlYXJSYW5nZUlFKHRtcFJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVkUmFuZ2VQcmUgPSB0bXBSYW5nZS5kdXBsaWNhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmVkUmFuZ2VQb3N0ID0gdG1wUmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUmFuZ2VQcmUuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUmFuZ2VQb3N0LmNvbGxhcHNlKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdG9yZWRSYW5nZVByZS5jb21wYXJlRW5kUG9pbnRzKFwiRW5kVG9TdGFydFwiLCBzZWxlY3Rpb25SYW5nZSkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUmFuZ2VQcmUubW92ZUVuZChcImNoYXJhY3RlclwiLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RvcmVkUmFuZ2VQb3N0LmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHNlbGVjdGlvblJhbmdlKSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRSYW5nZVBvc3QubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0dWR5U2tpbGxzQ2xlYXJSYW5nZUlFKHRoaXMuZ19hVGV4dFJhbmdlW2lSYW5nZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nX2FUZXh0UmFuZ2VbaVJhbmdlSW5kZXhdID0gc3RvcmVkUmFuZ2VQcmU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdfYVRleHRSYW5nZS5wdXNoKHN0b3JlZFJhbmdlUG9zdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nX2FIaWdobGlnaHRDb2xvdXIucHVzaCh0aGlzLmdfYUhpZ2hsaWdodENvbG91cltpUmFuZ2VJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yd19pZVNwZWNpZmljQ2FsbFRvU2V0SGlnaGxpZ2h0KHN0b3JlZFJhbmdlUHJlLCB0aGlzLmdfYUhpZ2hsaWdodENvbG91cltpUmFuZ2VJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucndfaWVTcGVjaWZpY0NhbGxUb1NldEhpZ2hsaWdodChzdG9yZWRSYW5nZVBvc3QsIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyW2lSYW5nZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZS5leGVjQ29tbWFuZChcIlVuU2VsZWN0XCIsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHsgIC8vIHNhZmFyaSBmaXJlZm94XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblJhbmdlID09IG51bGwgfHwgcF9iRm9yY2VDbGVhcilcbiAgICAgICAgICAgICAgICB7ICAgLy8gcmVtb3ZlIGFsbCBoaWdobGlnaHRpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYoIXBfYkZvcmNlQ2xlYXIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZ3JlZSA9IGZhbHNlOy8vY29uZmlybShzdHJUbXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWFncmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgICAgICAgICAgdG9kbyBpZihnX2JQZXJzaXN0QW5ub3RhdGlvbnMpXG4vLyAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGFkZGVkIGFzIGlmIHBlcnNpc3RpbmcgYnV0IHdhbnQgdG8gY2xlYXIgaGlnaGxpZ2h0cyB0byByZWZyZXNoIHR1cm4gcGVyc2lzdGVuY2Ugb2ZmXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYWxsb3dzIHRoaXMgZGF0YSB0byBub3QgYmUgbG9zdCBhcyB3ZWxsIGFzIG5vdCBzZW5kaW5nIGJhZCBkYXRhLlxuLy8gICAgICAgICAgICAgICAgICAgICAgICBnX3N0clN0b3JlZEhpZ2hsaWdodERhdGEgPSBudWxsO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICBnX3N0clN0b3JlZEhpZ2hsaWdodFVucHJvY2Vzc2VkRGF0YSA9IG51bGw7XG4vLyAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtc1RvUmVtb3ZlID0gdGhpcy5nX2FUZXh0UmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ19hVGV4dFJhbmdlID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zVG9SZW1vdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBSYW5nZSA9IGl0ZW1zVG9SZW1vdmVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBSYW5nZS5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RvZG8gbW92ZSBnZXRMaXN0T2ZIaWdobGlnaHRhYmxlTm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucndfcmVtb3ZlSGlnaGxpZ2h0KHRoaXMuZ2V0TGlzdE9mSGlnaGxpZ2h0YWJsZU5vZGVzKHRtcFJhbmdlLnN0YXJ0Q2FyZXQsIHRtcFJhbmdlLmVuZENhcmV0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHsgICAvL3NlbGVjdGlvblJhbmdlIGlzIGEgVEhEb21SYW5nZSwgcmVmcmVzaCBiZWZvcmUgdXNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaVJhbmdlSW5kZXggPSAwOyBpUmFuZ2VJbmRleCA8IHRoaXMuZ19hVGV4dFJhbmdlLmxlbmd0aDsgaVJhbmdlSW5kZXgrKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayB0aGF0IG91ciB0ZXh0IHJhbmdlcyBmcm9tIHRoZSBzdG9yZWQgdG8gdGhlIHNlbGVjdGlvbiBkbyBub3QgY29uZmxpY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhleSByZWxhdGUgdG8gdGhlIHNhbWUgYm9keSAoaW4gY2FzZSBvZiBpZnJhbWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcERvbVJhbmdlID0gdGhpcy5nX2FUZXh0UmFuZ2VbaVJhbmdlSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzZWxlY3Rpb25SYW5nZS5ib2R5ICE9IHRtcERvbVJhbmdlLmJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gY2Fubm90IG92ZXJsYXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuUmVzdWx0ID0gc2VsZWN0aW9uUmFuZ2UuY29tcGFyZVJhbmdlKHRtcERvbVJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG5SZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuVEhEb21SYW5nZV9FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnN0YXR1cyA9IFwiRXJyb3Igb2NjdXJyZWQgd2hlbiB0cnlpbmcgdG8gcmVtb3ZlIGEgaGlnaGxpZ2h0LlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5USERvbVJhbmdlX1RBUkdFVF9TQU1FOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLlRIRG9tUmFuZ2VfVEFSR0VUX0lOU0lERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IHNlbGVjdGlvbiBjb250YWlucyBhbiBleGlzdGluZyByYW5nZSBlbnRpcmVseSwgcmVtb3ZlIGV4aXN0aW5nXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wRG9tUmFuZ2UucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ3X3JlbW92ZUhpZ2hsaWdodCh0aGlzLmdldExpc3RPZkhpZ2hsaWdodGFibGVOb2Rlcyh0bXBEb21SYW5nZS5zdGFydENhcmV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wRG9tUmFuZ2UuZW5kQ2FyZXQpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdfYVRleHRSYW5nZS5zcGxpY2UoaVJhbmdlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdfYUhpZ2hsaWdodENvbG91ci5zcGxpY2UoaVJhbmdlSW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taVJhbmdlSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzLlRIRG9tUmFuZ2VfVEFSR0VUX0lOQ0xVREVTX1RISVM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuVEhEb21SYW5nZV9UQVJHRVRfSU5DTFVERVNfVEhJU19BVF9TVEFSVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5USERvbVJhbmdlX1RBUkdFVF9JTkNMVURFU19USElTX0FUX0VORDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IHNlbGVjdGlvbiBlbnRpcmVseSBpbnNpZGUgYW4gZXhpc3RpbmcgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXNlMVNGRihpUmFuZ2VJbmRleCwgc2VsZWN0aW9uUmFuZ2UsIG5SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2lSYW5nZUluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5USERvbVJhbmdlX09WRVJMQVBTX1NUQVJUX09GX1RBUkdFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3IHNlbGVjdGlvbiBiZWZvcmUgYW5kIGVuZHMgaW4gYW4gZXhpc3RpbmcgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXNlMlNGRihpUmFuZ2VJbmRleCwgc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5USERvbVJhbmdlX09WRVJMQVBTX0VORF9PRl9UQVJHRVQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBzZWxlY3Rpb24gc3RhcnRzIGluIGFuZCBlbmRzIGFmdGVyIGFuIGV4aXN0aW5nIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FzZTNTRkYoaVJhbmdlSW5kZXgsIHNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50cy5USERvbVJhbmdlX0FGVEVSX1RBUkdFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb25zdGFudHMuVEhEb21SYW5nZV9CRUZPUkVfVEFSR0VUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDovL2RvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNzZG9tLnJ3X2NvbGxhcHNlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbi8vICAgICAgICAgICAgdG9kbyBpZihnX2JQZXJzaXN0QW5ub3RhdGlvbnMgJiYgZ19iUGVyc2lzdEhpZ2hsaWdodHMgJiZcbi8vICAgICAgICAgICAgICAgIHR5cGVvZihyd19zdG9yZUhpZ2hsaWdodERhdGEpICE9IFwidW5kZWZpbmVkXCIpXG4vLyAgICAgICAgICAgIHsgICAvLyBjYWxsIGlmIHBrdCB3aXRoIHN0dWRlbnQgaWQgZ2l2ZW4gYW5kIG5vdCBhIHRlYWNoZXJcbi8vICAgICAgICAgICAgICAgIHJ3X3N0b3JlSGlnaGxpZ2h0RGF0YSgpO1xuLy8gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGp1c3QgaW4gY2FzZSBoYXZlIGNvbGxlY3Qgc2NyZWVuIG9wZW4gYXMgdGhpcyB3b3VsZCBjb250aW51ZSB0byBzaG93IGhpZ2hsaWdodHMuXG4vLyAgICAgICAgICAgIGlmKGdfYWJWaXNpYmxlW1BPUFVQX0NPTExFQ1RdKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAkcndfZGl2UHJlc3MoUE9QVVBfQ09MTEVDVCk7XG4vLyAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGV4YylcbiAgICAgICAge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkVycm9yIGluIG1ldGhvZDogXCIgKyBleGMubmFtZSArIFwiIFwiICsgZXhjLm1lc3NhZ2UgKyBcIiBcIiArIGV4Yy5kZXNjcmlwdGlvbiArIFwiIFwiICsgZXhjLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8qIVxuICAgIC8qIHJlZnJlc2ggYWxsIHRoZSB0ZXh0IHJhbmdlcyBzdG9yZWQgaW4gb3JkZXIgdG8ga2VlcCBvbmx5IHRob3NlXG4gICAgIHRoYXQgc3RpbGwgYXBwbHlcbiAgICAgbmVlZCB0byByZWZyZXNoIHRoZSBzdG9yZWQgdGV4dCByYW5nZXMgaWYgYSBuYXZpZ2F0aW9uXG4gICAgIG9jY3VycyBvciB0aGUgaW50ZXJuZXQgZXhwbG9yZXIgd2luZG93IGNsb3Nlc1xuICAgICBSZXR1cm5zIHRydWUgaWYgYW4gaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICovXG4gICAgc3R1ZHlTa2lsbHNIVE1MUmVmcmVzaFJhbmdlcygpXG4gICAge1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRlbXBUZXh0UmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGJsbkl0ZW1SZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaVJhbmdlSW5kZXggPSAwO1xuXG4gICAgICAgICAgICAvL2VudW1lcmF0ZSB0aGUgc3RydWN0dXJlIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IGRlYWQgcmVmZXJlbmNlc1xuICAgICAgICAgICAgZm9yIChpUmFuZ2VJbmRleCA9IDA7IGlSYW5nZUluZGV4IDwgdGhpcy5nX2FUZXh0UmFuZ2UubGVuZ3RoOyBpUmFuZ2VJbmRleCsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlbXBUZXh0UmFuZ2UgPSB0aGlzLmdfYVRleHRSYW5nZVtpUmFuZ2VJbmRleF07XG5cbiAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wVGV4dFJhbmdlLnRleHQgPT0gbnVsbCB8fCB0ZW1wVGV4dFJhbmdlLnRleHQgPT0gXCJcIilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9ubyByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFRleHRSYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2goZXhlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZ0UoZXhlKTtcbiAgICAgICAgICAgICAgICAgICAgLy90ZXh0cmFuZ2UgaGFzIGJlZW4gbG9zdFxuICAgICAgICAgICAgICAgICAgICB0ZW1wVGV4dFJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGVtcFRleHRSYW5nZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy90ZXh0cmFuZ2UgZGVhZCBzbyByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nX2FUZXh0UmFuZ2Uuc3BsaWNlKGlSYW5nZUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nX2FIaWdobGlnaHRDb2xvdXIuc3BsaWNlKGlSYW5nZUluZGV4LCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBibG5JdGVtUmVtb3ZlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy90YWtlIHN0ZXAgYmFjayBhbmQgZm9sbG93aW5nIGl0ZW1zIG1vdmVkIGRvd24gYSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaVJhbmdlSW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBibG5JdGVtUmVtb3ZlZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXhjKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVycm9yIGluIG1ldGhvZCBzdHVkeVNraWxsc0hUTUxSZWZyZXNoUmFuZ2VzOiBcIiArIGV4Yy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gc2VsZWN0aW9uIGVudGlyZWx5IGluc2lkZSByYW5nZVxuLy8gblBvcyB0aGUgcG9pbnQgaW4gdGhlIGdfYVRleHRSYW5nZSBhcnJheSB0aGF0IGNvbmZsaWN0c1xuLy8gc2VsZWN0aW9uUmFuZ2UgdGhlIG5ldyBzZWxlY3Rpb24gYmVpbmcgbWFkZSwgVEhEb21SYW5nZVxuICAgIGNhc2UxU0ZGKHBfblBvcywgcF9zZWxlY3Rpb25SYW5nZSwgcF90aERvbVJhbmdlVHlwZSlcbiAgICB7XG4gICAgICAgIC8vIHJlbW92ZSBlbnRpcmVseVxuICAgICAgICAvLyBhZGQgbmV3IGl0ZW1zIChvcmlnaW5hbCBiZWZvcmUsIG9yaWdpbmFsIGFmdGVyKSAgc2VsZWN0aW9uIGFkZGVkIGJ5IGNhbGxlclxuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgLy8gc3RvcmUgcG9zaXRpb25zIGJlZm9yZSBjaGFuZ2luZyBkb21cbiAgICAgICAgdmFyIHN0ck9yaWdDb2xvdXIgPSB0aGlzLmdfYUhpZ2hsaWdodENvbG91cltwX25Qb3NdO1xuICAgICAgICB2YXIgb3JpZ0RvbVJhbmdlID0gdGhpcy5nX2FUZXh0UmFuZ2VbcF9uUG9zXTtcbiAgICAgICAgb3JpZ0RvbVJhbmdlLnJlZnJlc2goKTtcbiAgICAgICAgdmFyIHN0YXJ0TGVmdFJlZlB0ID0gb3JpZ0RvbVJhbmdlLnN0YXJ0UmVmO1xuICAgICAgICB2YXIgZW5kTGVmdFJlZlB0ID0gcF9zZWxlY3Rpb25SYW5nZS5zdGFydFJlZjtcbiAgICAgICAgdmFyIHN0YXJ0UmlnaHRSZWZQdCA9IHBfc2VsZWN0aW9uUmFuZ2UuZW5kUmVmO1xuICAgICAgICB2YXIgZW5kUmlnaHRSZWZQdCA9IG9yaWdEb21SYW5nZS5lbmRSZWY7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGhpZ2hsaWdodGluZ1xuICAgICAgICB0aGlzLnJ3X3JlbW92ZUhpZ2hsaWdodCh0aGlzLmdldExpc3RPZkhpZ2hsaWdodGFibGVOb2RlcyhvcmlnRG9tUmFuZ2Uuc3RhcnRDYXJldCxcbiAgICAgICAgICAgIG9yaWdEb21SYW5nZS5lbmRDYXJldCkpO1xuICAgICAgICB0aGlzLmdfYVRleHRSYW5nZS5zcGxpY2UocF9uUG9zLCAxKTtcbiAgICAgICAgdGhpcy5nX2FIaWdobGlnaHRDb2xvdXIuc3BsaWNlKHBfblBvcywgMSk7XG5cbiAgICAgICAgLy8gIGFkZCB0aGUgc3BsaXQgaGlnaGxpZ2h0c1xuICAgICAgICAvLyBDaGVjayBpZiBib3VuZGFyeSBtYXRjaCBpbiB3aGljaCBjYXNlIG9ubHkgcmUtYWRkIG9uZVxuXG4gICAgICAgIHZhciBzdGFydENhcmV0O1xuICAgICAgICB2YXIgZW5kQ2FyZXQ7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB0bXBEb21SYW5nZTtcblxuICAgICAgICAvLyBpZiBzZWxlY3Rpb24gaXMgYXQgdGhlIHN0YXJ0IHRoZW4gbm90aGluZyB0byBhZGQgdG8gdGhlIGxlZnRcbiAgICAgICAgaWYocF90aERvbVJhbmdlVHlwZSAhPSBDb25zdGFudHMuVEhEb21SYW5nZV9UQVJHRVRfSU5DTFVERVNfVEhJU19BVF9TVEFSVClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gYWRkIGxlZnRcbiAgICAgICAgICAgIHZhciBjYXJldFJhbmdlID0gIG5ldyBUSENhcmV0UmFuZ2UocF9zZWxlY3Rpb25SYW5nZS5ib2R5LFxuICAgICAgICAgICAgICAgIHN0YXJ0TGVmdFJlZlB0LnBhdGgsIHN0YXJ0TGVmdFJlZlB0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICBlbmRMZWZ0UmVmUHQucGF0aCwgZW5kTGVmdFJlZlB0Lm9mZnNldCk7XG4gICAgICAgICAgICBzdGFydENhcmV0ID0gY2FyZXRSYW5nZS5sZWZ0Q2FyZXQ7XG4gICAgICAgICAgICBlbmRDYXJldCA9IGNhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yd19zZXRIaWdobGlnaHQoc3RhcnRDYXJldC5ub2RlLCBzdGFydENhcmV0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICBlbmRDYXJldC5ub2RlLCBlbmRDYXJldC5vZmZzZXQsIHN0ck9yaWdDb2xvdXIpO1xuXG4gICAgICAgICAgICB0bXBEb21SYW5nZSA9IG5ldyBUSERvbVJhbmdlKHJlc3VsdC5zdGFydCwgMCxcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kLCByZXN1bHQuZW5kLm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5nX2FUZXh0UmFuZ2UucHVzaCh0bXBEb21SYW5nZSk7XG4gICAgICAgICAgICB0aGlzLmdfYUhpZ2hsaWdodENvbG91ci5wdXNoKHN0ck9yaWdDb2xvdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgdGhlbiBub3RoaW5nIHRvIGFkZCB0byB0aGUgcmlnaHRcbiAgICAgICAgaWYocF90aERvbVJhbmdlVHlwZSAhPSBDb25zdGFudHMuVEhEb21SYW5nZV9UQVJHRVRfSU5DTFVERVNfVEhJU19BVF9FTkQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGFkZCByaWdodFxuICAgICAgICAgICAgY2FyZXRSYW5nZSA9ICBuZXcgVEhDYXJldFJhbmdlKHBfc2VsZWN0aW9uUmFuZ2UuYm9keSxcbiAgICAgICAgICAgICAgICBzdGFydFJpZ2h0UmVmUHQucGF0aCwgc3RhcnRSaWdodFJlZlB0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICBlbmRSaWdodFJlZlB0LnBhdGgsIGVuZFJpZ2h0UmVmUHQub2Zmc2V0KTtcbiAgICAgICAgICAgIHN0YXJ0Q2FyZXQgPSBjYXJldFJhbmdlLmxlZnRDYXJldDtcbiAgICAgICAgICAgIGVuZENhcmV0ID0gY2FyZXRSYW5nZS5yaWdodENhcmV0O1xuXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJ3X3NldEhpZ2hsaWdodChzdGFydENhcmV0Lm5vZGUsIHN0YXJ0Q2FyZXQub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVuZENhcmV0Lm5vZGUsIGVuZENhcmV0Lm9mZnNldCwgc3RyT3JpZ0NvbG91cik7XG5cbiAgICAgICAgICAgIHRtcERvbVJhbmdlID0gbmV3IFRIRG9tUmFuZ2UocmVzdWx0LnN0YXJ0LCAwLFxuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQsIHJlc3VsdC5lbmQubm9kZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmdfYVRleHRSYW5nZS5wdXNoKHRtcERvbVJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyLnB1c2goc3RyT3JpZ0NvbG91cik7XG4gICAgICAgIH1cbiAgICAgICAgcF9zZWxlY3Rpb25SYW5nZS5yZWZyZXNoKCk7XG4gICAgICAgIC8vIHRoZSBtaWRkbGUgZ2V0cyBhZGRlZCBieSBjYWxsZXIuXG4gICAgfVxuXG4vLyBzZWxlY3Rpb24gZW5kcyBpbiByYW5nZVxuICAgIGNhc2UyU0ZGKG5Qb3MsIHNlbGVjdGlvblJhbmdlKVxuICAgIHtcbiAgICAgICAgLy8gcmVtb3ZlIGVudGlyZWx5XG4gICAgICAgIC8vIGFkZCBuZXcgaXRlbSAob3JpZ2luYWwgYWZ0ZXIpICBzZWxlY3Rpb24gYWRkZWQgYnkgY2FsbGVyXG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICAvLyBzdG9yZSBwb3NpdGlvbnMgYmVmb3JlIGNoYW5naW5nIGRvbVxuICAgICAgICB2YXIgc3RyT3JpZ0NvbG91ciA9IHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyW25Qb3NdO1xuICAgICAgICB2YXIgb3JpZ0RvbVJhbmdlID0gdGhpcy5nX2FUZXh0UmFuZ2VbblBvc107XG4gICAgICAgIG9yaWdEb21SYW5nZS5yZWZyZXNoKCk7XG4gICAgICAgIHZhciBzdGFydFJpZ2h0UmVmUHQgPSBzZWxlY3Rpb25SYW5nZS5lbmRSZWY7XG4gICAgICAgIHZhciBlbmRSaWdodFJlZlB0ID0gb3JpZ0RvbVJhbmdlLmVuZFJlZjtcblxuICAgICAgICAvLyByZW1vdmUgaGlnaGxpZ2h0aW5nXG4gICAgICAgIHRoaXMucndfcmVtb3ZlSGlnaGxpZ2h0KHRoaXMuZ2V0TGlzdE9mSGlnaGxpZ2h0YWJsZU5vZGVzKG9yaWdEb21SYW5nZS5zdGFydENhcmV0LFxuICAgICAgICAgICAgb3JpZ0RvbVJhbmdlLmVuZENhcmV0KSk7XG4gICAgICAgIHRoaXMuZ19hVGV4dFJhbmdlLnNwbGljZShuUG9zLCAxKTtcbiAgICAgICAgdGhpcy5nX2FIaWdobGlnaHRDb2xvdXIuc3BsaWNlKG5Qb3MsIDEpO1xuXG4gICAgICAgIC8vICBhZGQgdGhlIHNwbGl0IGhpZ2hsaWdodHNcbiAgICAgICAgLy8gYWRkIHJpZ2h0XG4gICAgICAgIHZhciBjYXJldFJhbmdlID0gIG5ldyBUSENhcmV0UmFuZ2Uoc2VsZWN0aW9uUmFuZ2UuYm9keSxcbiAgICAgICAgICAgIHN0YXJ0UmlnaHRSZWZQdC5wYXRoLCBzdGFydFJpZ2h0UmVmUHQub2Zmc2V0LFxuICAgICAgICAgICAgZW5kUmlnaHRSZWZQdC5wYXRoLCBlbmRSaWdodFJlZlB0Lm9mZnNldCk7XG4gICAgICAgIHZhciBzdGFydENhcmV0ID0gY2FyZXRSYW5nZS5sZWZ0Q2FyZXQ7XG4gICAgICAgIHZhciBlbmRDYXJldCA9IGNhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yd19zZXRIaWdobGlnaHQoc3RhcnRDYXJldC5ub2RlLCBzdGFydENhcmV0Lm9mZnNldCxcbiAgICAgICAgICAgIGVuZENhcmV0Lm5vZGUsIGVuZENhcmV0Lm9mZnNldCwgc3RyT3JpZ0NvbG91cik7XG5cbiAgICAgICAgdmFyIHRtcERvbVJhbmdlID0gbmV3IFRIRG9tUmFuZ2UocmVzdWx0LnN0YXJ0LCAwLFxuICAgICAgICAgICAgcmVzdWx0LmVuZCwgcmVzdWx0LmVuZC5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5nX2FUZXh0UmFuZ2UucHVzaCh0bXBEb21SYW5nZSk7XG4gICAgICAgIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyLnB1c2goc3RyT3JpZ0NvbG91cik7XG5cbiAgICAgICAgc2VsZWN0aW9uUmFuZ2UucmVmcmVzaCgpO1xuICAgICAgICAvLyB0aGUgbWlkZGxlIGdldHMgYWRkZWQgYnkgY2FsbGVyLlxuICAgIH1cblxuICAgIC8vIHNlbGVjdGlvbiBzdGFydHMgaW4gcmFuZ2VcbiAgICBjYXNlM1NGRihuUG9zLCBzZWxlY3Rpb25SYW5nZSlcbiAgICB7XG4gICAgICAgIC8vIHJlbW92ZSBlbnRpcmVseVxuICAgICAgICAvLyBhZGQgbmV3IGl0ZW0gKG9yaWdpbmFsIGJlZm9yZSkgIHNlbGVjdGlvbiBhZGRlZCBieSBjYWxsZXJcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIC8vIHN0b3JlIHBvc2l0aW9ucyBiZWZvcmUgY2hhbmdpbmcgZG9tXG4gICAgICAgIHZhciBzdHJPcmlnQ29sb3VyID0gdGhpcy5nX2FIaWdobGlnaHRDb2xvdXJbblBvc107XG4gICAgICAgIHZhciBvcmlnRG9tUmFuZ2UgPSB0aGlzLmdfYVRleHRSYW5nZVtuUG9zXTtcbiAgICAgICAgb3JpZ0RvbVJhbmdlLnJlZnJlc2goKTtcbiAgICAgICAgdmFyIHN0YXJ0TGVmdFJlZlB0ID0gb3JpZ0RvbVJhbmdlLnN0YXJ0UmVmO1xuICAgICAgICB2YXIgZW5kTGVmdFJlZlB0ID0gc2VsZWN0aW9uUmFuZ2Uuc3RhcnRSZWY7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGhpZ2hsaWdodGluZ1xuICAgICAgICB0aGlzLnJ3X3JlbW92ZUhpZ2hsaWdodCh0aGlzLmdldExpc3RPZkhpZ2hsaWdodGFibGVOb2RlcyhvcmlnRG9tUmFuZ2Uuc3RhcnRDYXJldCxcbiAgICAgICAgICAgIG9yaWdEb21SYW5nZS5lbmRDYXJldCkpO1xuICAgICAgICB0aGlzLmdfYVRleHRSYW5nZS5zcGxpY2UoblBvcywgMSk7XG4gICAgICAgIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyLnNwbGljZShuUG9zLCAxKTtcblxuICAgICAgICAvLyAgYWRkIHRoZSBzcGxpdCBoaWdobGlnaHRzXG4gICAgICAgIC8vIGFkZCBsZWZ0XG4gICAgICAgIHZhciBjYXJldFJhbmdlID0gbmV3IFRIQ2FyZXRSYW5nZShzZWxlY3Rpb25SYW5nZS5ib2R5LFxuICAgICAgICAgICAgc3RhcnRMZWZ0UmVmUHQucGF0aCwgc3RhcnRMZWZ0UmVmUHQub2Zmc2V0LFxuICAgICAgICAgICAgZW5kTGVmdFJlZlB0LnBhdGgsIGVuZExlZnRSZWZQdC5vZmZzZXQpO1xuXG4gICAgICAgIHZhciBzdGFydENhcmV0ID0gY2FyZXRSYW5nZS5sZWZ0Q2FyZXQ7XG4gICAgICAgIHZhciBlbmRDYXJldCA9IGNhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yd19zZXRIaWdobGlnaHQoc3RhcnRDYXJldC5ub2RlLCBzdGFydENhcmV0Lm9mZnNldCxcbiAgICAgICAgICAgIGVuZENhcmV0Lm5vZGUsIGVuZENhcmV0Lm9mZnNldCwgc3RyT3JpZ0NvbG91cik7XG5cbiAgICAgICAgdmFyIHRtcERvbVJhbmdlID0gbmV3IFRIRG9tUmFuZ2UocmVzdWx0LnN0YXJ0LCAwLFxuICAgICAgICAgICAgcmVzdWx0LmVuZCwgcmVzdWx0LmVuZC5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5nX2FUZXh0UmFuZ2UucHVzaCh0bXBEb21SYW5nZSk7XG4gICAgICAgIHRoaXMuZ19hSGlnaGxpZ2h0Q29sb3VyLnB1c2goc3RyT3JpZ0NvbG91cik7XG5cbiAgICAgICAgc2VsZWN0aW9uUmFuZ2UucmVmcmVzaCgpO1xuICAgICAgICAvLyB0aGUgbWlkZGxlIGdldHMgYWRkZWQgYnkgY2FsbGVyLlxuICAgIH1cbn0iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW5tbCBvbiAyNS8wNC8yMDE2LlxuICovXG5cbmltcG9ydCB7TG9vcFN0YXRlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL01hdGhKYXgvTG9vcFN0YXRlJ1xuXG5leHBvcnQgY2xhc3MgRWxlbWVudEhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgaXMgbGVhZiBjaGFyYWN0ZXIgdGhhdCBzaG91bGRuJ3QgYmUgdHJlYXRlZCBhcyBlbGVtZW50IHRvIGxvb3AgaW4gdG8uXG4gICAgICogQHBhcmFtIHBfc3RyVHlwZVxuICAgICAqL1xuICAgIGlzVG9rZW5UeXBlKHBfc3RyVHlwZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBwX3N0clR5cGUgPT0gXCJlbnRpdHlcIiB8fCBwX3N0clR5cGUgPT0gXCJjaGFyXCIgfHxcbiAgICAgICAgICAgIHBfc3RyVHlwZSA9PSBcImVudGl0aWVzXCIgfHwgcF9zdHJUeXBlID09IFwiY2hhcnNcIjtcbiAgICB9XG5cbiAgICAvLyBSZWN1cnNpdmUgbG9vcCB0aHJvdWdoIHRoZSBkb20uXG4gICAgLy8gQWRkcyBlbGVtZW50cyBpbiBnaXZlbiByYW5nZSB0byB0aGUgbGlzdFxuICAgIC8vIFJldHVybnMgdHJ1ZSB3aGVuIGdvbmUgYXMgZmFyIGFzIGl0IG5lZWRzIHRvIGdvLlxuICAgIGxvb3BlcihkYXRhRWxlbSwgc3BhbklkLCBzdGF0ZSlcbiAgICB7XG4gICAgICAgIC8vIGNoZWNrIGZvciA8bWZlbmNlZCBvcGVuPSBjbG9zZT0gbWF0aG1sIGNhc2Ugd2l0aCBzZWN0aW9uIGNsb3NlZCBieSB0aGVzZSB0aHJvd2luZyBjb3VudCBvZmZcbiAgICAgICAgaWYgKGRhdGFFbGVtIT1udWxsKSB7XG4gICAgICAgICAgICB2YXIgamF4U3BhbmlkID0gZGF0YUVsZW0uc3BhbklEID8gZGF0YUVsZW0uc3BhbklEIDogZGF0YUVsZW0uQ0hUTUxub2RlSUQ7XG4gICAgICAgICAgICBqYXhTcGFuaWQgPSBqYXhTcGFuaWQgIT0gbnVsbCAmJiBqYXhTcGFuaWQgIT0gdW5kZWZpbmVkID8gamF4U3BhbmlkIDogZGF0YUVsZW0uUEhUTUxzcGFuSUQ7XG5cbiAgICAgICAgICAgIC8vIGlmIChqYXhTcGFuaWQhPW51bGwpe1xuICAgICAgICAgICAgaWYgKGpheFNwYW5pZCAhPSBudWxsICYmIGpheFNwYW5pZCA9PSBzcGFuSWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wdXNoVG9MaXN0KGRhdGFFbGVtKTtcbiAgICAgICAgICAgICAgICArK3N0YXRlLmNvdW50O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUVsZW0uZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUVsZW0uZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5sb29wZXIoZGF0YUVsZW0uZGF0YVtpXSwgc3BhbklkLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXRMaXN0KHJvb3QsIHNwYW5JZClcbiAgICB7XG4gICAgICAgIHZhciBzdGF0ZSA9IG5ldyBMb29wU3RhdGUoKTtcbiAgICAgICAgdGhpcy5sb29wZXIocm9vdCwgc3BhbklkLCBzdGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlLmdldExpc3QoKTtcbiAgICB9XG5cbn0iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW5tbCBvbiAyNS8wNC8yMDE2LlxuICovXG5cbmV4cG9ydCBjbGFzcyBIaWdobGlnaHREYXRhe1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mZyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTcGFuSWQgPSAwO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDI1LzA0LzIwMTYuXG4gKi9cblxuZXhwb3J0IGNsYXNzIExvb3BTdGF0ZXtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDE7IC8vIFdoZW4gbG9vcCBzdGFydHMgYWxyZWFkeSBhdCB0aGUgc2Vjb25kIGVsZW1lbnRcbiAgICAgICAgdGhpcy5saXN0ID0gW107XG4gICAgfVxuXG4gICAgcHVzaFRvTGlzdCAob2JqKVxuICAgIHtcbiAgICAgICAgdGhpcy5saXN0LnB1c2gob2JqKTtcbiAgICB9O1xuXG4gICAgZ2V0TGlzdCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0O1xuICAgIH1cbn0iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW5tbCBvbiAyNS8wNC8yMDE2LlxuICovXG5pbXBvcnQge0hpZ2hsaWdodERhdGF9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vTWF0aEpheC9IaWdobGlnaHREYXRhJ1xuaW1wb3J0IHtFbGVtZW50SGVscGVyfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL01hdGhKYXgvRWxlbWVudEhlbHBlcidcbmltcG9ydCB7U1NET019IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL1NTRE9NJ1xuXG5cbmV4cG9ydCBjbGFzcyBNYXRoSmF4SGlnaGxpZ2h0ZXJ7XG4gICAgY29uc3RydWN0b3IoamF4KXtcbiAgICAgICAgdGhpcy5oaWdobGlnaHREYXRhU3RvcmUgPSB7fTsgLy8gc3RvcmVzIGhpZ2hsaWdodCBkYXRhIGZvciBnaXZlbiB0eXBlLlxuICAgICAgICB0aGlzLmhpZ2hsaWdodEpheFJvb3QgPSBqYXgucm9vdDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRDbGVhckxhc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLmVsZW1lbnRIZWxwZXIgPSBuZXcgRWxlbWVudEhlbHBlcigpXG5cbiAgICB9XG5cbiAgICAvLyBTZXQgd2hldGhlciBvciBub3QgdGhlIHByZXZpb3VzIGhpZ2hsaWdodCBzaG91bGQgYmUgY2xlYXJlZCB3aGVuIGFkZGluZyBuZXcgb25lLlxuICAgIC8vIElmIHNldCB0byBmYWxzZSBhbmQgaGlnaGxpZ2h0cyBhZGRlZCB0aGUgb2xkIGhpZ2hsaWdodHMgYXJlIG5vdCBzdG9yZWQgYW5kIGFkZGluZyBhIG5ldyBoaWdobGlnaHRcbiAgICAvLyBkb2VzIG5vdCBjbGVhciB0aGUgb2xkIG9uZS4gIENhbGxpbmcgY2xlYXJIaWdobGlnaHRzKCkgd2lsbCBub3QgcmVtb3ZlIHRoZW0uICBTZXR0aW5nIHRoaXMgdG8gdHJ1ZVxuICAgIC8vIHdpbGwgb25seSBhZmZlY3QgaGlnaGxpZ2h0cyBhZGRlZCBhZnRlciBpdCBpcyBzZXQgdHJ1ZS5cbiAgICAvLyBUaGUgY2FsbGVyIG5lZWRzIHRvIGtlZXAgaXRzIG93biByZWNvcmQgb2YgaGlnaGxpZ2h0cyBhZGRlZCB3aGlsZSB0aGlzIGlzIGZhbHNlLlxuICAgIHNldENsZWFyTGFzdEhpZ2hsaWdodCAoYilcbiAgICB7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Q2xlYXJMYXN0ID0gYjtcbiAgICB9O1xuXG4gICAgLy8gdHlwZSBcImNvbnRleHRcIiBvciBcIndvcmRcIiBvciBjdXN0b20gdmFsdWUgbWF0Y2hlZCB0byBoaWdobGlnaHROb2RlcyBjYWxsLlxuICAgIC8vIHN0eWxlICBcIm91dGxpbmVcIiwgXCJ1bmRlcmxpbmVcIiwgXCJmZ1wiLCBcImJnXCIsIG9yIFwibm9uZVwiIChcIlwiIG9yIG51bGwgY291bnQgYXMgbm9uZSlcbiAgICAvLyByIGcgYiB2YWx1ZSAwLTI1NVxuICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBzdHlsZSB1cGRhdGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICBzZXRIaWdobGlnaHRTdHlsZSAodHlwZSwgc3R5bGUsIHIsIGcsIGIpXG4gICAge1xuICAgICAgICBpZih0eXBlb2YodHlwZSkgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgY3VycmVudGx5IGhpZ2hsaWdodGluZyBmb3IgdGhpcyB0eXBlLCBpZiBzbyBuZWVkIHRvIHJlbW92ZSB0aGlzXG4gICAgICAgIC8vIHByaW9yIHRvIGNoYW5naW5nIG9yIHJlbW92aW5nIHRoZSBzdHlsZSBmb3IgdGhpcyB0eXBlLlxuICAgICAgICBpZih0aGlzLmhpZ2hsaWdodERhdGFTdG9yZVt0eXBlXSAmJiB0aGlzLmhpZ2hsaWdodERhdGFTdG9yZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRtcERhdGEgPSB0aGlzLmhpZ2hsaWdodERhdGFTdG9yZVt0eXBlXTtcbiAgICAgICAgICAgIGlmKHRtcERhdGEgJiYgdG1wRGF0YS5sYXN0U3BhbklkID4gMCApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodE5vZGVzSW1wbCh0eXBlLCB0bXBEYXRhLnN0eWxlLCB0bXBEYXRhLmxhc3RTcGFuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoc3R5bGUgPT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhpZ2hsaWdodERhdGFTdG9yZVt0eXBlXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodHlwZW9mKHN0eWxlKSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAge1xuICAgICAgICAgICAgc3R5bGUgPSBzdHlsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc3R5bGUgPT09IFwiXCIgfHwgc3R5bGUgPT09IFwibm9uZVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5oaWdobGlnaHREYXRhU3RvcmVbdHlwZV07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuUiwgbkcsIG5CO1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgblIgPSB0aGlzLnBhcnNlQ29sb3Iocik7XG4gICAgICAgICAgICBuRyA9IHRoaXMucGFyc2VDb2xvcihnKTtcbiAgICAgICAgICAgIG5CID0gdGhpcy5wYXJzZUNvbG9yKGIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycilcbiAgICAgICAgeyAgIC8vIGludmFsaWQgdmFsdWVzIHBhc3NlZCBpblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGE7XG5cbiAgICAgICAgaWYodGhpcy5oaWdobGlnaHREYXRhU3RvcmVbdHlwZV0gJiYgdGhpcy5oaWdobGlnaHREYXRhU3RvcmUuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmhpZ2hsaWdodERhdGFTdG9yZVt0eXBlXTtcbiAgICAgICAgICAgIC8vIElmIGlzIGFscmVhZHkgaGlnaGxpZ2h0IGFuZCBhZGRpbmcgaGlnaGxpZ2h0IG1pZ2h0IHdhbnQgZXhpc3RpbmcgZmcgb3IgYmcga2VwdC5cbiAgICAgICAgICAgIC8vIGlmIGV4aXN0aW5nIHN0eWxlIGlzIG5vdCBoaWdobGlnaHQsIGFsd2F5cyB3YW50IHRvIGNsZWFyIHZhbHVlcy5cbiAgICAgICAgICAgIGlmKGRhdGEuc3R5bGUgIT09IFwiaGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGF0YS5mZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZGF0YS5iZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBkYXRhID0gbmV3IEhpZ2hsaWdodERhdGEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHN0eWxlID09PSBcImZnXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEuc3R5bGUgPSBcImhpZ2hsaWdodFwiO1xuICAgICAgICAgICAgZGF0YS5mZyA9IFwicmdiKFwiICsgblIgKyBcIixcIiArIG5HICsgXCIsXCIgKyBuQiArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc3R5bGUgPT09IFwiYmdcIilcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YS5zdHlsZSA9IFwiaGlnaGxpZ2h0XCI7XG4gICAgICAgICAgICBkYXRhLmJnID0gXCJyZ2IoXCIgKyBuUiArIFwiLFwiICsgbkcgKyBcIixcIiArIG5CICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihzdHlsZSA9PT0gXCJvdXRsaW5lXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIGRhdGEuZmcgPSBcInJnYihcIiArIG5SICsgXCIsXCIgKyBuRyArIFwiLFwiICsgbkIgKyBcIilcIjtcbiAgICAgICAgICAgIGRhdGEuYmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc3R5bGUgPT09IFwidW5kZXJsaW5lXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIGRhdGEuZmcgPSBcInJnYihcIiArIG5SICsgXCIsXCIgKyBuRyArIFwiLFwiICsgbkIgKyBcIilcIjtcbiAgICAgICAgICAgIGRhdGEuYmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaWdobGlnaHREYXRhU3RvcmVbdHlwZV0gPSBkYXRhO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGhpZ2hsaWdodGluZyB0byBlbGVtZW50cyBmcm9tIGdpdmVuIHJhbmdlXG4gICAgLy8gdHlwZSBpcyB1c2VkIHRvIHNlbGVjdCB0aGUgc3R5bGUgc2V0IGZvciB0aGF0IHR5cGUgd2l0aCBzZXRIaWdobGlnaHRTdHlsZSAoaS5lLiBcImNvbnRleHRcIiBvciBcIndvcmRcIilcbiAgICAvLyBzdGFydCBhbmQgZW5kIGdpdmUgdGhlIGluY2x1c2l2ZSByYW5nZSB0byBoaWdobGlnaHQuXG4gICAgaGlnaGxpZ2h0Tm9kZXMgKHR5cGUsIHNwYW5JZClcbiAgICB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZih0aGlzLmhpZ2hsaWdodERhdGFTdG9yZVt0eXBlXSAmJiB0aGlzLmhpZ2hsaWdodERhdGFTdG9yZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuaGlnaGxpZ2h0RGF0YVN0b3JlW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGEuc3R5bGUgPT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRhdGEubGFzdFNwYW5JZCA+IDAgICYmIHRoaXMuaGlnaGxpZ2h0Q2xlYXJMYXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNsZWFySGlnaGxpZ2h0Tm9kZXNJbXBsKHR5cGUsIGRhdGEuc3R5bGUsIGRhdGEubGFzdFNwYW5JZCk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmxhc3RTcGFuSWQgPSBzcGFuSWQ7XG4gICAgLy8gICAgICAgICAgICAgICAgZGF0YS5sYXN0RW5kID0gZW5kO1xuXG4gICAgICAgIC8vIFBhc3Mgcm9vdCwgdGhlbiBjb3VudCBmb3IgcG9zaXRpb24gb2YgZWxlbWVudCBmb3IgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnQgdG8gZmV0Y2gsIGluY2x1c2l2ZS5cbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmVsZW1lbnRIZWxwZXIuZ2V0TGlzdCh0aGlzLmhpZ2hsaWdodEpheFJvb3QsIHNwYW5JZCk7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkhpZ2hsaWdodCBzdGFydCBcIiArIHN0YXJ0ICsgXCIgICBlbmQgICBcIiArIGVuZCk7XG5cbiAgICAgICAgdGhpcy5oaWdobGlnaHRJbXBsKGxpc3QsIHR5cGUsIGRhdGEuc3R5bGUsIGRhdGEuZmcsIGRhdGEuYmcpO1xuICAgIH07XG5cbiAgICAvLyBjbGVhciBhbGwgaGlnaGxpZ2h0c1xuICAgIGNsZWFySGlnaGxpZ2h0cyAoKVxuICAgIHtcbiAgICAgICAgZm9yKHZhciB0eXBlIGluIHRoaXMuaGlnaGxpZ2h0RGF0YVN0b3JlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih0aGlzLmhpZ2hsaWdodERhdGFTdG9yZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuaGlnaGxpZ2h0RGF0YVN0b3JlW3R5cGVdO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodE5vZGVzSW1wbCh0eXBlLCBcIlwiLCBkYXRhLmxhc3RTcGFuSWQpO1xuICAgICAgICAgICAgICAgIGRhdGEubGFzdFNwYW5JZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY2xlYXJIaWdobGlnaHROb2RlcyAodHlwZSwgc3BhbklkKVxuICAgIHtcbiAgICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodE5vZGVzSW1wbCh0eXBlLCBcIlwiLCBzcGFuSWQpO1xuICAgIH07XG5cbiAgICBwYXJzZUNvbG9yKHZhbClcbiAgICB7XG4gICAgICAgIHZhciB0bXBWYWw7XG4gICAgICAgIGlmKHR5cGVvZih2YWwpID09PSBcInN0cmluZ1wiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0bXBWYWwgPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHR5cGVvZih2YWwpID09PSBcIm51bWJlclwiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0bXBWYWwgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBcImludmFsaWRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZih0bXBWYWwgPCAwIHx8IHRtcFZhbCA+IDI1NSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgXCJpbnZhbGlkXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG1wVmFsO1xuICAgIH1cblxuICAgIGNsZWFySGlnaGxpZ2h0Tm9kZXNJbXBsKHR5cGUsIHN0eWxlLCBzcGFuSUQpXG4gICAge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMuZWxlbWVudEhlbHBlci5nZXRMaXN0KHRoaXMuaGlnaGxpZ2h0SmF4Um9vdCwgc3BhbklEKTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwLCBuTGVuID0gbGlzdC5sZW5ndGg7IGkgPCBuTGVuOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihzdHlsZSA9PT0gXCJcIiB8fCBzdHlsZSA9PT0gXCJvdXRsaW5lXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5tYXRob3V0bGluZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihzdHlsZSA9PT0gXCJcIiB8fCBzdHlsZSA9PT0gXCJ1bmRlcmxpbmVcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0ucHJldmlvdXNsaW5lKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21QcmV2aW91cyhpdGVtLnByZXZpb3VzbGluZSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdG8gd2hhdCBpcyBsZWZ0IGFzIGxhc3QgaW4gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGl0ZW0ucHJldmlvdXNsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxlbiA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5tYXRodW5kZXJsaW5lID0gaXRlbS5wcmV2aW91c2xpbmVbbGVuIC0gMV0udmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubWF0aHVuZGVybGluZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm1hdGh1bmRlcmxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoc3R5bGUgPT09IFwiXCIgfHwgc3R5bGUgPT09IFwiaGlnaGxpZ2h0XCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZihpdGVtLnByZXZpb3VzY29sb3IpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVByZXZpb3VzKGl0ZW0ucHJldmlvdXNjb2xvciwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY29sb3IgdG8gd2hhdCBpcyBsZWZ0IGFzIGxhc3QgaW4gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGl0ZW0ucHJldmlvdXNjb2xvci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihsZW4gPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubWF0aGNvbG9yID0gaXRlbS5wcmV2aW91c2NvbG9yW2xlbiAtIDFdLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm1hdGhjb2xvciA9IFwiXCI7ICAgIC8vIHNwYWNlIHJhdGhlciB0aGFuIFwiXCIgZHVlIHRvIGJ1ZyBpbiBtYXRoamF4IHdoZXJlIHdpbGwgaWdub3JlIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubWF0aGNvbG9yID0gXCIgXCI7ICAgIC8vIHNwYWNlIHJhdGhlciB0aGFuIFwiXCIgZHVlIHRvIGJ1ZyBpbiBtYXRoamF4IHdoZXJlIHdpbGwgaWdub3JlIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5tYXRoYmFja2dyb3VuZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3BhbkVsZW09bnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzcGFuRWxlbSA9aXRlbS5IVE1Mc3BhbkVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKXtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3BhbkVsZW09PW51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5FbGVtID0gaXRlbS5DSFRNTG5vZGVFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcGFuRWxlbT09bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIHZhciBiU3VjY2VzcyA9dHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5IVE1McmVtb3ZlQ29sb3IhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYlN1Y2Nlc3MgPXRoaXMuc2V0dXBQb3N0Rml4KHNwYW5FbGVtLCB0eXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihiU3VjY2VzcylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLkhUTUxoYW5kbGVDb2xvcihzcGFuRWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycil7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLlBIVE1MaGFuZGxlQ29sb3Ioc3BhbkVsZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0ZG93blBvc3RGaXgoKTtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgIHZhciBiU3VjY2VzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uSFRNTHJlbW92ZUNvbG9yIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJTdWNjZXNzID0gdGhpcy5zZXR1cFBvc3RGaXgoc3BhbkVsZW0sIHR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoYlN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5IVE1McmVtb3ZlQ29sb3IhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uSFRNTHJlbW92ZUNvbG9yKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwID0gaXRlbS5IVE1Mc3BhbkVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcCA9IGl0ZW0uQ0hUTUxub2RlRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcC5zdHlsZS5iYWNrZ3JvdW5kID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcC5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRkb3duUG9zdEZpeCgpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLkhUTUxyZW1vdmVDb2xvciE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwID0gaXRlbS5IVE1Mc3BhbkVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3AgPSBpdGVtLkNIVE1Mbm9kZUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3AgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Auc3R5bGUuYmFja2dyb3VuZCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcC5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZG9uZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpZ2hsaWdodEltcGwobGlzdCwgdHlwZSwgc3R5bGUsIGZnLCBiZylcbiAgICB7XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIG5MZW4gPSBsaXN0Lmxlbmd0aDsgaSA8IG5MZW47IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGNvbG9ySGFuZGxlID0gaXRlbS5IVE1MaGFuZGxlQ29sb3I/aXRlbS5IVE1MaGFuZGxlQ29sb3I6aXRlbS5DSFRNTGhhbmRsZUNvbG9yO1xuICAgICAgICAgICAgaWYodHlwZW9mKGNvbG9ySGFuZGxlKSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYW5FbGVtPW51bGw7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzcGFuRWxlbSA9aXRlbS5DSFRNTG5vZGVFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKXtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3BhbkVsZW09PW51bGwpe1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbkVsZW0gPSBpdGVtLkhUTUxzcGFuRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpe1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihzcGFuRWxlbSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHN0eWxlID09PSBcImhpZ2hsaWdodFwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoYmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5tYXRoYmFja2dyb3VuZCA9IGJnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWl0ZW0ucHJldmlvdXNjb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXZpb3VzY29sb3IgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpdGVtLm1hdGhjb2xvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgcHVzaGVzIHRoZSBjdXJyZW50IGNvbG9yIGlmIHNldC4gIElmIHRoaXMgZXhpc3RzIHdpdGhvdXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5IGV4aXN0aW5nLCB0aGVuIGl0IGlzIHNldCBieSBzb3VyY2Ugb3RoZXIgdGhhbiB0aGUgdG9vbGJhci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5wcmV2aW91c2NvbG9yLnB1c2goe1wia2V5XCI6XCJcIiwgXCJ2YWxcIjppdGVtLm1hdGhjb2xvcn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RlIHRoaXMgZHVlIHRvIGJ1dCBpbiBtYXRoamF4IHJlbGF0aW5nIHRvIHNldHRpbmcgbWF0aGNvbG9yIHRvIFwiXCIgKHlvdSBjYW4ndClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgeW91IGNhbiB5b3UgbmVlZCB0byBkbyB0aGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHNzZG9tLmdldENvbXB1dGVkU3R5bGUoc3BhbkVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gdG1wLmNvbG9yO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvbClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXNjb2xvci5wdXNoKHtcImtleVwiOlwiXCIsIFwidmFsXCI6Y29sfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Vcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXNjb2xvci5wdXNoKHtcImtleVwiOlwiXCIsIFwidmFsXCI6XCJyZ2IoMCwwLDApXCJ9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMganVzdCByZW1vdmVzIGFueSBpbiBwcmV2aW91cyBsaXN0IHRoYXQgbWF0Y2hlcyB0aGUgdHlwZSBhYm91dCB0byBiZSBhZGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGlzIG9ubHkgaW4gbGlzdCBvbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVByZXZpb3VzKGl0ZW0ucHJldmlvdXNjb2xvciwgdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXNjb2xvci5wdXNoKHtcImtleVwiOnR5cGUsIFwidmFsXCI6Zmd9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ubWF0aGNvbG9yID0gZmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdHlsZSA9PT0gXCJvdXRsaW5lXCIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLm1hdGhvdXRsaW5lID0gZmcgKyBcInRoaW4gc29saWRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdHlsZSA9PT0gXCJ1bmRlcmxpbmVcIilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCFpdGVtLnByZXZpb3VzbGluZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5wcmV2aW91c2xpbmUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0udGV4dERlY29yYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5wcmV2aW91c2xpbmUucHVzaCh7XCJrZXlcIjpcIlwiLCBcInZhbFwiOml0ZW0udGV4dERlY29yYXRpb259KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVByZXZpb3VzKGl0ZW0ucHJldmlvdXNsaW5lLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpdGVtLnByZXZpb3VzbGluZS5wdXNoKHtcImtleVwiOnR5cGUsIFwidmFsXCI6XCJ1bmRlcmxpbmVcIn0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ubWF0aHVuZGVybGluZSA9IFwidW5kZXJsaW5lXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnRseSBjYW5ub3Qgc2V0IHRleHQtZGVjb3JhdGlvbiBjb2xvciBzbyBjb2xvciBpZ25vcmVkIGZvciB0aGlzXG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiSGlnaGxpZ2h0IFwiICsgdHlwZSArIFwiICBcIiArIGl0ZW0udG9TdHJpbmcoKSArIFwiICAgXCIrIGkpO1xuXG5cbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGFkZCBzb21ldGhpbmcgdG8gbWFrZSBpZCB1bmlxdWUsIHNvIGNhbiBiZSBzdXJlIGl0IGlzIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBzcGVjaWZpYyB0byBpbXBsZW1lbnRhdGlvbiBpbiBtYXRoamF4LCBidXQgd2l0aCByZXF1ZXN0IHRvIHdvcmsgYnkgY2FsbGluZyBpblxuICAgICAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIHBsdWdpbiBpbnNpZGUgbWF0aGpheCwgdGhpcyBpcyBuZWVkZWQuXG5cbiAgICAgICAgICAgICAgICB2YXIgYlN1Y2Nlc3MgPSB0aGlzLnNldHVwUG9zdEZpeChzcGFuRWxlbSwgdHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYoYlN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5IVE1MaGFuZGxlQ29sb3Ioc3BhbkVsZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5QSFRNTGhhbmRsZUNvbG9yKHNwYW5FbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0ZG93blBvc3RGaXgoKTtcblxuICAgICAgICAgICAgICAvLyAgY29uc29sZS5sb2coXCJIaWdobGlnaHQgRG9uZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUZyb21QcmV2aW91cyhhcnIsIHR5cGUpXG4gICAge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihhcnJbaV0ua2V5ID09PSB0eXBlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaW5ncyB3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBfc3BhblxuICAgICAqIEBwYXJhbSBwX3N0clR5cGVcbiAgICAgKiBAcGFyYW0gcF9iQWRkaW5nICB0cnVlIGlmIGFkZGluZyB0aGUgY29sb3VyIHNvIHNwYW4gc2hvdWxkIG5vdCBhbHJlYWR5IGV4aXN0XG4gICAgICovXG4gICAgc2V0dXBQb3N0Rml4KHBfc3BhbiwgcF9zdHJUeXBlLCBwX2JBZGRpbmcpXG4gICAge1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIEhUTUxDU1MgPSBNYXRoSmF4Lk91dHB1dEpheFtcIkhUTUwtQ1NTXCJdP01hdGhKYXguT3V0cHV0SmF4W1wiSFRNTC1DU1NcIl06TWF0aEpheC5PdXRwdXRKYXhbXCJDb21tb25IVE1MXCJdO1xuICAgICAgICAgICAgdmFyIHN0clR5cGVBc0FkZGVkID0gXCItXCIgKyBwX3N0clR5cGU7XG5cbiAgICAgICAgICAgIGlmKHBfYkFkZGluZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBlbGVtZW50IGxpa2UgdGhpcyBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgIHZhciBzdHJTcGFuSUQgPSBwX3NwYW4uaWQgKyBIVE1MQ1NTLmlkUG9zdGZpeCArIHN0clR5cGVBc0FkZGVkO1xuICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0clNwYW5JRCkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7ICAgLy8gYWxyZWFkeSBleGlzdHMsIGRvbid0IGFkZCBoaWdobGlnaHQgYXMgd2lsbCBhZGQgdG8gYmFkIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0eXBlb2YoSFRNTENTUy5pZFBvc3RmaXgpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3N0clRtcFBvc3RGaXggPSBIVE1MQ1NTLmlkUG9zdGZpeDtcbiAgICAgICAgICAgICAgICBIVE1MQ1NTLmlkUG9zdGZpeCArPSBzdHJUeXBlQXNBZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc3RyVG1wUG9zdEZpeCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgSFRNTENTUy5pZFBvc3RmaXggPSBzdHJUeXBlQXNBZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2dFKGVycik7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHRoZWlyIGludGVybmFsIGxvZ2ljIGNoYW5nZXMsIHRoaXMgd2lsbCBwcm9iYWJseSBzdG9wIGhpZ2hsaWdodGluZyB3b3JraW5nIHByb3Blcmx5XG4gICAgICAgICAgICAvLyBidXQgd2lsbCBzdG9wIHRvb2xiYXIgYnJlYWtpbmcgY29tcGxldGVseS5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gaWRQb3N0Rml4IHRvIHByZXZpb3VzIHN0YXRlLCBiYXNlZCBvbiBzdG9yZWQgbV9zdHJUbXBQb3N0Rml4LlxuICAgICAqIElmIGl0IGlzIG51bGwsIHRoZW4gaWRQb3N0Rml4IGhhc24ndCBiZWVuIGFsdGVyZWQsXG4gICAgICogSWYgaXQgaXMgbnVsbCwgdGhlbiBpZFBvc3RGaXggd2FzIGFsdGVyZWQgYW5kIG5vIHByZXZpb3VzIHZhbHVlLlxuICAgICAqIElmIGl0IGlzIHN0cmluZywgdGhlbiBpZFBvc3RGaXggd2FzIGFsdGVyZWQgYW5kIG5lZWQgdG8gcmV0dXJuLlxuICAgICAqL1xuICAgIHNldGRvd25Qb3N0Rml4KClcbiAgICB7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgSFRNTENTUyA9IE1hdGhKYXguT3V0cHV0SmF4W1wiSFRNTC1DU1NcIl0/TWF0aEpheC5PdXRwdXRKYXhbXCJIVE1MLUNTU1wiXTpNYXRoSmF4Lk91dHB1dEpheFtcIkNvbW1vbkhUTUxcIl07XG5cbiAgICAgICAgICAgIGlmKHRoaXMubV9zdHJUbXBQb3N0Rml4ID09IFwiXCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgSFRNTENTUy5pZFBvc3RmaXggPSBudWxsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBIVE1MQ1NTLmlkUG9zdGZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHRoaXMubV9zdHJUbXBQb3N0Rml4ICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgSFRNTENTUy5pZFBvc3RmaXggPXRoaXMubV9zdHJUbXBQb3N0Rml4O1xuICAgICAgICAgICAgICAgIHRoaXMubV9zdHJUbXBQb3N0Rml4ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgbnVsbCBhbmQgbm90aGluZyB0byBkb1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycilcbiAgICAgICAge1xuICAgICAgICAgICAvLyBjb25zb2xlLmxvZ0UoZXJyKTtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlaXIgaW50ZXJuYWwgbG9naWMgY2hhbmdlcywgdGhpcyB3aWxsIHByb2JhYmx5IHN0b3AgaGlnaGxpZ2h0aW5nIHdvcmtpbmcgcHJvcGVybHlcbiAgICAgICAgICAgIC8vIGJ1dCB3aWxsIHN0b3AgdG9vbGJhciBicmVha2luZyBjb21wbGV0ZWx5LlxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDIxLzA0LzIwMTYuXG4gKi9cblxuZXhwb3J0IGNsYXNzIE1hdGhTcGVhayB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHNyZS5TeXN0ZW0uZ2V0SW5zdGFuY2UoKS5zZXR1cEVuZ2luZSh7c2VtYW50aWNzOiBmYWxzZSwgZG9tYWluOiAnbWF0aHNwZWFrJywgc3R5bGU6ICdkZWZhdWx0J30pO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gc3JlLlN5c3RlbS5nZXRJbnN0YW5jZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwX25vZGUgc2hvdWxkIGJlIG1hdGhKYXggbm9kZVxuICAgICAqL1xuICAgIGdldFRleHRGcm9tTWF0aEpheCAocF9ub2RlKVxuICAgIHtcbiAgICAgICAgaWYocF9ub2RlLmlzTWF0aEpheClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSBwX25vZGU7XG4gICAgICAgICAgICB3aGlsZSh0bXBOb2RlICE9IG51bGwgJiYgdG1wTm9kZS5pc01hdGhKYXggJiYgIXRtcE5vZGUuaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG1wTm9kZSA9IHRtcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdHJNYXRoQ29kZTtcbiAgICAgICAgICAgIGlmKHRtcE5vZGUgJiYgdG1wTm9kZS5pZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJNYXRoQ29kZSA9IFwibWF0aDpcIiArIHRtcE5vZGUuaWQgKyBcIjtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJNYXRoQ29kZSA9IFwibWF0aDpub25lO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGpheCA9TWF0aEpheC5IdWIuZ2V0SmF4Rm9yKHBfbm9kZSk7XG4gICAgICAgIGlmKGpheCAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbW1sID0gbnVsbDtcbiAgICAgICAgICAgIHRyeVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1tbCA9IGpheC5yb290LnRvTWF0aE1MKFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmKG1tbCAhPSBudWxsIHx8IG1tbC5sZW5ndGggPjApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyTWF0aENvZGUgKyBtbWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIGdldFNwZWVjaCAgKGVsZW1lbnRJRCl7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudElEID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJRCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCE9bnVsbCAmJiBlbGVtZW50LmlzTWF0aEpheD09dHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRoSmF4VGV4dCA9IHRoaXMuZ2V0TWF0aE1MVGV4dChlbGVtZW50SUQpO1xuICAgICAgICAgICAgICAgIHZhciBtYXRoSmF4T2JqZWN0ID0gdGhpcy5nZXRNYXRoTUxPYmplY3QoZWxlbWVudElEKTtcbiAgICAgICAgICAgICAgICBtYXRoSmF4VGV4dD0gbWF0aEpheFRleHQucmVwbGFjZSgvPFxcLyhbXj5dKykvZyxcIjwvbWF0aG1sOiQxPlwiKTtcbiAgICAgICAgICAgICAgICBtYXRoSmF4VGV4dD1tYXRoSmF4VGV4dC5yZXBsYWNlKC88KFtePl0rKS9nLFwiPG1hdGhtbDokMT5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UucHJvY2Vzc0V4cHJlc3Npb24odGhpcy5nZXRNYXRoTUxXaXRoQm9va21hcmtzKG1hdGhKYXhPYmplY3QsIG1hdGhKYXhUZXh0LCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcblxuICAgIGdldFNwZWVjaFdpdGhCb29rbWFya3MgKGVsZW1lbnRJRCl7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudElEID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJRCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCE9bnVsbCAmJiBlbGVtZW50LmlzTWF0aEpheD09dHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElEKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0aEpheFRleHQgPSB0aGlzLmdldE1hdGhNTFRleHQoZWxlbWVudElEKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0aEpheE9iamVjdCA9IHRoaXMuZ2V0TWF0aE1MT2JqZWN0KGVsZW1lbnRJRCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UucHJvY2Vzc0V4cHJlc3Npb24odGhpcy5nZXRNYXRoTUxXaXRoQm9va21hcmtzKG1hdGhKYXhPYmplY3QsIG1hdGhKYXhUZXh0LCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcblxuICAgIGdldFNwZWVjaFdpdGhCb29rbWFya3NGcm9tRWxlbWVudCAoZWxlbWVudCl7XG4gICAgICAgIGlmIChlbGVtZW50IT1udWxsICYmIGVsZW1lbnQuaXNNYXRoSmF4PT10cnVlKSB7XG4gICAgICAgICAgICB2YXIgdGV4dD1cIlwiO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0aEpheFRleHQgPSB0aGlzLmdldE1hdGhNTFRleHQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGhKYXhPYmplY3QgPSB0aGlzLmdldE1hdGhNTE9iamVjdChlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXRoID0gdGhpcy5nZXRNYXRoTUxXaXRoQm9va21hcmtzKG1hdGhKYXhPYmplY3QsIG1hdGhKYXhUZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0aCE9XCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5pbnN0YW5jZS5wcm9jZXNzRXhwcmVzc2lvbihtYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpe1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuXG4gICAgZ2V0TWF0aE1MT3JpZ2luYWxUZXh0IChlbGVtZW50SUQpe1xuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRJRCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SUQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQhPW51bGwgJiYgZWxlbWVudC5pc01hdGhKYXg9PXRydWUpIHtcblxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElEKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aEpheC5IdWIuZ2V0SmF4Rm9yKGVsZW1lbnQpLm9yaWdpbmFsVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuXG4gICAgZ2V0TWF0aE1MVGV4dCAoZWxlbWVudCl7XG4gICAgICAgIGlmIChlbGVtZW50IT1udWxsICYmIGVsZW1lbnQuaXNNYXRoSmF4PT10cnVlKSB7XG4gICAgICAgICAgICB2YXIgbWF0aEpheFRleHQgPSBNYXRoSmF4Lkh1Yi5nZXRKYXhGb3IoZWxlbWVudCkucm9vdC50b01hdGhNTCgpO1xuICAgICAgICAgICAgdmFyIG9QYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICB2YXIgb0RPTSA9IG9QYXJzZXIucGFyc2VGcm9tU3RyaW5nKG1hdGhKYXhUZXh0LCBcInRleHQveG1sXCIpO1xuICAgICAgICAgICAgaWYgKG9ET00uZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09IFwicGFyc2VyZXJyb3JcIiAgfHwgb0RPTS5kb2N1bWVudEVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlTmFtZT09IFwicGFyc2VyZXJyb3JcIil7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1hdGhtbCBpcyBpbnZhbGlkLCBQbGVhc2UgY29udGFjdCBwYWdlIHByb3ZpZGVyXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IFwiTWF0aG1sIGlzIGludmFsaWQsIFBsZWFzZSBjb250YWN0IHBhZ2UgcHJvdmlkZXJcIjtcbiAgICAgICAgICAgICAgICBtYXRoSmF4VGV4dD1cIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGhKYXhUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG5cbiAgICBnZXRNYXRoTUxPYmplY3QgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQhPW51bGwgJiYgZWxlbWVudC5pc01hdGhKYXg9PXRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoSmF4Lkh1Yi5nZXRKYXhGb3IoZWxlbWVudCkucm9vdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG5cbiAgICBpc01hdGhNTChlbGVtZW50SUQpe1xuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRJRCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SUQpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50LmlzTWF0aEpheCA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgZ2V0TWF0aE1MV2l0aEJvb2ttYXJrcyAobWF0aHNPYmplY3QsbWF0aHNUZXh0LCBpbmNsdWRlQm9va21hcmtzKXtcblxuICAgICAgICBpZiAobWF0aHNUZXh0IT1udWxsICl7XG4gICAgICAgICAgICBtYXRoc1RleHQgPSBtYXRoc1RleHQucmVwbGFjZSgvPG1hdGhtbDptYXRoLio+LywnPG1hdGggeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGhzT2JqZWN0LmRhdGEgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9MDsgaSA8IG1hdGhzT2JqZWN0LmRhdGEubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhzT2JqZWN0LmRhdGFbaV0hPW51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGpheFNwYW5pZCA9IG1hdGhzT2JqZWN0LmRhdGFbaV0uc3BhbklEID8gbWF0aHNPYmplY3QuZGF0YVtpXS5zcGFuSUQgOiBtYXRoc09iamVjdC5kYXRhW2ldLkNIVE1Mbm9kZUlEO1xuICAgICAgICAgICAgICAgICAgICBqYXhTcGFuaWQgPSBqYXhTcGFuaWQgIT0gbnVsbCAmJiBqYXhTcGFuaWQgIT0gdW5kZWZpbmVkID8gamF4U3BhbmlkIDogbWF0aHNPYmplY3QuZGF0YVtpXS5QSFRNTHNwYW5JRDtcblxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRoc09iamVjdC5kYXRhW2ldLnRvTWF0aE1MICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRoc09iamVjdC5kYXRhW2ldLnRvTWF0aE1MKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGpheFNwYW5pZCAhPSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGhzT2JqZWN0LmRhdGFbaV0uZGF0YVswXSAhPSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGhzT2JqZWN0LmRhdGFbaV0uZGF0YVswXS5kYXRhWzBdICE9IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0aHNPYmplY3QuZGF0YVtpXS5kYXRhWzBdLmRhdGFbMF0udG9NYXRoTUwgPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFuID0gbWF0aHNPYmplY3QuZGF0YVtpXS50b01hdGhNTCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGhzVGV4dC5pbmRleE9mKHNwYW4pID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhbiA9IHNwYW4ucmVwbGFjZSgvPi4qPC8sIFwiPlwiICsgbWF0aHNPYmplY3QuZGF0YVtpXS5kYXRhWzBdLmRhdGFbMF0gKyBcIjxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUJvb2ttYXJrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBsID0gc3Bhbi5yZXBsYWNlKCc+JywgJyBib29rbWFyayA9XCInICsgamF4U3BhbmlkICsgJ1wiPicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbCA9IHNwYW4ucmVwbGFjZSgnPicsICcgbm9ib29rbWFyayA9XCJcIj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGhzVGV4dCA9IG1hdGhzVGV4dC5yZXBsYWNlKHNwYW4sIHJlcGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hdGhzVGV4dCA9IHRoaXMuZ2V0TWF0aE1MV2l0aEJvb2ttYXJrcyhtYXRoc09iamVjdC5kYXRhW2ldLCBtYXRoc1RleHQsIGluY2x1ZGVCb29rbWFya3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0aHNUZXh0O1xuICAgIH07XG5cbiAgICBnZXRNYXRoTUxUZXh0V2l0aEJvb2ttYXJrcyAoZWxlbWVudElEKXtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50SUQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElEKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50IT1udWxsICYmIGVsZW1lbnQuaXNNYXRoSmF4PT10cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SUQpO1xuICAgICAgICAgICAgICAgIHZhciBtYXRoSmF4VGV4dCA9IHRoaXMuZ2V0TWF0aE1MVGV4dChlbGVtZW50SUQpO1xuICAgICAgICAgICAgICAgIHZhciBtYXRoSmF4T2JqZWN0ID0gdGhpcy5nZXRNYXRoTUxPYmplY3QoZWxlbWVudElEKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdGhNTFdpdGhCb29rbWFya3MobWF0aEpheE9iamVjdCwgbWF0aEpheFRleHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG5cblxufTtcbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDA5LzA1LzIwMTYuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFByZWRpY3Rpb257XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY3Vyc2VyPTA7XG4gICAgICAgIC8vIFRoZSBwcm9wZXJ0aWVzIHRoYXQgd2UgY29weSBpbnRvIGEgbWlycm9yZWQgZGl2LlxuICAgICAgICAvLyBOb3RlIHRoYXQgc29tZSBicm93c2Vycywgc3VjaCBhcyBGaXJlZm94LFxuICAgICAgICAvLyBkbyBub3QgY29uY2F0ZW5hdGUgcHJvcGVydGllcywgaS5lLiBwYWRkaW5nLXRvcCwgYm90dG9tIGV0Yy4gLT4gcGFkZGluZyxcbiAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBkbyBldmVyeSBzaW5nbGUgcHJvcGVydHkgc3BlY2lmaWNhbGx5LlxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAnYm94U2l6aW5nJyxcbiAgICAgICAgICAgICd3aWR0aCcsICAvLyBvbiBDaHJvbWUgYW5kIElFLCBleGNsdWRlIHRoZSBzY3JvbGxiYXIsIHNvIHRoZSBtaXJyb3IgZGl2IHdyYXBzIGV4YWN0bHkgYXMgdGhlIHRleHRhcmVhIGRvZXNcbiAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgJ292ZXJmbG93WCcsXG4gICAgICAgICAgICAnb3ZlcmZsb3dZJywgIC8vIGNvcHkgdGhlIHNjcm9sbGJhciBmb3IgSUVcblxuICAgICAgICAgICAgJ2JvcmRlclRvcFdpZHRoJyxcbiAgICAgICAgICAgICdib3JkZXJSaWdodFdpZHRoJyxcbiAgICAgICAgICAgICdib3JkZXJCb3R0b21XaWR0aCcsXG4gICAgICAgICAgICAnYm9yZGVyTGVmdFdpZHRoJyxcblxuICAgICAgICAgICAgJ3BhZGRpbmdUb3AnLFxuICAgICAgICAgICAgJ3BhZGRpbmdSaWdodCcsXG4gICAgICAgICAgICAncGFkZGluZ0JvdHRvbScsXG4gICAgICAgICAgICAncGFkZGluZ0xlZnQnLFxuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICAgICAgICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAgICAgICAnZm9udFZhcmlhbnQnLFxuICAgICAgICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgICAgICAgJ2ZvbnRTdHJldGNoJyxcbiAgICAgICAgICAgICdmb250U2l6ZScsXG4gICAgICAgICAgICAnbGluZUhlaWdodCcsXG4gICAgICAgICAgICAnZm9udEZhbWlseScsXG5cbiAgICAgICAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgICAgICAgJ3RleHRUcmFuc2Zvcm0nLFxuICAgICAgICAgICAgJ3RleHRJbmRlbnQnLFxuICAgICAgICAgICAgJ3RleHREZWNvcmF0aW9uJywgIC8vIG1pZ2h0IG5vdCBtYWtlIGEgZGlmZmVyZW5jZSwgYnV0IGJldHRlciBiZSBzYWZlXG5cbiAgICAgICAgICAgICdsZXR0ZXJTcGFjaW5nJyxcbiAgICAgICAgICAgICd3b3JkU3BhY2luZydcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBzZXRFZGl0Q29udHJvbChlbGVtZW50KXtcbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT0gXCJURVhUQVJFQVwiIHx8XG4gICAgICAgICAgICAoZWxlbWVudC5ub2RlTmFtZSA9PSBcIklOUFVUXCIgJiYgZWxlbWVudC50eXBlLnRvTG93ZXJDYXNlKCkgPT0gXCJ0ZXh0XCIpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xFZGl0ID0gZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuY3Vyc2VyPWVsZW1lbnQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hhciA9IHRoaXMuZ2V0Q3VycmVudENoYXJhY3RlcigpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmN1cnNlciAsdGhpcy5jdXJzZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNFZGl0YWJsZSgpe1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuY29udHJvbEVkaXQpPT1cInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xFZGl0Lm5vZGVOYW1lID09IFwiVEVYVEFSRUFcIiB8fFxuICAgICAgICAgICAgICAgICh0aGlzLmNvbnRyb2xFZGl0Lm5vZGVOYW1lID09IFwiSU5QVVRcIiAmJiB0aGlzLmNvbnRyb2xFZGl0LnR5cGUudG9Mb3dlckNhc2UoKSA9PSBcInRleHRcIikpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXRTZW50ZW5jZSAgKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jdXJzZXIgPSB0aGlzLmNvbnRyb2xFZGl0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKXtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbCwgd29yZCA9IFwiXCI7XG4gICAgICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIChzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkpLm1vZGlmeSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWwuZ2V0UmFuZ2VBdCgwKTtcblxuICAgICAgICAgICAgc2VsLmNvbGxhcHNlVG9TdGFydCgpO1xuXG4gICAgICAgICAgICBpZiAoKHRoaXMuY3VycmVudENoYXIuY2hhckNvZGVBdCgwKSA9PSAzMikgfHwgKHRoaXMuY3VycmVudENoYXIuY2hhckNvZGVBdCgwKSA9PSAxNjApKSB7XG4gICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImJhY2t3YXJkXCIsIFwic2VudGVuY2Vib3VuZGFyeVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJleHRlbmRcIiwgXCJiYWNrd2FyZFwiLCBcInNlbnRlbmNlYm91bmRhcnlcIik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgd29yZCA9IHNlbC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHNlbGVjdGlvblxuICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHNlbGVjdGVkUmFuZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKChzZWwgPSBkb2N1bWVudC5zZWxlY3Rpb24pICYmIHNlbC50eXBlICE9IFwiQ29udHJvbFwiKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWwuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UuZXhwYW5kKFwic2VudGVuY2VcIik7XG4gICAgICAgICAgICB3b3JkID0gcmFuZ2UudGV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyAoXCJjdXJzZXIgXCIgK3RoaXMuY3Vyc2VyKTtcbiAgICAgICAgdGhpcy5jb250cm9sRWRpdC5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmN1cnNlciAsdGhpcy5jdXJzZXIpO1xuICAgICAgICByZXR1cm4gd29yZDtcbiAgICB9XG5cblxuICAgIGdldFBvc2l0aW9uT2ZQb3B1cCgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNvbnRyb2xFZGl0O1xuICAgICAgICBpZiAodHlwZW9mKGVsZW1lbnQpPT1cInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIHJldHVybiB7XCJ0b3BcIjotMTAwICxcImxlZnRcIjotMTAwfVxuICAgICAgICB9XG4gICAgICAgIHZhciBmb250U2l6ZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJyk7XG5cbi8vICAgICAgICB2YXIgcmVjdCA9IHRoaXMucGxhY2VIb2xkZXI7XG4vL1xuLy8gICAgICAgIHJlY3Quc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xFZGl0Lm5vZGVOYW1lID09IFwiVEVYVEFSRUFcIiB8fFxuICAgICAgICAgICAgKHRoaXMuY29udHJvbEVkaXQubm9kZU5hbWUgPT0gXCJJTlBVVFwiICYmIHRoaXMuY29udHJvbEVkaXQudHlwZS50b0xvd2VyQ2FzZSgpID09IFwidGV4dFwiKSkge1xuXG5cbiAgICAgICAgICAgIC8vdmFyIGNvb3JkaW5hdGVzID0gR2V0U2NyZWVuQ29yZGluYXRlcyhlbGVtZW50KTtcblxuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gdGhpcy5nZXRDYXJldENvb3JkaW5hdGVzKGVsZW1lbnQsIGVsZW1lbnQuc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgIHRoaXMuY3Vyc2VyPWVsZW1lbnQuc2VsZWN0aW9uRW5kO1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgICAgICB0aGlzLkdldE9mZnNldChlbGVtZW50LCBvZmZzZXQpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm9mZnNldCAtPiBcIiArIG9mZnNldC55ICsgXCIgLSBcIiArIG9mZnNldC54KTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJFbGVtZW50IFBvc2l0aW9uIDogXCIgKyBjb29yZGluYXRlcy50b3AgKyBcIiAvIFwiICsgY29vcmRpbmF0ZXMubGVmdCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVsZW1lbnQgU2Nyb2xsIDogXCIgKyBlbGVtZW50LnNjcm9sbFRvcCArIFwiIC8gXCIgKyBlbGVtZW50LnNjcm9sbExlZnQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJFbGVtZW50IG9mZnNldCA6IFwiICsgZWxlbWVudC5vZmZzZXRUb3AgKyBcIiAvIFwiICsgZWxlbWVudC5vZmZzZXRMZWZ0KTtcblxuXG4gICAgICAgICAgICB2YXIgdG9wID0gb2Zmc2V0LnkgLSBlbGVtZW50LnNjcm9sbFRvcCArIGNvb3JkaW5hdGVzLnRvcCArIHBhcnNlSW50KGZvbnRTaXplKSArIDQgKyAncHgnO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBvZmZzZXQueCAtIGVsZW1lbnQuc2Nyb2xsTGVmdCArIGNvb3JkaW5hdGVzLmxlZnQgKyAxMCArICdweCc7XG4gICAgICAgICAgICByZXR1cm4ge1widG9wXCI6dG9wICxcImxlZnRcIjpsZWZ0fTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgcmVjdC5zdHlsZS50b3AgPSBlbGVtZW50Lm9mZnNldFRvcFxuICAgICAgICAgICAgIC0gZWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgICArIGNvb3JkaW5hdGVzLnRvcCArIHBhcnNlSW50KGZvbnRTaXplKSArIDEwXG4gICAgICAgICAgICAgKyAncHgnO1xuXG4gICAgICAgICAgICAgcmVjdC5zdHlsZS5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0XG4gICAgICAgICAgICAgLSBlbGVtZW50LnNjcm9sbExlZnRcbiAgICAgICAgICAgICArIGNvb3JkaW5hdGVzLmxlZnRcbiAgICAgICAgICAgICArICdweCc7Ki9cblxuICAgICAgICAgLy8gICBjb25zb2xlLmxvZyhcIkVsZW1lbnQgRmluYWwgUG9zaXRpb24gOiBcIiArIHJlY3Quc3R5bGUudG9wICsgXCIgLyBcIiArIHJlY3Quc3R5bGUubGVmdCk7XG4gICAgICAgIH1cbi8vICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZ2V0U2VsZWN0aW9uQ29vcmRzKCk7XG4vL1xuLy8gICAgICAgICAgICByZWN0LnN0eWxlLnRvcCA9IGNvb3JkaW5hdGVzLnRvcCArIHBhcnNlSW50KGZvbnRTaXplKSArIDEwICsgKDM1KVxuLy8gICAgICAgICAgICAgICAgKyAncHgnO1xuLy8gICAgICAgICAgICByZWN0LnN0eWxlLmxlZnQgPSBjb29yZGluYXRlcy5sZWZ0XG4vLyAgICAgICAgICAgICAgICArICdweCc7XG4vLyAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1widG9wXCI6LTEwMCAsXCJsZWZ0XCI6LTEwMH1cbiAgICB9XG5cbiAgICBHZXRPZmZzZXQob2JqZWN0LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFvYmplY3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG9mZnNldC54ICs9IG9iamVjdC5vZmZzZXRMZWZ0O1xuICAgICAgICBvZmZzZXQueSArPSBvYmplY3Qub2Zmc2V0VG9wO1xuXG4gICAgICAgIHRoaXMuR2V0T2Zmc2V0KG9iamVjdC5vZmZzZXRQYXJlbnQsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgZ2V0Q2FyZXRDb29yZGluYXRlcyAgKGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIC8vIG1pcnJvcmVkIGRpdlxuICAgICAgIHZhciBtaXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50Lm5vZGVOYW1lICsgJy0tbWlycm9yLWRpdicpO1xuICAgICAgICBpZiAoIW1pcnJvckRpdikge1xuICAgICAgICAgICAgbWlycm9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBtaXJyb3JEaXYuaWQgPSBlbGVtZW50Lm5vZGVOYW1lICsgJy0tbWlycm9yLWRpdic7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1pcnJvckRpdik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3R5bGUgPSBtaXJyb3JEaXYuc3R5bGU7XG4gICAgICAgIHZhciBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICAgICAgLy8gZGVmYXVsdCB0ZXh0YXJlYSBzdHlsZXNcbiAgICAgICAgc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gICAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICE9PSAnSU5QVVQnKVxuICAgICAgICAgICAgc3R5bGUud29yZFdyYXAgPSAnYnJlYWstd29yZCc7ICAvLyBvbmx5IGZvciB0ZXh0YXJlYS1zXG5cbiAgICAgICAgLy8gcG9zaXRpb24gb2ZmLXNjcmVlblxuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ICAvLyByZXF1aXJlZCB0byByZXR1cm4gY29vcmRpbmF0ZXMgcHJvcGVybHlcbiAgICAgICAgc3R5bGUudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgKyBwYXJzZUludChjb21wdXRlZC5ib3JkZXJUb3BXaWR0aCkgKyAncHgnO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gXCI0MDBweFwiO1xuICAgICAgICBzdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgLy8gdHJhbnNmZXIgdGhlIGVsZW1lbnQncyBwcm9wZXJ0aWVzIHRvIHRoZSBkaXZcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHN0eWxlW3Byb3BdID0gY29tcHV0ZWRbcHJvcF07XG4gICAgICAgIH0pO1xuLy9cbi8vICAgICAgICBpZiAoaXNGaXJlZm94KSB7XG4vLyAgICAgICAgICAgIHN0eWxlLndpZHRoID0gcGFyc2VJbnQoY29tcHV0ZWQud2lkdGgpIC0gMiArICdweCcgIC8vIEZpcmVmb3ggYWRkcyAyIHBpeGVscyB0byB0aGUgcGFkZGluZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc1MzY2MlxuLy8gICAgICAgICAgICAvLyBGaXJlZm94IGxpZXMgYWJvdXQgdGhlIG92ZXJmbG93IHByb3BlcnR5IGZvciB0ZXh0YXJlYXM6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTk4NDI3NVxuLy8gICAgICAgICAgICBpZiAoZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBwYXJzZUludChjb21wdXRlZC5oZWlnaHQpKVxuLy8gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3dZID0gJ3Njcm9sbCc7XG4vLyAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJzsgIC8vIGZvciBDaHJvbWUgdG8gbm90IHJlbmRlciBhIHNjcm9sbGJhcjsgSUUga2VlcHMgb3ZlcmZsb3dZID0gJ3Njcm9sbCdcbi8vICAgICAgICB9XG4gICAgICAgIHN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIG1pcnJvckRpdi50ZXh0Q29udGVudCA9IGVsZW1lbnQudmFsdWUuc3Vic3RyaW5nKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgLy8gdGhlIHNlY29uZCBzcGVjaWFsIGhhbmRsaW5nIGZvciBpbnB1dCB0eXBlPVwidGV4dFwiIHZzIHRleHRhcmVhOiBzcGFjZXMgbmVlZCB0byBiZSByZXBsYWNlZCB3aXRoIG5vbi1icmVha2luZyBzcGFjZXMgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzQwMjAzNS8xMjY5MDM3XG4gICAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSU5QVVQnKVxuICAgICAgICAgICAgbWlycm9yRGl2LnRleHRDb250ZW50ID0gbWlycm9yRGl2LnRleHRDb250ZW50LnJlcGxhY2UoL1xccy9nLCBcIlxcdTAwYTBcIik7XG5cbiAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIC8vIFdyYXBwaW5nIG11c3QgYmUgcmVwbGljYXRlZCAqZXhhY3RseSosIGluY2x1ZGluZyB3aGVuIGEgbG9uZyB3b3JkIGdldHNcbiAgICAgICAgLy8gb250byB0aGUgbmV4dCBsaW5lLCB3aXRoIHdoaXRlc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSBiZWZvcmUgKCM3KS5cbiAgICAgICAgLy8gVGhlICAqb25seSogcmVsaWFibGUgd2F5IHRvIGRvIHRoYXQgaXMgdG8gY29weSB0aGUgKmVudGlyZSogcmVzdCBvZiB0aGVcbiAgICAgICAgLy8gdGV4dGFyZWEncyBjb250ZW50IGludG8gdGhlIDxzcGFuPiBjcmVhdGVkIGF0IHRoZSBjYXJldCBwb3NpdGlvbi5cbiAgICAgICAgLy8gZm9yIGlucHV0cywganVzdCAnLicgd291bGQgYmUgZW5vdWdoLCBidXQgd2h5IGJvdGhlcj9cbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGVsZW1lbnQudmFsdWUuc3Vic3RyaW5nKHBvc2l0aW9uKSB8fCAnLic7ICAvLyB8fCBiZWNhdXNlIGEgY29tcGxldGVseSBlbXB0eSBmYXV4IHNwYW4gZG9lc24ndCByZW5kZXIgYXQgYWxsXG4gICAgICAgIHNwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJsaWdodGdyZXlcIjtcbiAgICAgICAgbWlycm9yRGl2LmFwcGVuZENoaWxkKHNwYW4pO1xuXG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgIHRvcDogc3Bhbi5vZmZzZXRUb3AgKyBwYXJzZUludChjb21wdXRlZFsnYm9yZGVyVG9wV2lkdGgnXSksXG4gICAgICAgICAgICBsZWZ0OiBzcGFuLm9mZnNldExlZnQgKyBwYXJzZUludChjb21wdXRlZFsnYm9yZGVyTGVmdFdpZHRoJ10pXG4gICAgICAgIH07XG5cbiAgICAgICAgLy9hbGVydChjb29yZGluYXRlcy50b3AgKyBcIiBcIiArIGNvb3JkaW5hdGVzLmxlZnQpO1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgfVxuXG5cblxuICAgIHNldFNlbGVjdGlvblJhbmdlICAoaW5wdXQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgaWYgKGlucHV0LnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQuY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgc2VsZWN0aW9uRW5kKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHNldENhcmV0UG9zaXRpb24gIChlbGVtLCBjYXJldFBvcykge1xuXG4gICAgICAgIGlmIChlbGVtICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLmNyZWF0ZVRleHRSYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IGVsZW0uY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UubW92ZSgnY2hhcmFjdGVyJywgY2FyZXRQb3MpO1xuICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0uc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnNldFNlbGVjdGlvblJhbmdlKGNhcmV0UG9zLCBjYXJldFBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5zZXJ0VGV4dCAgKCBuZXdUZXh0KSB7XG5cbiAgICAgICAgdmFyIGVsID0gdGhpcy5jb250cm9sRWRpdDtcblxuXG4gICAgICAgIC8vdmFyIGN1cnJlbnRQb3NpdGlvbiA9IDA7XG5cbiAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT0gXCJESVZcIikge1xuXG4gICAgICAgICAgICBlbC5mb2N1cygpO1xuXG4gICAgICAgICAgICB2YXIgcndQcmVkaWN0aW9uUG9zaXRpb25FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3J3UHJlZGljdGlvblBvc2l0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLnNldENhcmV0UG9zaXRpb25EaXYoY3VycmVudENvbnRleHRDb250cm9sSUQpO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShlbCwgcndQcmVkaWN0aW9uUG9zaXRpb25FbGVtZW50LnZhbHVlLCByd1ByZWRpY3Rpb25Qb3NpdGlvbkVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hhciA9IHRoaXMuZ2V0Q3VycmVudENoYXJhY3RlcigpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0ZWRUZXh0KG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5DdXJyZW50UG9zaXRpb24gPSBlbC5zZWxlY3Rpb25TdGFydDtcblxuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShlbCwgdGhpcy5DdXJyZW50UG9zaXRpb24sIHRoaXMuQ3VycmVudFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hhciA9IHRoaXMuZ2V0Q3VycmVudENoYXJhY3RlcigpO1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZShlbCwgdGhpcy5DdXJyZW50UG9zaXRpb24sIHRoaXMuQ3VycmVudFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0ZWRUZXh0KG5ld1RleHQpO1xuXG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblJhbmdlKGVsLCB0aGlzLkN1cnJlbnRQb3NpdGlvbiwgdGhpcy5DdXJyZW50UG9zaXRpb24pO1xuXG4gICAgICAgICAgICB0aGlzLnNldENhcmV0UG9zaXRpb24oZWwsIHRoaXMuQ3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG5cblxuXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgZ2V0Q3VycmVudENoYXJhY3RlciAgKCkge1xuICAgICAgICB2YXIgc2VsLCB3b3JkID0gXCJcIjtcbiAgICAgICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgKHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSkubW9kaWZ5KSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlVG9TdGFydCgpO1xuICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJiYWNrd2FyZFwiLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJleHRlbmRcIiwgXCJmb3J3YXJkXCIsIFwiY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgLy9zZWwubW9kaWZ5KFwiZXh0ZW5kXCIsIFwiYmFja3dhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG5cbiAgICAgICAgICAgIHdvcmQgPSBzZWwudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgLy8gUmVzdG9yZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIHNlbC5hZGRSYW5nZShzZWxlY3RlZFJhbmdlKTtcbiAgICAgICAgfSBlbHNlIGlmICgoc2VsID0gZG9jdW1lbnQuc2VsZWN0aW9uKSAmJiBzZWwudHlwZSAhPSBcIkNvbnRyb2xcIikge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlLmV4cGFuZChcIndvcmRcIik7XG4gICAgICAgICAgICB3b3JkID0gcmFuZ2UudGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZDtcbiAgICB9XG5cbiAgICByZXBsYWNlU2VsZWN0ZWRUZXh0ICAocmVwbGFjZW1lbnRUZXh0KSB7XG4gICAgICAgIHZhciBzZWwsIHJhbmdlLCBiZWdpbm5pbmdMaW5lID0gZmFsc2U7XG4gICAgICAgIHJlcGxhY2VtZW50VGV4dCArPSBcIiBcIjtcblxuICAgICAgICB2YXIgbW92ZUNvdW50ID0gMDtcblxuICAgICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgICAgICAgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQubm9kZU5hbWUgPT0gXCJURVhUQVJFQVwiIHx8XG4gICAgICAgICAgICAgICAgKGFjdGl2ZUVsZW1lbnQubm9kZU5hbWUgPT0gXCJJTlBVVFwiICYmIGFjdGl2ZUVsZW1lbnQudHlwZS50b0xvd2VyQ2FzZSgpID09IFwidGV4dFwiKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc2VyPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmN1cnJlbnRDaGFyLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2MzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudFRleHQgPSBcIiBcIiArIHJlcGxhY2VtZW50VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2MDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmNvbGxhcHNlVG9TdGFydCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWwubW9kaWZ5KFwibW92ZVwiLCBcImJhY2t3YXJkXCIsIFwid29yZFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdvcmQgaGFzIGEgLSwgaWYgc28gd2UgbmVlZCB0byBnbyBiYWNrIG9uZSBtb3JlIHdvcmQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJiYWNrd2FyZFwiLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBcImJhY2t3YXJkXCIsIFwiY2hhcmFjdGVyXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3b3JkID0gc2VsLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod29yZCA9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBcImZvcndhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJleHRlbmRcIiwgXCJmb3J3YXJkXCIsIFwiY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJiYWNrd2FyZFwiLCBcIndvcmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJleHRlbmRcIiwgXCJmb3J3YXJkXCIsIFwid29yZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWwubW9kaWZ5KFwiZXh0ZW5kXCIsIFwiZm9yd2FyZFwiLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmNvbGxhcHNlVG9TdGFydCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJiYWNrd2FyZFwiLCBcIndvcmRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwubW9kaWZ5KFwiZXh0ZW5kXCIsIFwiZm9yd2FyZFwiLCBcIndvcmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJ3b3JkXCIpO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmNvbGxhcHNlVG9TdGFydCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJiYWNrd2FyZFwiLCBcIndvcmRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3b3JkIGhhcyBhIC0sIGlmIHNvIHdlIG5lZWQgdG8gZ28gYmFjayBvbmUgbW9yZSB3b3JkP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIFwiYmFja3dhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd29yZCA9IHNlbC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQgPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGN1cnNvciBwb3NpdGlvbiB0byB0aGUgcHJldmlvdXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJleHRlbmRcIiwgXCJiYWNrd2FyZFwiLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJmb3J3YXJkXCIsIFwiY2hhcmFjdGVyXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIFwiYmFja3dhcmRcIiwgXCJ3b3JkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwubW9kaWZ5KFwiZXh0ZW5kXCIsIFwiZm9yd2FyZFwiLCBcIndvcmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJleHRlbmRcIiwgXCJmb3J3YXJkXCIsIFwid29yZFwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh3b3JkLmNoYXJDb2RlQXQoMCkgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGN1cnNvciBwb3NpdGlvbiB0byB0aGUgcHJldmlvdXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImJhY2t3YXJkXCIsIFwiY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBcImZvcndhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJ3b3JkXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZCA9IHNlbC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQuc3Vic3RyKHdvcmQubGVuZ3RoIC0gMSwgMSkgPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJ3b3JkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQgPSBzZWwudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiV2luXCIpICE9IC0xKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQuc3Vic3RyKHdvcmQubGVuZ3RoIC0gMSwgMSkgPT0gXCIgXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJleHRlbmRcIiwgXCJiYWNrd2FyZFwiLCBcImNoYXJhY3RlclwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRUZXh0ID0gcmVwbGFjZW1lbnRUZXh0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZCA9IHNlbC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdleCA9IC9eWzAtOWEtekEtWl0rJC87XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3b3JkLnN1YnN0cih3b3JkLmxlbmd0aCAtIDEsIDEpLm1hdGNoKHJlZ2V4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImJhY2t3YXJkXCIsIFwiY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRUZXh0ID0gcmVwbGFjZW1lbnRUZXh0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gYWN0aXZlRWxlbWVudC52YWx1ZSwgc3RhcnQgPSBhY3RpdmVFbGVtZW50LnNlbGVjdGlvblN0YXJ0LCBlbmQgPSBhY3RpdmVFbGVtZW50LnNlbGVjdGlvbkVuZDtcblxuICAgICAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiV2luXCIpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWdub3JlIHRoaXMgZm9yIHdpbmRvdy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWlnaHQgbmVlZCB0byBhZGQgZnVydGhlciBoYW5kbGluZ1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbC5zbGljZShlbmQpLnN1YnN0cigwLCAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudFRleHQgPSByZXBsYWNlbWVudFRleHQudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVDb3VudCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiO1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIjpcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLlwiOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRUZXh0ID0gcmVwbGFjZW1lbnRUZXh0LnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudC52YWx1ZSA9IHZhbC5zbGljZSgwLCBzdGFydCkgKyByZXBsYWNlbWVudFRleHQgKyB2YWwuc2xpY2UoZW5kKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuQ3VycmVudFBvc2l0aW9uID0gc3RhcnQgKyAocmVwbGFjZW1lbnRUZXh0Lmxlbmd0aCkgKyBtb3ZlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAvL2FsZXJ0KFwiaW4gdGV4dCBhcmVhXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2FyZXRQb3NpdGlvbkRpdihhY3RpdmVFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5jdXJyZW50Q2hhci5jaGFyQ29kZUF0KDApID09IDMyKSB8fCAodGhpcy5jdXJyZW50Q2hhci5jaGFyQ29kZUF0KDApID09IDE2MCkpIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJiYWNrd2FyZFwiLCBcIndvcmRcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd29yZCBoYXMgYSAtLCBpZiBzbyB3ZSBuZWVkIHRvIGdvIGJhY2sgb25lIG1vcmUgd29yZD9cbiAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJiYWNrd2FyZFwiLCBcImNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmQgPSBzZWwudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAod29yZCA9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGN1cnNvciBwb3NpdGlvbiB0byB0aGUgcHJldmlvdXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwubW9kaWZ5KFwiZXh0ZW5kXCIsIFwiYmFja3dhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBcImZvcndhcmRcIiwgXCJjaGFyYWN0ZXJcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIFwiYmFja3dhcmRcIiwgXCJ3b3JkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJ3b3JkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJ3b3JkXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod29yZC5jaGFyQ29kZUF0KDApID09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgY3Vyc29yIHBvc2l0aW9uIHRvIHRoZSBwcmV2aW91cyBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImJhY2t3YXJkXCIsIFwiY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgXCJmb3J3YXJkXCIsIFwiY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsLm1vZGlmeShcImV4dGVuZFwiLCBcImZvcndhcmRcIiwgXCJ3b3JkXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWwucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJlcGxhY2VtZW50VGV4dCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbC5kZWxldGVGcm9tRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGFjdGl2ZUVsZW1lbnQudmFsdWUsIHN0YXJ0ID0gYWN0aXZlRWxlbWVudC5zZWxlY3Rpb25TdGFydCwgZW5kID0gYWN0aXZlRWxlbWVudC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudC52YWx1ZSA9IHZhbC5zbGljZSgwLCBzdGFydCkgKyByZXBsYWNlbWVudFRleHQgKyB2YWwuc2xpY2UoZW5kKTtcblxuICAgICAgICAgICAgICAgIHNldENhcmV0UG9zaXRpb25EaXYoYWN0aXZlRWxlbWVudCwgc3RhcnQgKyAocmVwbGFjZW1lbnRUZXh0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UpIHtcbiAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS50ZXh0ID0gcmVwbGFjZW1lbnRUZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgICBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICAgIHZhciB0ZXh0Q29tcG9uZW50ID0gdGhpcy5jb250cm9sRWRpdDtcbiAgICAgICAgdmFyIHNlbGVjdGVkVGV4dDtcbiAgICAgICAgLy8gSUUgdmVyc2lvblxuICAgICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGV4dENvbXBvbmVudC5mb2N1cygpO1xuICAgICAgICAgICAgdmFyIHNlbCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgc2VsZWN0ZWRUZXh0ID0gc2VsLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTW96aWxsYSB2ZXJzaW9uXG4gICAgICAgIGVsc2UgaWYgKHRleHRDb21wb25lbnQuc2VsZWN0aW9uU3RhcnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0ZXh0Q29tcG9uZW50LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgdmFyIGVuZFBvcyA9IHRleHRDb21wb25lbnQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgc2VsZWN0ZWRUZXh0ID0gdGV4dENvbXBvbmVudC52YWx1ZS5zdWJzdHJpbmcoc3RhcnRQb3MsIGVuZFBvcylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRUZXh0O1xuICAgIH1cbn1cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDIwLzA0LzIwMTYuXG4gKi9cbmltcG9ydCB7U1NET019IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL1NTRE9NJ1xuaW1wb3J0IHtFdmVudEJ1c30gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9FdmVudHMvRXZlbnRCdXMnXG5cbmV4cG9ydCBjbGFzcyBTY3JvbGxJblRvVmlld3tcbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuXG4gICAgfVxuXG4gICAgLy9TY3JvbGwgYnJvd3NlciBzY3JlZW4gdG8gbm9kZS5cbi8vIHRvZG8gTm90ZSB0aGF0IHRoaXMgaXMgbWFraW5nIGFzc3VtcHRpb24gdGhhdCBhIGRpdiBpbnNpZGUgYSBkaXYgb3IgZGl2IGluc2lkZSBhIHBhZ2UgaXMgc21hbGxlciB0aGFuIHRoZSBjb250YWluZXJcbi8vIHNvIGVuc3VyZXMgdGhhdCB0aGUgZGl2IGlzIGluIHRoZSBjb250YWluZXJzIHZpZXdhYmxlIGFyZWEuXG4vLyBUaGUgYWJvdmUgaGFzIG5vdCBiZWVuIHB1dCBpbiBwbGFjZSB5ZXQsIGFzIHdvdWxkIG5lZWQgbG90IG9mIHRlc3RpbmdcblxuICAgIHJ3X3Njcm9sbFRvT2JqZWN0KHBfbm9kZSlcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgJGdfYk1vdXNlU3BlZWNoID0gZmFsc2U7XG4vLyAgICAgICAgaWYodHlwZW9mKGViYV9ub19zY3JvbGwpID09IFwiYm9vbGVhblwiICYmIGViYV9ub19zY3JvbGwpXG4vLyAgICAgICAge1xuLy8gICAgICAgICAgICByZXR1cm47XG4vLyAgICAgICAgfVxuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRoZVdpbmRvdyA9IHNzZG9tLmdldFdpbmRvdyhwX25vZGUpO1xuXG4gICAgICAgICAgICBpZih0aGVXaW5kb3cgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHBfbm9kZSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgcF9ub2RlLnBhcmVudE5vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgICAgdmFyIG9iaiA9IHBfbm9kZTtcbiAgICAgICAgICAgIGlmKG9iai5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBtb3ZlIHVwIGZyb20gYSBkaXYgbmVlZCB0byBzdG9yZSB0aGUgb2Zmc2V0IGluIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlIGRpdiB0byBjb3ZlciB0aGUgY2FzZVxuICAgICAgICAgICAgLy8gb2YgYSBzY3JvbGxpbmcgZGl2IHRoYXQgaXMgbGFyZ2VyIHRoYW4gcGFnZSBoZWlnaHQsIG5lZWQgdG8gYm90aCBzY3JvbGwgZGl2IGludG8gdmlldyBhbmQgcGFydCBvZiBkaXZcbiAgICAgICAgICAgIC8vIG5lZWRlZCBpbnRvIHZpZXcuXG4gICAgICAgICAgICB2YXIgZGl2T2Zmc2V0T2JqID0gbnVsbDtcblxuICAgICAgICAgICAgLy9kbyBjaGVjayB0byBzZWUgaWYgaW5zaWRlIGEgc2Nyb2xsYWJsZSBkaXYgIG9yIGEgc2Nyb2xsYWJsZSBmb3JtXG4gICAgICAgICAgICB2YXIgcGFyZW50VGVzdCA9IG9iajtcbiAgICAgICAgICAgIHZhciB0bXBCb2R5ID0gb2JqLm93bmVyRG9jdW1lbnQuYm9keTtcblxuICAgICAgICAgICAgdmFyIGJTY3JvbGxlZERpdiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHN0b3JlZE1hdGNoT2JqID0gbnVsbDtcblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERpdiBjaGVja2luZ1xuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgd2hpbGUocGFyZW50VGVzdCAhPSBudWxsICYmIHBhcmVudFRlc3QgIT0gdG1wQm9keSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihwYXJlbnRUZXN0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImRpdlwiIHx8IHBhcmVudFRlc3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwiZm9ybVwiKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGlmIGl0IGlzIHNjcm9sbGFibGUgZGl2XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMucndfaXNEaXZTY3JvbGxhYmxlKHBhcmVudFRlc3QpKVxuICAgICAgICAgICAgICAgICAgICB7Ly8gSVMgc2Nyb2xsYWJsZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBiU2Nyb2xsZWREaXYgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZPZmZzZXRPYmogPSB0aGlzLnJ3X3Njcm9sbFRvT2JqZWN0RGl2Q2hlY2sob2JqLCBwYXJlbnRUZXN0LCBkaXZPZmZzZXRPYmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRNYXRjaE9iaiA9IHBhcmVudFRlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBwYXJlbnRUZXN0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b2RvIGNoZWNrIGZvciBuZXN0ZWQgZGl2cyBvZiBkaWZmZXJlbnQgdHlwZXMgdG8gY2hlY2sgZm9yIGNhc2Ugd2hlcmUgZXZlbiBmb3Igc2Vjb25kIHNjcm9sbGluZyBkaXYgaW4gbmVlZHMgb3JpZyBvYmplY3Qgb2Zmc2V0IHJhdGhlciB0aGFuIGRpdiBpdCBpcyBpbi5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50VGVzdCA9IHBhcmVudFRlc3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoc3RvcmVkTWF0Y2hPYmogIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvYmogPSBzdG9yZWRNYXRjaE9iajtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGVuZCBvZiBkaXYgY2hlY2tpbmdcbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBzY3JvbGxpbmcgaW4gYm9keVxuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgd2hpbGUgKG9iaiAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHggKz0gb2JqLm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgeSArPSBvYmoub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5vZmZzZXRQYXJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGRpdk9mZnNldE9iaiAhPSBudWxsKVxuICAgICAgICAgICAgeyAgIC8vIHNjcm9sbGVkIGluIGEgZGl2XG4gICAgICAgICAgICAgICAgeSArPSBkaXZPZmZzZXRPYmoueTtcbiAgICAgICAgICAgICAgICB4ICs9IGRpdk9mZnNldE9iai54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2NyZWVuTGVmdDtcbiAgICAgICAgICAgIHZhciBzY3JlZW5Ub3A7XG4gICAgICAgICAgICB2YXIgc2NyZWVuV2lkdGg7XG4gICAgICAgICAgICB2YXIgc2NyZWVuSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIG5XaWR0aE9mZnNldCA9IDMwO1xuXG4gICAgICAgICAgICBpZiAocF9ub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7ICAgLy8gbWFrZSBhIGd1ZXNzIGF0IHdpZHRoLCBkb2Vzbid0IG5lZWQgdG8gYmUgdG9vIHByZWNpc2UuIChvciByYXRoZXIgZWZmb3J0IHRvIG1ha2UgcHJlY2lzZSBub3Qgd29ydGggcmVzdWx0KVxuICAgICAgICAgICAgICAgIG5XaWR0aE9mZnNldCA9IDEwICsgNSAqIHBfbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChuV2lkdGhPZmZzZXQgPiA2MClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5XaWR0aE9mZnNldCA9IDYwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NyZWVuTGVmdCA9IHRoaXMucndfZ2V0U2NyZWVuT2Zmc2V0TGVmdCh0aGVXaW5kb3cpO1xuICAgICAgICAgICAgc2NyZWVuVG9wID0gdGhpcy5yd19nZXRTY3JlZW5PZmZzZXRUb3AodGhlV2luZG93KTtcblxuICAgICAgICAgICAgaWYodHlwZW9mKCB0aGVXaW5kb3cuaW5uZXJXaWR0aCApID09ICdudW1iZXInKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNjcmVlbldpZHRoID0gdGhlV2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgc2NyZWVuSGVpZ2h0ID0gdGhlV2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih0aGVXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA+IDAgJiZcbiAgICAgICAgICAgICAgICB0aGVXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzY3JlZW5XaWR0aCA9IHRoZVdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgc2NyZWVuSGVpZ2h0ID0gdGhlV2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2NyZWVuV2lkdGggPSB0aGVXaW5kb3cuZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBzY3JlZW5IZWlnaHQgPSB0aGVXaW5kb3cuZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjcmVlbldpZHRoID0gc2NyZWVuV2lkdGggLSBuV2lkdGhPZmZzZXQ7XG4gICAgICAgICAgICBzY3JlZW5IZWlnaHQgPSBzY3JlZW5IZWlnaHQgLSAyMDtcblxuICAgICAgICAgICAgdmFyIGJOZWVkWDtcbiAgICAgICAgICAgIHZhciBiTmVlZFk7XG5cbiAgICAgICAgICAgIGlmKGJTY3JvbGxlZERpdilcbiAgICAgICAgICAgIHsgICAgLy8gY2hlY2sgdGhhdCBhcyBtdWNoIG9mIGRpdiBpcyBpbnNpZGUgdmlldyBhcyBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAvL25vdCBjdXJyZW50bHkgd29ydGggdGltZSBpbnZvbHZlZCB0byBkbyB0aGlzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJOZWVkWCA9ICh4IDwgc2NyZWVuTGVmdCB8fCB4ID4gKHNjcmVlbkxlZnQgKyBzY3JlZW5XaWR0aCkpO1xuICAgICAgICAgICAgYk5lZWRZID0gKHkgPCBzY3JlZW5Ub3AgfHwgeSA+IChzY3JlZW5Ub3AgKyBzY3JlZW5IZWlnaHQpKTtcbiAgICAgICAgICAgIGlmIChiTmVlZFggfHwgYk5lZWRZICYmICh4ICE9IDAgfHwgeSAhPSAwKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoeCA+IChzY3JlZW5MZWZ0ICsgc2NyZWVuV2lkdGgpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9ICh4ICsgc2NyZWVuTGVmdCkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeSA+IChzY3JlZW5Ub3AgKyBzY3JlZW5IZWlnaHQpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9ICh5ICsgc2NyZWVuVG9wKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBiSG92ZXIgPSAkZ19iTW91c2VTcGVlY2g7XG4gICAgICAgICAgICAgICAgaWYoJGdfYk1vdXNlU3BlZWNoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJGdfYk1vdXNlU3BlZWNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBFdmVudEJ1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnB1Ymxpc2goXCJwYXVzZUhvdmVyXCIsbnVsbCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhlV2luZG93LnNjcm9sbFRvKChiTmVlZFg/eDpzY3JlZW5MZWZ0KSwgKGJOZWVkWT95OnNjcmVlblRvcCkpO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIElwYWQgbmVlZCB0byBmb3JjZSB0aGUgc2Nyb2xsIGV2ZW50IGFzIHRoZXkgZGVjaWRlZCBzY3JvbGwgZXZlbnQgbm90IG5lZWRlZCBvbiBpcGFkIHZlcnNpb24gb2Ygc2FmYXJpXG4gICAgICAgICAgICAgICAgdmFyIGdfYlRvdWNoU2NyZWVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYoZ19iVG91Y2hTY3JlZW4pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByd19wb3NpdGlvblRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcndfcG9zaXRpb25BbGxEaXZCYXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgICAgICBpZihiSG92ZXIpXG4gICAgICAgICAgICAgICAge1xuXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goaWdub3JlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpZ25vcmUpO1xuICAgICAgICB9XG4vLyAgICAgICAgZ19iRGlkU2Nyb2xsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLypEaXN0YW5jZSBzY3JlZW4gaXMgc2Nyb2xsZWQgdG8gdGhlIHJpZ2h0Ki9cbiAgICByd19nZXRTY3JlZW5PZmZzZXRMZWZ0KHBfd2luZG93KVxuICAgIHtcbiAgICAgICAgaWYodHlwZW9mKHBfd2luZG93KSA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB7XG4gICAgICAgICAgICBwX3dpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV2ZW4gaWYgbm90IHN1cHBvcnRlZCB0aGVzZSBzdGlsbCByZXR1cm4gMCByYXRoZXIgdGhhbiB1bmRlZmluZWQsIHNvIG5lZWQgdG8gdGVzdCBhbGwgZm9yIG5vbiB6ZXJvIGFuZCB1c2UgdGhhdCBpZiBleGlzdHMuXG4gICAgICAgIC8vIGV2ZW4gZmlyZWZveC9jaHJvbWUvc2FmYXJpIGRvIG5vdCBtYXRjaCB1cCBvbiB0aGlzLCBub3QganVzdCBJRSBwcm9ibGVtLlxuXG4gICAgICAgIGlmKHBfd2luZG93LnBhZ2VYT2Zmc2V0ICYmIHBfd2luZG93LnBhZ2VYT2Zmc2V0ID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBfd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYocF93aW5kb3cuZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ICYmIHBfd2luZG93LmRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwX3dpbmRvdy5kb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihwX3dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCAmJiBwX3dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwX3dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKkRpc3RhbmNlIHNjcmVlbiBpcyBzY3JvbGxlZCBkb3duKi9cbiAgICByd19nZXRTY3JlZW5PZmZzZXRUb3AocF93aW5kb3cpXG4gICAge1xuICAgICAgICBpZih0eXBlb2YocF93aW5kb3cpID09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBfd2luZG93ID0gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIC8vIGV2ZW4gaWYgbm90IHN1cHBvcnRlZCB0aGVzZSBzdGlsbCByZXR1cm4gMCByYXRoZXIgdGhhbiB1bmRlZmluZWQsIHNvIG5lZWQgdG8gdGVzdCBhbGwgZm9yIG5vbiB6ZXJvIGFuZCB1c2UgdGhhdCBpZiBleGlzdHMuXG4gICAgICAgIC8vIGV2ZW4gZmlyZWZveC9jaHJvbWUvc2FmYXJpIGRvIG5vdCBtYXRjaCB1cCBvbiB0aGlzLCBub3QganVzdCBJRSBwcm9ibGVtLlxuXG4gICAgICAgIGlmKHBfd2luZG93LnBhZ2VZT2Zmc2V0ICYmIHBfd2luZG93LnBhZ2VZT2Zmc2V0ID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBfd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYocF93aW5kb3cuZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgJiYgcF93aW5kb3cuZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcF93aW5kb3cuZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihwX3dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wICYmIHBfd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcF93aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbi8vIHRvZG8gbW9yZSBhY2N1cmF0ZSBkZXRlcm1pbmF0aW9uIG9mIHNjcmVlbiBzY3JvbGxpbmc/XG4gICAgcndfZ2V0U2NyZWVuT2Zmc2V0TGVmdEFsdChwX3dpbmRvdylcbiAgICB7XG4gICAgICAgIGlmKHR5cGVvZihwX3dpbmRvdykgPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgcF93aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnJlc29sdmVkVmFyaWFibGVcbiAgICAgICAgaWYocF93aW5kb3cuZG9jdW1lbnQuY29tcGF0TW9kZSA9PSBcIkNTUzFDb21wYXRcIiAmJiBwX3dpbmRvdy5kb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgJiYgcF93aW5kb3cuZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbExlZnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5yZXNvbHZlZFZhcmlhYmxlXG4gICAgICAgICAgICByZXR1cm4gcF93aW5kb3cuZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbExlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL25vaW5zcGVjdGlvbiBVbm5lY2Vzc2FyeUxvY2FsVmFyaWFibGVKUyxKU1VucmVzb2x2ZWRWYXJpYWJsZVxuICAgICAgICB2YXIgbiA9IChwX3dpbmRvdy5wYWdlWE9mZnNldClcbiAgICAgICAgICAgID8gcF93aW5kb3cucGFnZVhPZmZzZXRcbiAgICAgICAgICAgIDogKHBfd2luZG93LnNjcm9sbFgpXG4gICAgICAgICAgICA/IHBfd2luZG93LnNjcm9sbFhcbiAgICAgICAgICAgIDogKHBfd2luZG93LmRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdClcbiAgICAgICAgICAgID8gcF93aW5kb3cuZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0XG4gICAgICAgICAgICA6IChwX3dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCk/XG4gICAgICAgICAgICBwX3dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDowO1xuXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGluc2lkZSBhIGRpdiBzb21lIG9mZnNldCBtYXkgbmVlZCB0byBzY3JvbGwgaW5zaWRlIHRoZSBkaXYsIHRoZW4gbmVlZCB0byBzY3JvbGwgb3V0c2lkZSB0aGUgZGl2IHRvIGdldCB0aGUgZGl2XG4gICAgICogaXRzZWxmIGluIHZpZXcuXG4gICAgICovXG4gICAgcndfc2Nyb2xsVG9PYmplY3REaXZDaGVjayhwX25vZGUsIHBfZGl2LCBwX3ByZXZEaXZPZmZzZXRPYmopXG4gICAge1xuICAgICAgICB2YXIgbkRpdk9mZnNldFg7XG4gICAgICAgIHZhciBuRGl2T2Zmc2V0WTtcblxuICAgICAgICB2YXIgbk9iakhlaWdodCA9IHBfZGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIG5PYmpXaWR0aCA9IHBfZGl2LmNsaWVudFdpZHRoO1xuXG4gICAgICAgIHZhciBjbGllbnRSZWN0V2lkdGggPSBwX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgLSBwX25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblxuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgaGF2ZSBzY3JvbGxhYmxlIGRpdiBhbmQgbm9kZSBpbiBpdFxuXG4gICAgICAgIHZhciBuVG1wT2Zmc2V0VG9wID0gMDtcbiAgICAgICAgdmFyIG5UbXBPZmZzZXRMZWZ0ID0gMDtcblxuICAgICAgICAvL0NoZWNrIGlmIHRoZSBub2RlJ3Mgb2Zmc2V0IHBhcmVudCBpcyB0aGUgZGl2IG9yIGluc2lkZSB0aGUgZGl2XG4gICAgICAgIHZhciB0bXBPYmogPSBwX25vZGU7XG4gICAgICAgIHdoaWxlKHRtcE9iaiAhPSBwX2RpdiAmJiB0bXBPYmogIT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgblRtcE9mZnNldFRvcCArPSB0bXBPYmoub2Zmc2V0VG9wO1xuICAgICAgICAgICAgblRtcE9mZnNldExlZnQgKz0gdG1wT2JqLm9mZnNldExlZnQ7XG4gICAgICAgICAgICB0bXBPYmogPSB0aGlzLnJ3X3NhZmVPZmZzZXRQYXJlbnQodG1wT2JqLCBwX2Rpdik7ICAvL3NvIGRvZXMgbm90IHNraXAgb3ZlciBjb250YWluaW5nIGRpdi5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRtcE9iaiA9PSBudWxsKVxuICAgICAgICB7ICAgLy8gYXNzdW1lIGhlcmUgdGhhdCBwX25vZGUgaXMgZGVmaW5pdGVseSBpbnNpZGUgcF9kaXYsIHNvIG9ubHkgaGVyZSBpZiBvZmZzZXRQYXJlbnQgaGlnaGVyIHRoYW4gcF9kaXZcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gcmVkdWNlIHNjcm9sbGluZyBpbiBkaXYgYnkgb2Zmc2V0IG9mIGRpdlxuICAgICAgICAgICAgblRtcE9mZnNldExlZnQgLT0gcF9kaXYub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIG5UbXBPZmZzZXRUb3AgLT0gcF9kaXYub2Zmc2V0VG9wO1xuXG4gICAgICAgICAgICAvLyBzZXQgcmV0dXJuIG9iamVjdCBmb3IgaG93IHRvIHByb2NlZWQuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmKHBfcHJldkRpdk9mZnNldE9iaiAhPSBudWxsKVxuICAgICAgICB7ICAgLy8gaWYgYWxyZWFkeSBzY3JvbGxlZCBhIGRpdiB3aWxsIGdldCBoZXJlXG4gICAgICAgICAgICBuVG1wT2Zmc2V0VG9wICs9IHBfcHJldkRpdk9mZnNldE9iai55O1xuICAgICAgICAgICAgblRtcE9mZnNldExlZnQgKz0gcF9wcmV2RGl2T2Zmc2V0T2JqLng7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3QgaW4gdmlldyBhcmVhIHRoZW4gc2Nyb2xsXG5cbiAgICAgICAgLy8gU2Nyb2xsIFRvcFxuICAgICAgICBpZihwX2Rpdi5zY3JvbGxUb3AgPiBuVG1wT2Zmc2V0VG9wIHx8XG4gICAgICAgICAgICAocF9kaXYuc2Nyb2xsVG9wICsgbk9iakhlaWdodCkgPCAoblRtcE9mZnNldFRvcCArIHBfbm9kZS5vZmZzZXRIZWlnaHQpKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZihuT2JqSGVpZ2h0ID4gKHBfbm9kZS5vZmZzZXRIZWlnaHQgKiA2KSlcbiAgICAgICAgICAgIHsgICAvLyBmb3IgbmFycm93IG9iamVjdCwgYWRkIGEgYml0IG9mIHNwYWNlIGFib3ZlIGl0LlxuICAgICAgICAgICAgICAgIHBfZGl2LnNjcm9sbFRvcCA9IG5UbXBPZmZzZXRUb3AgLSBwX25vZGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBfZGl2LnNjcm9sbFRvcCA9IG5UbXBPZmZzZXRUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTY3JvbGwgbGVmdFxuICAgICAgICBpZihjbGllbnRSZWN0V2lkdGggPCAyMDAmJiAocF9kaXYuc2Nyb2xsTGVmdCA+IG5UbXBPZmZzZXRMZWZ0IHx8XG4gICAgICAgICAgICAocF9kaXYuc2Nyb2xsTGVmdCArIG5PYmpXaWR0aCkgPCAoblRtcE9mZnNldExlZnQgKyBwX25vZGUub2Zmc2V0V2lkdGgpKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcF9kaXYuc2Nyb2xsTGVmdCA9IG5UbXBPZmZzZXRMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBvZmZzZXQgaW4gdGhlIHZpc2libGUgYXJlYSBvZiB0aGUgZGl2ICh0aGlzIG5lZWRlZCB3aGV0aGVyIHNjcm9sbHMgb3Igbm90KVxuICAgICAgICBuRGl2T2Zmc2V0WCA9IG5UbXBPZmZzZXRMZWZ0IC0gcF9kaXYuc2Nyb2xsTGVmdDtcbiAgICAgICAgbkRpdk9mZnNldFkgPSBuVG1wT2Zmc2V0VG9wIC0gcF9kaXYuc2Nyb2xsVG9wO1xuXG4gICAgICAgIHJldHVybiB7eDpuRGl2T2Zmc2V0WCwgeTpuRGl2T2Zmc2V0WX07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUbyBhbGxvdyBzYWZlIHJldHJpZXZhbCBvZiBvZmZzZXQgcGFyZW50LiAgVGhpcyB3aWxsIGNoZWNrIHRoYXQgaXQgaXMgbm90IHNraXBwZWQgb3Zlci5cbiAgICAgKiBAcGFyYW0gcF9vYmpcbiAgICAgKi9cbiAgICByd19zYWZlT2Zmc2V0UGFyZW50KHBfb2JqLCBwX2VuZE5vZGUpXG4gICAge1xuICAgICAgICB2YXIgc3RhcnRPYmogPSBwX29iajtcbiAgICAgICAgdmFyIGVuZE9iaiA9IHN0YXJ0T2JqLm9mZnNldFBhcmVudDtcbiAgICAgICAgaWYoZW5kT2JqID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocF9lbmROb2RlID09IG51bGwpXG4gICAgICAgIHsgICAvLyBubyBmdXJ0aGVyIGNoZWNrIG5lZWRlZFxuICAgICAgICAgICAgcmV0dXJuIGVuZE9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IGVuZCBub2RlIGlzIG5vdCBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmRcblxuICAgICAgICB3aGlsZShzdGFydE9iaiAhPSBudWxsICYmIHN0YXJ0T2JqICE9IGVuZE9iailcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoc3RhcnRPYmogPT0gcF9lbmROb2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIG5vIG9mZnNldCBwYXJlbnQgZm9yIHRoaXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydE9iaiA9IHN0YXJ0T2JqLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZE9iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGZhbHNlIHJlc3VsdCwgaXMgZGl2IGEgc2Nyb2xsYWJsZSBkaXYuXG4gICAgICogQHBhcmFtIHBfZGl2XG4gICAgICovXG4gICAgcndfaXNEaXZTY3JvbGxhYmxlKHBfZGl2KVxuICAgIHtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIC8qTkIgcG9zc2libGUgaXNzdWUgd2l0aCBpbmxpbmUgZml4ZWQgZGl2IGluIHBhZ2UgdGhhdCBhbHNvIHNjcm9sbHMsIG1heSBvciBtYXkgbm90IGJlIGltcG9ydGFudCBpc3N1ZT8qL1xuXG4gICAgICAgIC8vIGNoZWNrIHRoZSBkaXZcbiAgICAgICAgdmFyIG5PYmpIZWlnaHQgPSBwX2Rpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBuT2JqV2lkdGggPSBwX2Rpdi5jbGllbnRXaWR0aDtcblxuICAgICAgICB2YXIgdGhlU3R5bGUgPSBzc2RvbS5nZXRDb21wdXRlZFN0eWxlKHBfZGl2KTtcblxuICAgICAgICB2YXIgYlNjcm9sbGFibGUgPSBmYWxzZTtcblxuICAgICAgICBpZih0aGVTdHlsZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0aGVTdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIiAmJlxuICAgICAgICAgICAgdGhlU3R5bGUuZGlzcGxheSAhPSBcImlubGluZVwiKSAgLy8gaWYgaW5saW5lIGEgZGl2LCBzdG9wcyBiZWluZyBhIGRpdiBhcyBzdWNoIHNvIG5vIHNjcm9sbC5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYocF9kaXYuc2Nyb2xsSGVpZ2h0ID4gbk9iakhlaWdodCAmJiB0aGVTdHlsZS5vdmVyZmxvd1kgIT0gXCJ2aXNpYmxlXCIpXG4gICAgICAgICAgICB7ICAgLy8gZW5zdXJlIHRoYXQgb3ZlcmZsb3d4IGlzIG5vdCB2aXNpYmxlXG4gICAgICAgICAgICAgICAgYlNjcm9sbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihwX2Rpdi5zY3JvbGxXaWR0aCA+IG5PYmpXaWR0aCAmJiB0aGVTdHlsZS5vdmVyZmxvd1ggIT0gXCJ2aXNpYmxlXCIpXG4gICAgICAgICAgICB7ICAgLy8gZW5zdXJlIHRoYXQgb3ZlcmZsb3d5IGlzIG5vdCB2aXNpYmxlXG4gICAgICAgICAgICAgICAgYlNjcm9sbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJTY3JvbGxhYmxlO1xuICAgIH1cbn0iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW5tbCBvbiAwMy8wNS8yMDE2LlxuICovXG5cbmV4cG9ydCBjbGFzcyBCYXNlU2VsZWN0aW9ue1xuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgfVxuXG4gICAgY2xlYXJTZWxlY3Rpb25fKCl7XG4gICAgICAgdGhpcy5jbGVhckJyb3dzZXJTZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHdlYiBwYWdlIHNlbGVjdGlvbi4gVGhpcyBpcyBub3QgdGhlIGhpZ2hsaWdodHNcbiAgICAgKiB3ZSBhZGQuXG4gICAgICovXG4gICAgICAgIGNsZWFyQnJvd3NlclNlbGVjdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTx3aW5kb3cuZnJhbWVzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5lbXB0eSkgeyAgLy8gQ2hyb21lXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZnJhbWVzW2ldLmdldFNlbGVjdGlvbigpLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcykgeyAgLy8gRmlyZWZveFxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmZyYW1lc1tpXS5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1jYXRjaChlKXtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuZW1wdHkpIHsgIC8vIENocm9tZVxuICAgICAgICAgICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5lbXB0eSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKSB7ICAvLyBGaXJlZm94XG4gICAgICAgICAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikgeyAgLy8gSUU/XG4gICAgICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNlbGVjdGlvblJhbmdlKCl7XG4gICAgICAgIFxuICAgIH1cblxuICAgIGhhc1NlbGVjdGlvbiAoKXtcblxuICAgIH1cblxufSIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbm1sIG9uIDE5LzA0LzIwMTYuXG4gKi9cbmltcG9ydCB7VEhDYXJldFJhbmdlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIQ2FyZXRSYW5nZSdcbmltcG9ydCB7VEhDYXJldH0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USENhcmV0J1xuaW1wb3J0IHtUSERvbVJhbmdlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIRG9tUmFuZ2UnXG5pbXBvcnQge0Jhc2VTZWxlY3Rpb259IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vU2VsZWN0aW9uL0Jhc2VTZWxlY3Rpb24nXG5pbXBvcnQge0V2ZW50QnVzfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0V2ZW50cy9FdmVudEJ1cydcbmltcG9ydCB7U3BlZWNoT2JqZWN0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1NwZWVjaE9iamVjdCdcblxuZXhwb3J0IGNsYXNzIEhvdmVyU3BlYWsgZXh0ZW5kcyBCYXNlU2VsZWN0aW9ue1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmV2ZW50PXt9O1xuICAgICAgICB0aGlzLnRpbWVyRXZlbnQ9bnVsbDtcbiAgICAgICAgdGhpcy5jYWxsYmFjaz1udWxsO1xuICAgICAgICB0aGlzLmNhcmV0UmFuZ2U9bnVsbDtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEV2ZW50QnVzKClcbiAgICAgICAgZXZlbnQuc3Vic2NyaWJlKFwicGF1c2VIb3ZlclwiLHRoaXMuY2xlYXJUaW1lci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zZW50ZW5jZVxuICAgICAgICB0aGlzLnJlYWRSYW5nZT1udWxsO1xuICAgIH1cblxuICAgIG1vdXNlTW92ZWQoZXZlbnQsY2FsbGJhY2spe1xuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lckV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQ9IGV2ZW50O1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaz1jYWxsYmFjaztcbiAgICAgICAgICAgIHRoaXMudGltZXJFdmVudCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFNwZWVjaCgpLCA1MDApO1xuICAgIH1cblxuICAgIGNsZWFyVGltZXIoKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJFdmVudCk7XG4gICAgfVxuICAgIGNsZWFySG92ZXJTcGVhaygpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lckV2ZW50KTtcbiAgICAgICAgdGhpcy5zZW50ZW5jZT09bnVsbDtcbiAgICB9XG5cbiAgICBzdGFydFNwZWVjaCgpe1xuXG4gICAgICAgIHZhciByYW5nZTtcblxuICAgICAgICBpZiAodGhpcy5ldmVudC50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT1cInRleHRhcmVhXCIpe1xuICAgICAgICAgICAgcmFuZ2UgPSBuZXcgVEhEb21SYW5nZSh0aGlzLmV2ZW50LnRhcmdldCwgMCxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50LnRhcmdldCwgMCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgICB9ZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jUmFuZ2UgPSB0aGlzLmV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQodGhpcy5ldmVudC5jbGllbnRYLCB0aGlzLmV2ZW50LmNsaWVudFkpO1xuICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFRIRG9tUmFuZ2UoZG9jUmFuZ2Uuc3RhcnRDb250YWluZXIsIGRvY1JhbmdlLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBkb2NSYW5nZS5lbmRDb250YWluZXIsIGRvY1JhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGRvY1JhbmdlID0gdGhpcy5ldmVudC50YXJnZXQub3duZXJEb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHRoaXMuZXZlbnQuY2xpZW50WCwgdGhpcy5ldmVudC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBUSERvbVJhbmdlKGRvY1JhbmdlLm9mZnNldE5vZGUsIGRvY1JhbmdlLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgZG9jUmFuZ2Uub2Zmc2V0Tm9kZSwgZG9jUmFuZ2Uub2Zmc2V0KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbG9jYWxTcGVlY2hPYmplY3QgPSBuZXcgU3BlZWNoT2JqZWN0KCk7XG4gICAgICAgICAgICBsb2NhbFNwZWVjaE9iamVjdC5wcm9jZXNzUmFuZ2UocmFuZ2UsIHRydWUpO1xuICAgICAgICAgICAgdmFyIG5ld1NlbnRlbmNlID0gbG9jYWxTcGVlY2hPYmplY3QuZ2V0Rmlyc3RTZW50ZW5jZSgpO1xuXG4gICAgICAgICAgICB2YXIgb2xkU2VudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIG5ld1NlbnRUZXh0ID0gXCJcIjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VudGVuY2UgJiYgdGhpcy5zZW50ZW5jZS5nZXRSYXdUZXh0KCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb2xkU2VudFRleHQgPSB0aGlzLnNlbnRlbmNlLmdldFJhd1RleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTZW50ZW5jZS5nZXRSYXdUZXh0KCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3U2VudFRleHQgPSBuZXdTZW50ZW5jZS5nZXRSYXdUZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50LnRhcmdldCA9PSByYW5nZS5zdGFydENhcmV0Lm5vZGUucGFyZW50RWxlbWVudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZW50ZW5jZSA9PSBudWxsIHx8IG9sZFNlbnRUZXh0LmluZGV4T2YobmV3U2VudFRleHQpID09IC0xKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW50ZW5jZSA9IG5ld1NlbnRlbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZXRTZWxlY3Rpb25SYW5nZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkUmFuZ2U7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGtldmluIG9uIDIzLzAzLzE2LlxuICovXG5pbXBvcnQge1RIQ2FyZXRSYW5nZX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USENhcmV0UmFuZ2UnXG5pbXBvcnQge1RIRG9tUmFuZ2V9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhEb21SYW5nZSdcbmltcG9ydCB7VXRpbGl0aWVzfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1V0aWxpdGllcy9VdGlsaXRpZXMnXG5pbXBvcnQge1NTRE9NfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9TU0RPTSdcbmltcG9ydCB7QmFzZVNlbGVjdGlvbn0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9TZWxlY3Rpb24vQmFzZVNlbGVjdGlvbidcbmltcG9ydCB7RG9tTmF2aWdhdGlvbn0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9ET00vRG9tTmF2aWdhdGlvbidcbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9BdHRyaWJ1dGUnXG5cbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25Db250cm9sbGVyIGV4dGVuZHMgQmFzZVNlbGVjdGlvbntcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5nX2lwYWRTZWxlY3Rpb25SYW5nZT1udWxsO1xuICAgIH1cblxuICAgIGdldFNlbGVjdGlvblJhbmdlKCl7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbl8oKVxuICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uLnJhbmdlO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNlbGVjdGlvbk9iamVjdCgpe1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25fKClcbiAgICAgICAgdGhpcy5jbGVhckJyb3dzZXJTZWxlY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9XG5cbiAgICBpc01hdGhKYXgocmFuZ2Upe1xuICAgICAgICBpZiAodHlwZW9mIChNYXRoSmF4KSE9XCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q2FyZXQubm9kZS5pc01hdGhKYXgpe1xuICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q2FyZXQubm9kZS5wYXJlbnROb2RlLmlzTWF0aEpheCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IHNlbGVjdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0aW9ucy5cbiAgICAgKi9cbiAgICBoYXNTZWxlY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbl8oKVxuICAgICAgICBpZiAoc2VsZWN0aW9uICE9bnVsbCAmJiBzZWxlY3Rpb24hPXVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0U2VsZWN0aW9uU3RyaW5nKClcbiAgICB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbl8oKTtcbiAgICAgICAgdmFyIHRleHQgPSBzZWxlY3Rpb24ucmFuZ2UudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG5cbiAgICBnZXRTZWxlY3Rpb25fKClcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgZG9tTmF2ID0gbmV3IERvbU5hdmlnYXRpb24oKTtcbiAgICAgICAgdmFyIHRoZVdpbmRvdyA9IG51bGw7XG4gICAgICAgIHZhciB0aGVSYW5nZSA9IG51bGw7XG5cbiAgICAgICAgaWYodGhpcy5nX2lwYWRTZWxlY3Rpb25SYW5nZSE9bnVsbClcbiAgICAgICAgeyAgIC8vIHdvcmthcm91bmQgZm9yIGlwYWQgSU9TNSBidWcsIGxvc2VzIHNlbGVjdGlvbiBvbiBhbnkgYWN0aW9uLlxuICAgICAgICAgICAgZ19pcGFkU2VsZWN0aW9uV2luZG93LmdldFNlbGVjdGlvbigpLmFkZFJhbmdlKHRoaXMuZ19pcGFkU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRtcFNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICB2YXIgZm91bmRTZWwgPSBudWxsO1xuICAgICAgICB2YXIgdXRpbGl0aWVzID0gbmV3IFV0aWxpdGllcygpO1xuICAgICAgICBpZighdG1wU2VsLmlzQ29sbGFwc2VkICYmIHV0aWxpdGllcy50cmltKHRtcFNlbC50b1N0cmluZygpKS5sZW5ndGggPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGVXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgICAgICBmb3VuZFNlbCA9IHRtcFNlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEZvciBTRkYgY2hlY2sgaWYgaGF2ZSBzZWxlY3Rpb24gaW5zaWRlIGFuIElucHV0IGVsZW1lbnQuXG4gICAgICAgICAgICAvLyBJZiBzbyBnX2xhc3RJbnB1dFNlbGVjdFNGRiB3aWxsIHBvaW50IHRvIGFuIElucHV0IGVsZW1lbnQuXG4vLyAgICAgICAgICAgICAgICBpZihnX2xhc3RJbnB1dFNlbGVjdFNGRiAmJiBnX2xhc3RJbnB1dFNlbGVjdFNGRi5zZWxlY3Rpb25TdGFydFxuLy8gICAgICAgICAgICAgICAgICAgICE9IGdfbGFzdElucHV0U2VsZWN0U0ZGLnNlbGVjdGlvbkVuZClcbi8vICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2ZyYW1lOndpbmRvdywgcmFuZ2U6bmV3IFN0cmluZyhcbi8vICAgICAgICAgICAgICAgICAgICAgICAgZ19sYXN0SW5wdXRTZWxlY3RTRkYudmFsdWUuc3Vic3RyaW5nKGdfbGFzdElucHV0U2VsZWN0U0ZGLnNlbGVjdGlvblN0YXJ0LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ19sYXN0SW5wdXRTZWxlY3RTRkYuc2VsZWN0aW9uRW5kKVxuLy8gICAgICAgICAgICAgICAgICAgICl9O1xuLy8gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzZWxlY3Rpb24gaW5zaWRlIGEgZnJhbWVcbi8vICAgICAgICAgICAgICAgIHZhciByZXMgPSBTU0RPTS5nZXRGcmFtZVNlbGVjdGlvblNGRih3aW5kb3cpO1xuLy8gICAgICAgICAgICAgICAgaWYocmVzLmZvdW5kU2VsKVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIHRoZVdpbmRvdyA9IHJlcy50aGVXaW5kb3c7XG4vLyAgICAgICAgICAgICAgICAgICAgZm91bmRTZWwgPSByZXMuZm91bmRTZWw7XG4vLyAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihmb3VuZFNlbCA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaSA9MDtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZFNlbD09bnVsbCAmJiBpPCB3aW5kb3cuZnJhbWVzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0bXBTZWwgPSB3aW5kb3cuZnJhbWVzW2ldLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdG1wU2VsLmlzQ29sbGFwc2VkICYmIHV0aWxpdGllcy50cmltKHRtcFNlbC50b1N0cmluZygpKS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbCA9IHRtcFNlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbD1udWxsO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZm91bmRTZWwgPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYoZm91bmRTZWwuZm9jdXNOb2RlICYmIGZvdW5kU2VsLmZvY3VzTm9kZS5pZClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoZm91bmRTZWwuZm9jdXNOb2RlLmlkID09IFwiZmxhc2hjb250ZW50XCIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgemVybyBsZW5ndGggc2VsZWN0aW9uXG4gICAgICAgIGlmKGZvdW5kU2VsLmFuY2hvck5vZGUgIT0gbnVsbCAmJiBmb3VuZFNlbC5hbmNob3JOb2RlID09IGZvdW5kU2VsLmZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgZm91bmRTZWwuYW5jaG9yT2Zmc2V0ID09IGZvdW5kU2VsLmZvY3VzT2Zmc2V0KVxuICAgICAgICB7ICAgLy8gQ2FzZXMgd2l0aCBmbGFzaCB3ZXJlIGNvbGxhcHNlZCBzZWxlY3Rpb24gbm90IHJlY29yZGVkIGFzIGNvbGxhcHNlZC5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1velJhbmdlID0gbnVsbDtcbiAgICAgICAgaWYoZm91bmRTZWwuZ2V0UmFuZ2VBdClcbiAgICAgICAgeyAgLy8gZmlyZWZveFxuICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRBc3NpZ25tZW50XG4gICAgICAgICAgICBtb3pSYW5nZSA9IGZvdW5kU2VsLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7ICAvLyBzYWZhcmlcblxuICAgICAgICAgICAgdmFyIHJhbmdlID0gc3Nkb20uZ2V0UmFuZ2VPYmplY3QoKTtcbiAgICAgICAgICAgIGlmKHJhbmdlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gaWYgc2VsZWN0aW9uIGRvbmUgdmlhIGRvdWJsZSBjbGljayByYXRoZXIgdGhhbiBkcmFnZ2luZyB0aGVuIHRoZSBzZWxlY3Rpb24gb2JqZWN0IGlzIGluY29ycmVjdCwgbmVlZCB0byBndWVzc1xuICAgICAgICAgICAgICAgIGlmKCBmb3VuZFNlbC5hbmNob3JOb2RlID09IGZvdW5kU2VsLmZvY3VzTm9kZSAmJiBmb3VuZFNlbC5hbmNob3JPZmZzZXQgPT0gZm91bmRTZWwuZm9jdXNPZmZzZXQpXG4gICAgICAgICAgICAgICAgeyAvLyBpZiBjb250YWlucyBubyBzcGFjZXMgaXMganVzdCBvbmUgd29yZCwgb3RoZXJ3aXNlIGlzIHNlbnRlbmNlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzc2RvbS5nZXRSYW5nZUZyb21TZWxlY3Rpb25Qb2ludChmb3VuZFNlbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgbmVlZCB0byB0ZWxsIHdoZXRoZXIgd29yZCBvciBzZW50ZW5jZSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAvLyB1c2U6IHZhciB0bXBTdHIgPSBmb3VuZFNlbCArIFwiXCI7IGlmKHRtcFN0ci5pbmRleE9mKFwiIFwiKSA+IC0xKSAgeyAgLy8gc2VudGVuY2UgaGFuZGxpbmd9ZWxzZXsgIC8vIHdvcmQgaGFuZGxpbmd9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGZvdW5kU2VsLmFuY2hvck5vZGUsIGZvdW5kU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChmb3VuZFNlbC5mb2N1c05vZGUsIGZvdW5kU2VsLmZvY3VzT2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZihyYW5nZS50b1N0cmluZygpLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICB7ICAgLy8gdHJ5IG90aGVyIHdheSBhcm91bmQgaW4gY2FzZSBzZWxlY3QgZnJvbSByaWdodCB0byBsZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChmb3VuZFNlbC5mb2N1c05vZGUsIGZvdW5kU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChmb3VuZFNlbC5hbmNob3JOb2RlLCBmb3VuZFNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1velJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYobW96UmFuZ2UgIT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29uID0gbW96UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgc3RhcnRPZmYgPSBtb3pSYW5nZS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgIHZhciBlbmRDb24gPSBtb3pSYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgZW5kT2ZmID0gbW96UmFuZ2UuZW5kT2Zmc2V0O1xuXG4gICAgICAgICAgICAvL2lmIGNvbnRhaW5lciBpcyBub3QgYSB0ZXh0IG5vZGUgaXQgY2FuIGNhdXNlIHNlbGVjdGlvbiBlcnJvclxuICAgICAgICAgICAgaWYoc3RhcnRDb24ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihzdGFydENvbi5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHsgICAvLyBub3QgZWxlbWVudCBvciB0ZXh0IG5vZGUsIGJhZCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7ICAgLy8gbWlnaHQgbmVlZCB0byB1c2Ugc3ViIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnRPZmYgPiAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzdGFydENvbi5oYXNDaGlsZE5vZGVzKCkgJiYgc3RhcnRDb24uY2hpbGROb2Rlcy5sZW5ndGggPiBzdGFydE9mZilcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENvbiA9IHN0YXJ0Q29uLmNoaWxkTm9kZXNbc3RhcnRPZmZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0YXJ0Q29uLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvIGxvb2sgaW50byB0aGlzIG1vcmUsIHdoYXQgdG8gZG8gd2hlbiBzZWxlY3Rpb24gZW5kcyBhZnRlciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvIHBhcnRpY3VsYXJseSBsb29rIGF0IGltZyB3aXRoIG1zZ1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RhcnRDb24udG9TdHJpbmcoKSA9PSBcIltvYmplY3QgSFRNTEVtYmVkRWxlbWVudF1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgY29udGFpbmVyIGlzIG5vdCBhIHRleHQgbm9kZSBpdCBjYW4gY2F1c2Ugc2VsZWN0aW9uIGVycm9yXG4gICAgICAgICAgICBpZihlbmRDb24ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZihlbmRDb24ubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICB7ICAgLy8gbm90IGVsZW1lbnQgb3IgdGV4dCBub2RlLCBiYWQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeyAgIC8vIG1pZ2h0IG5lZWQgdG8gdXNlIHN1YiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGlmKGVuZENvbi5oYXNDaGlsZE5vZGVzKCkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVuZENvbi5jaGlsZE5vZGVzLmxlbmd0aCA+IGVuZE9mZilcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgICAvLyBtb3ZlIHRvIGl0ZW0gc3VyZSB0byBiZSBhZnRlciBzZWxlY3Rpb24gYW5kIGFsbG93IGxvb2sgZm9yIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29uID0gZW5kQ29uLmNoaWxkTm9kZXNbZW5kT2ZmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDb24gPSBlbmRDb24uY2hpbGROb2Rlc1tlbmRPZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlbmRDb24ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gbWlnaHQgYmUgcGFyZW50IG9mIHRoZSBzZWxlY3Rpb24sIGxvb2sgdG8gbGFzdCB0ZXh0IGJlbmVhdGggdGhpcyBwb2ludCBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTRHVwbGljYXRlZERlY2xhcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gZG9tTmF2LmdldExhc3RDaGlsZFRleHROb2RlKGVuZENvbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRtcE5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29uID0gdG1wTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGZvdW5kIHlldFxuICAgICAgICAgICAgICAgICAgICBpZihlbmRDb24ubm9kZVR5cGUgIT0gMylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcEJsb2NrID0gZG9tTmF2LmdldFByZXZpb3VzTm9kZShzdGFydENvbiwgdHJ1ZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBKU0R1cGxpY2F0ZWREZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcE5vZGUgPSBkb21OYXYuZ2V0UHJldmlvdXNUZXh0Tm9kZShlbmRDb24sIGZhbHNlLCB0bXBCbG9jayk7ICAgICAgICAgLy8vIHNob3VsZCBiZSBmYWxzZT8gIHNvIGNhbiBnbyBiYWNrIG92ZXIgcGFyYSB0byB2YWxpZCB0ZXh0P1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG1wTm9kZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENvbiA9IHRtcE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihlbmRDb24ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2ZmID0gZW5kQ29uLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRPZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGVSYW5nZSA9IG5ldyBUSERvbVJhbmdlKHN0YXJ0Q29uLCBzdGFydE9mZixcbiAgICAgICAgICAgICAgICBlbmRDb24sIGVuZE9mZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoZVdpbmRvdyAhPSBudWxsICYmIHRoZVJhbmdlICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7ZnJhbWU6dGhlV2luZG93LCByYW5nZTp0aGVSYW5nZX07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW4gb24gMDYvMDQvMTYuXG4gKi9cbi8qKlxuICogQ3JlYXRlZCBieSBJbnRlbGxpSiBJREVBLlxuICogVXNlcjogc3R1YXJ0XG4gKiBEYXRlOiAwNS8wNi8xNVxuICogVGltZTogMTM6NTFcbiAqXG4gKlxuICovXG5cblxuaW1wb3J0IHtUSFJhbmdlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIUmFuZ2UnXG5pbXBvcnQge1NTRE9NfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9TU0RPTSdcblxuXG5cblxuLy8gU2V0IHVwIGEgYmFzZSB0eXBlLlxuLy8gQWxsIHRoZSBTcGVlY2ggb2JqZWN0cyB3aWxsIGhhdmUgYSBjb21tb24gY29yZSB0aGF0IGFsbG93cyBlYWNoIG9iamVjdCB0byBoYXZlIGEgcmFuZ2Ugc2V0IGZvciBpdCBhbmQgYSB0eXBlLlxuLyoqXG4gKiBCYXNlIHR5cGUuXG4gKlxuICogQVBJXG4gKiBnZXRSYW5nZVxuICogc2V0UmFuZ2VcbiAqIGdldFR5cGVcbiAqIGlzVmFsaWRcbiAqIHNldFZhbGlkXG4gKiBnZXRDb250ZW50c1xuICogc2V0Q29udGVudHNcbiAqIGFkZENvbnRlbnRcbiAqIGlzT3ZlcnJpZGluZ1RleHRcbiAqIGdldFdvcmRDb3VudFxuICogZ2V0V29yZHNcbiAqIGdldFNwb2tlblRleHRcbiAqIGdldEZpcnN0Tm9kZVxuICpcbiAqIEBwYXJhbSBwX3R5cGUgU3BlZWNoU3RyZWFtLnNwZWVjaERvbS5UeXBlc1xuICovXG5leHBvcnQgY2xhc3MgQmFzZU9iamVjdHtcbiAgICBjb25zdHJ1Y3RvcihwX3R5cGUpXG4gICAge1xuICAgICAgICAvLyBOZWVkIHRvIHVzZSB0aGlzIHRvIHdvcmsgd2l0aCBwcm90b3R5cGUgZm9yIHN1YiB0eXBlcywgYnV0IHRoZXNlIHNob3VsZCBiZSBjb25zaWRlcmVkIHByaXZhdGUgdmFyaWFibGVzLlxuICAgICAgICB0aGlzLm1fcmFuZ2UgPSBudWxsOyAgICAgICAgLy8gVEhSYW5nZVxuICAgICAgICB0aGlzLm1fdHlwZSA9IHBfdHlwZTsgICAgICAgLy8gU3BlZWNoU3RyZWFtLnNwZWVjaERvbS5UeXBlc1xuICAgICAgICB0aGlzLm1fYlZhbGlkID0gdHJ1ZTsgICAgICAgLy8gRmxhZyBmb3Igd2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyB2YWxpZC5cbiAgICAgICAgdGhpcy5tX2NvbnRlbnRzID0gbnVsbDsgICAgIC8vIEFycmF5IG9mIFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uQmFzZU9iamVjdCAgKE5CLCB0aGlzIG11c3QgYmUgbnVsbCBzbyBpdCBjcmVhdGVkIG5ldyBpbiBlYWNoIGluc3RhbmNlIHNvIGl0IGlzIG5vdCBzaGFyZWQgYWNyb3NzIHRoZW0uKVxuICAgICAgICB0aGlzLlR5cGVzID1cbiAgICAgICAge1xuICAgICAgICAgICAgV09SRDoxLCAgICAgICAgICAgICAvLyBiYXNpYyB0ZXh0XG4gICAgICAgICAgICBTRU5URU5DRToyLCAgICAgICAgIC8vIFNlbnRlbmNlIG9mIHdvcmQsIFNTTUwgYW5kIFNpbGVuY2Ugb2JqZWN0c1xuICAgICAgICAgICAgU1NNTDozLCAgICAgICAgICAgICAvLyBTU01MIGN1c3RvbSBvYmplY3RzXG4gICAgICAgICAgICBET0NVTUVOVDo0LCAgICAgICAgIC8vIGNvbGxlY3Rpb24gb2Ygc2VudGVuY2VzXG4gICAgICAgICAgICBTSUxFTkNFOjUgICAgICAgICAgIC8vIGVsZW1lbnQgdGhhdCBwYXVzZXMgc3BlZWNoXG4gICAgICAgIH07XG5cbiAgICB9XG4gICAgLy8gZ2V0dGVycyAvIHNldHRlcnNcblxuICAgIC8qKlxuICAgICAqIEdldCBSYW5nZS4gIFRoaXMgcmV0dXJucyBhcyBUSFJhbmdlIG9iamVjdCBpZiBpdCBleGlzdHMuXG4gICAgICogVGhpcyBpcyB0aGUgcmFuZ2UgaW4gdGhlIHBhZ2UgdGhhdCB0aGUgb2JqZWN0IHJlcHJlc2VudHMuXG4gICAgICovXG4gICAgZ2V0UmFuZ2UgKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fcmFuZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmFuZ2UsIHNob3VsZCBiZSBhIFRIUmFuZ2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSBwX3JhbmdlXG4gICAgICovXG4gICAgc2V0UmFuZ2UgKHBfcmFuZ2UpXG4gICAge1xuICAgICAgICBpZihwX3JhbmdlIGluc3RhbmNlb2YgVEhSYW5nZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tX3JhbmdlID0gcF9yYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRXJyb3IsIGNhbGxpbmcgc2V0UmFuZ2Ugd2l0aCBpbmNvcnJlY3QgdHlwZVwiKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uVHlwZXMgdHlwZSBmb3IgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0VHlwZSAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV90eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJvb2xlYW4gZm9yIHdoZXRoZXIgdGhlIG9iamVjdCBpcyBzZXQgYXMgdmFsaWQuICBXaWxsIGRlZmF1bHQgYXMgdmFsaWQuXG4gICAgICovXG4gICAgaXNWYWxpZCAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9iVmFsaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHZhbGlkIHN0YXR1cy5cbiAgICAgKiBAUGFyYW0gcF9iVmFsaWRcbiAgICAgKi9cbiAgICBzZXRWYWxpZCAocF9iVmFsaWQpXG4gICAge1xuICAgICAgICB0aGlzLm1fYlZhbGlkID0gcF9iVmFsaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb250ZW50cy4gIFJldHVybnMgYXMgYW4gYXJyYXkgb2YgQmFzZU9iamVjdHMuXG4gICAgICovXG4gICAgZ2V0Q29udGVudHMgKClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMubV9jb250ZW50cyA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1fY29udGVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tX2NvbnRlbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29udGVudHMuICBDb21wbGV0ZWx5IHJlcGxhY2VzIGN1cnJlbnQgY29udGVudHMuXG4gICAgICogQHBhcmFtIHBfY29udGVudHNcbiAgICAgKi9cbiAgICBzZXRDb250ZW50cyAocF9jb250ZW50cylcbiAgICB7XG4gICAgICAgIGlmKHBfY29udGVudHMgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRlbnRzID0gcF9jb250ZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIC8vaWYocF9jb250ZW50cyBpbnN0YW5jZW9mIFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uQmFzZU9iamVjdClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5tX2NvbnRlbnRzID0gW3BfY29udGVudHNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHNpbmdsZSBpdGVtIHRvIHRoZSBjb250ZW50cy5cbiAgICAgKiBAcGFyYW0gcF9vYmpcbiAgICAgKi9cbiAgICBhZGRDb250ZW50IChwX29iailcbiAgICB7XG4gICAgICAgLy90b2RvIGlmKHBfb2JqIGluc3RhbmNlb2YgU3BlZWNoU3RyZWFtLnNwZWVjaERvbS5CYXNlT2JqZWN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih0aGlzLm1fY29udGVudHMgPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fY29udGVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tX2NvbnRlbnRzLnB1c2gocF9vYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgb2JqZWN0IGlzIGFsdGVyaW5nIHRoZSB0ZXh0IGZyb20gd2hhdCB3YXMgcGFzZWQgaW4uXG4gICAgICogT25seSBhcHBsaWVzIHRvIHNvbWUgb2JqZWN0IHR5cGVzLCBzbyBhbHdheXMgZmFsc2UgdW5sZXNzIHN1YiB0eXBlIG92ZXJyaWRlcyB0aGlzLlxuICAgICAqL1xuICAgIGlzT3ZlcnJpZGluZ1RleHQgKClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIGdldFdvcmRDb3VudCAoKVxuICAgIHtcbiAgICAgICAgLy8gSWYgaXMgc2luZ2xlIHdvcmQsIG9yIGVsZW1lbnQgcmVwbGFjaW5nIGNvbnRlbnQgc28gdGhhdCBjb3VudHMgYXMgc2luZ2xlIHdvcmQuXG4gICAgICAgIGlmKHRoaXMubV90eXBlID09IHRoaXMuVHlwZXMuV09SRCB8fCB0aGlzLmlzT3ZlcnJpZGluZ1RleHQoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGlmKHRoaXMubV9jb250ZW50cyA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1fY29udGVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLm1fY29udGVudHMubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5MZW4gPSB0aGlzLm1fY29udGVudHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IoaT0wO2k8bkxlbjsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5tX2NvbnRlbnRzW2ldLmdldFdvcmRDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXJyYXkgb2YgdGhlIHdvcmRzIHRvIGJlIHNwb2tlbiwgZ3JvdXBlZCBhcyB3aWxsIGJlIGJvb2ttYXJrZWQuICBTbyB0eXBpY2FsbHkgb25lIHdvcmQgcGVyIG9iamVjdCxcbiAgICAgKiBidXQgb2JqZWN0IGNvdWxkIGJlIFNTTUwgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldFdvcmRzICgpXG4gICAge1xuICAgICAgICAvLyBJZiBpcyBzaW5nbGUgd29yZCwgb3IgZWxlbWVudCByZXBsYWNpbmcgY29udGVudCBzbyB0aGF0IGNvdW50cyBhcyBzaW5nbGUgd29yZC5cbiAgICAgICAgaWYodGhpcy5tX3R5cGUgPT0gdGhpcy5UeXBlcy5XT1JEIHx8IHRoaXMuaXNPdmVycmlkaW5nVGV4dCgpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmRzID0gW107XG4gICAgICAgIGlmKHRoaXMubV9jb250ZW50cyA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm1fY29udGVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLm1fY29udGVudHMubGVuZ3RoID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgbkxlbiA9IHRoaXMubV9jb250ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IoaT0wO2k8bkxlbjtpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd29yZHMgPSB3b3Jkcy5jb25jYXQodGhpcy5tX2NvbnRlbnRzW2ldLmdldFdvcmRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIGZvciB0aGUgZWxlbWVudC4gIENhbiBiZSB0aGUgdGV4dCBub2RlIG9yIGFuIGVsZW1lbnQgc3Vycm91bmRpbmcgYWxsIHRoZSB0ZXh0IG9yIHN1cnJvdW5kaW5nIHRoZSBzdGFydCBvZiB0aGUgdGV4dC5cbiAgICBnZXRGaXJzdE5vZGUgKClcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICAgIGlmKHJhbmdlICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjYXJldCA9IHNzZG9tLnJ3X2dldENhcmV0RnJvbVJlZlB0KHJhbmdlLmJvZHksIHJhbmdlLnN0YXJ0UmVmKTtcbiAgICAgICAgICAgIGlmKGNhcmV0ICE9IG51bGwgJiYgY2FyZXQubm9kZSAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXJldC5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEFic3RyYWN0XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGV4dCB0byBiZSBzcG9rZW4uICBUaGlzIHdpbGwgYmUgb3ZlcnJpZGVuIGluIGVhY2ggY2FzZSB3aGVyZSBpdCBpcyBuZWVkZWQuXG4gICAgICogSW5jbHVkZWQgaGVyZSBqdXN0IGluIGNhc2UsIGFzIGF0IHRpbWVzIGNhbGxlZCBvbiBhcnJheSBvZiBiYXNlIG9iamVjdHMgdGhhdFxuICAgICAqIHNob3VsZCBvbmx5IGluY2x1ZGUgdHlwZXMgdGhhdCBvdmVycmlkZSB0aGlzLiAgQnV0IGhlcmUgdG8gbG9nIGluIGNhc2Ugb2Ygd3JvbmcgdGltZSBiZWluZyBpbmNsdWRlZC5cbiAgICAgKi9cbiAgICBnZXRTcG9rZW5UZXh0ICgpXG4gICAge1xuICAgICAgICAvLyBpZihjb25zb2xlLmxvZylcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJDYWxsaW5nIGdldFNwb2tlblRleHQgb24gdHlwZSBvZiBTcGVlY2hPYmplY3QgdGhhdCBkb2Vzbid0IHN1cHBvcnQgaXQuXCIpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxufVxuXG4iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW5tbCBvbiAyMi8wNC8yMDE2LlxuICovXG5cbmltcG9ydCB7QmFzZU9iamVjdH0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9TZW50ZW5jZS9CYXNlT2JqZWN0J1xuXG5leHBvcnQgY2xhc3MgTWF0aFdvcmRPYmplY3QgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuSWQsIHBfc3RyV29yZCkge1xuICAgICAgICBzdXBlcigxKS8vdG9kb1xuICAgICAgICB0aGlzLnNwYW5JRD1zcGFuSWQ7XG4gICAgICAgIHRoaXMubV9zdHJXb3JkID0gcF9zdHJXb3JkOyAgICAgIC8vIFdvcmQgZm9yIHRoZSBnaXZlbiBvYmplY3QuICBSZWFkIG9ubHkuXG4gICAgICAgIHRoaXMubV9zdHJQcm9udW5jaWF0aW9uID0gbnVsbDsgIC8vIElmIHdvcmQgaXMgdG8gYmUgY2hhbmdlZCwgaXQgaXMgZ2l2ZW4gYSBwcm9udW5jaWF0aW9uIHRvIG92ZXJyaWRlIGl0LlxuICAgIH1cblxuICAgIGdldFJhbmdlKCl7XG4gICAgICAgcmV0dXJuIHRoaXMuc3BhbklEO1xuICAgIH1cblxuICAgIHNldFJhbmdlKHNwYW5JZCl7XG4gICAgICAgIHRoaXMuc3BhbklEPXNwYW5JZDtcbiAgICB9XG5cbiAgICBnZXRXb3JkICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3N0cldvcmQ7XG4gICAgfTtcbn0iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW4gb24gMDUvMDQvMTYuXG4gKi9cbmltcG9ydCB7U1NET019IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL1NTRE9NJ1xuaW1wb3J0IHtVdGlsaXRpZXN9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVXRpbGl0aWVzL1V0aWxpdGllcydcbmltcG9ydCB7VGV4dE92ZXJSYW5nZUJlYW5DbGFzc30gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9UZXh0T3ZlclJhbmdlQmVhbkNsYXNzJ1xuaW1wb3J0IHtCYXNlT2JqZWN0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1NlbnRlbmNlL0Jhc2VPYmplY3QnXG5pbXBvcnQge1RIRG9tUmFuZ2V9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhEb21SYW5nZSdcbmltcG9ydCB7TWF0aFNwZWFrfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL01hdGhKYXgvTWF0aFNwZWFrJ1xuaW1wb3J0IHtXb3JkT2JqZWN0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1NlbnRlbmNlL1dvcmRPYmplY3QnXG5pbXBvcnQge01hdGhXb3JkT2JqZWN0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1NlbnRlbmNlL01hdGhXb3JkT2JqZWN0J1xuaW1wb3J0IHtUSFJhbmdlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIUmFuZ2UnXG5pbXBvcnQge0RvbU5hdmlnYXRpb259IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL0RvbU5hdmlnYXRpb24nXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9ET00vQXR0cmlidXRlJ1xuLyoqXG4gKiBTZW50ZW5jZSBPYmplY3RcbiAqIFRoaXMgc2hvdWxkIGNvbnRhaW4gb2JqZWN0cyB0aGF0IG1ha2UgdXAgdGhlIHNlbnRlbmNlLiAgU1NNTCBvciB3b3JkIGVsZW1lbnRzXG4gKlxuICpcbiAqIFB1YmxpYyBBUElcbiAqIEluaGVyaXQgZnJvbSBCYXNlIE9iamVjdFxuICpcbiAqIHNldFZvaWNlXG4gKiBnZXRWb2ljZVxuICogc2V0Q2FyZXRSYW5nZVxuICogZ2V0Q2FyZXRSYW5nZVxuICogZ2V0UmF3VGV4dFxuICogc2V0UmF3VGV4dFxuICogZ2V0TWFya2VkVGV4dFxuICogc2V0TWFya2VkVGV4dFxuICogY2xvbmVcbiAqXG4gKiBAcGFyYW0gcF9jYXJldFJhbmdlXG4gKi9cbmV4cG9ydCBjbGFzcyBTZW50ZW5jZU9iamVjdCBleHRlbmRzIEJhc2VPYmplY3R7XG4gICAgY29uc3RydWN0b3IocF9jYXJldFJhbmdlKSB7XG4gICAgICAgIHN1cGVyKDIpLy90b2RvXG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgbV9zdHJWb2ljZSA9IG51bGw7XG4gICAgICAgIGlmIChwX2NhcmV0UmFuZ2UhPW51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubV9yYW5nZSA9IG5ldyBUSERvbVJhbmdlKHBfY2FyZXRSYW5nZS5sZWZ0Q2FyZXQubm9kZSwgcF9jYXJldFJhbmdlLmxlZnRDYXJldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgcF9jYXJldFJhbmdlLnJpZ2h0Q2FyZXQubm9kZSwgcF9jYXJldFJhbmdlLnJpZ2h0Q2FyZXQub2Zmc2V0KVxuXG4gICAgICAgICAgICB0aGlzLm1fY2FyZXRSYW5nZSA9IHBfY2FyZXRSYW5nZTsgLy8gVEhDYXJldFJhbmdlIC0gcmFuZ2UgdXNpbmcgY3VycmVudCBub2Rlcy4gIENvbnNpZGVyZWQgdGVtcG9yYXJ5IHJhbmdlIGFzIG5vdCBndWFyYW50ZWVkIHRvIHZhbGlkIGFmdGVyIGFueSBET00gbWFuaXB1bGF0aW9uLlxuICAgICAgICAgICAgaWYgKHBfY2FyZXRSYW5nZS5sZWZ0Q2FyZXQubm9kZS5pc01hdGhKYXgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGhTcGVhayA9IG5ldyBNYXRoU3BlYWsoKTtcbiAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9zdHJSYXdUZXh0ID0gbWF0aFNwZWFrLmdldFNwZWVjaFdpdGhCb29rbWFya3NGcm9tRWxlbWVudChwX2NhcmV0UmFuZ2UubGVmdENhcmV0Lm5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRNYXRoSW50b1dvcmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VudGVuY2VTcGFuSWQgPSBwX2NhcmV0UmFuZ2UubGVmdENhcmV0Lm5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpXG4gICAgICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5tX3N0clJhd1RleHQgPSBwX2NhcmV0UmFuZ2UuZ2V0VGV4dE92ZXJDYXJldFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fc3RyTWFya2VkVGV4dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdldHRlcnMgc2V0dGVyc1xuICAgIHNldFZvaWNlKHBfc3RyVm9pY2UpIHtcbiAgICAgICAgdGhpcy5tX3N0clZvaWNlID0gcF9zdHJWb2ljZTtcbiAgICB9XG5cbiAgICBnZXRWb2ljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9zdHJWb2ljZTtcbiAgICB9XG5cbiAgICBnZXRTcGFuSWQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VudGVuY2VTcGFuSWQ7XG4gICAgfVxuXG4gICAgc2V0Q2FyZXRSYW5nZShwX2NhcmV0UmFuZ2UpIHtcbiAgICAgICAgdGhpcy5tX2NhcmV0UmFuZ2UgPSBwX2NhcmV0UmFuZ2U7XG4gICAgICAgIHRoaXMubV9yYW5nZSA9IG1fY2FyZXRSYW5nZS5yd19nZXRUSFJhbmdlRnJvbVRIQ2FyZXRSYW5nZSgpO1xuICAgIH1cblxuICAgIGdldENhcmV0UmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fY2FyZXRSYW5nZTtcbiAgICB9XG5cblxuICAgIHNldFdvcmRzKHdvcmRzKXtcbiAgICAgICAgdmFyIHRtcCA9IG5ldyBXb3JkT2JqZWN0KG51bGwsd29yZHMpO1xuICAgICAgICB0aGlzLnNldENvbnRlbnRzKHRtcCk7XG4gICAgfVxuXG4gICAgZ2V0V29yZHMoKXtcbiAgICAgICAgdmFyIHdvcmRzQXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgdmFyIHdvcmRzID0gdGhpcy5nZXRDb250ZW50cygpO1xuICAgICAgICBmb3IgKHZhciBpID0wOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgd29yZHNBcnJheS5wdXNoKHdvcmRzW2ldLmdldFdvcmQoKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZHNBcnJheTtcbiAgICB9XG5cbiAgICBnZXRXb3JkUmFuZ2Uod29yZE5vKXtcbiAgICAgICAgdmFyIHdvcmRzID0gdGhpcy5nZXRDb250ZW50cygpO1xuICAgICAgICBpZiAod29yZE5vIDwgd29yZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gd29yZHNbd29yZE5vXS5nZXRSYW5nZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc01hdGhNTCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBUZXh0IGJlZm9yZSBpdCB3YXMgbW9kaWZpZWQuXG4gICAgICovXG4gICAgIGdldFJhd1RleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fc3RyUmF3VGV4dDtcbiAgICB9XG5cbiAgICBzZXRSYXdUZXh0KHBfc3RyUmF3VGV4dCkge1xuICAgICAgICB0aGlzLm1fc3RyUmF3VGV4dCA9IHBfc3RyUmF3VGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGV4dCBtYXJrZWQgdXAgZm9yIHNwZWVjaCB3aXRoIGZpbHRlcmluZyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGdldE1hcmtlZFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fc3RyTWFya2VkVGV4dDtcbiAgICB9XG5cbiAgICBzZXRNYXJrZWRUZXh0KHBfc3RyTWFya2VkVGV4dCkge1xuICAgICAgICB0aGlzLm1fc3RyTWFya2VkVGV4dCA9IHBfc3RyTWFya2VkVGV4dDtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdmFyIHRtcCA9IG5ldyBTZW50ZW5jZU9iamVjdChtX2NhcmV0UmFuZ2UpO1xuICAgICAgICB0bXAuc2V0Q29udGVudHModGhpcy5nZXRDb250ZW50cygpKTsgICAgIC8vIG1pZ2h0IHdhbnQgdG8gY2hhbmdlIHRoaXMgdG8gZGVlcCBjbG9uZSwgYnV0IGN1cnJlbnRseSBkb2VzIG5vdCBtYXR0ZXIuXG4gICAgICAgIHRtcC5zZXRWYWxpZCh0aGlzLmlzVmFsaWQoKSk7XG4gICAgICAgIHRtcC5zZXRWb2ljZShtX3N0clZvaWNlKTtcbiAgICAgICAgdG1wLnNldFJhd1RleHQobV9zdHJSYXdUZXh0KTtcbiAgICAgICAgdG1wLnNldE1hcmtlZFRleHQobV9zdHJNYXJrZWRUZXh0KTtcbiAgICAgICAgcmV0dXJuIHRtcDtcbiAgICB9XG5cbiAgICBzcGxpdE1hdGhJbnRvV29yZHMoKXtcbiAgICAgICAgaWYgKHRoaXMubV9zdHJSYXdUZXh0IT1cIlwiKSB7XG4gICAgICAgICAgICB2YXIgYm9va21hcmtzID0gdGhpcy5tX3N0clJhd1RleHQudG9Mb3dlckNhc2UoKS5tYXRjaCgvPGJvb2ttYXJrIG1hcms9XCJbMC05XStcIlxcLz4rL2cpO1xuICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy5tX3N0clJhd1RleHQudG9Mb3dlckNhc2UoKS5zcGxpdCgvPGJvb2ttYXJrIG1hcms9XCJbMC05XStcIlxcLz4rL2cpO1xuICAgICAgICAgICAgdmFyIGogPSAwXG4gICAgICAgICAgICAvL2NoZWNrIHRvIHNlZSBpZiB0aGVzZSBpcyBhIGJsYW5rIHdvcmQgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICBpZiAod29yZHMubGVuZ3RoID4gMCAmJiB3b3Jkc1swXSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2ttYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzcGFuSWQgPSBib29rbWFya3NbaV0ubWF0Y2goL1swLTldKy9nKTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbmV3IE1hdGhXb3JkT2JqZWN0KHNwYW5JZFswXSwgd29yZHNbal0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29udGVudCh0bXApO1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxjdWxhdGVzIHRoZSBvYmplY3RzIGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2UgcHJvdmlkZWQuICBJdCB3aWxsIGFzc3VtZSBpdCBpcyBzaW5nbGUgc2VudGVuY2UsXG4gICAgICogc28gaWYgcGFzc2VkIHRleHQgd2l0aCBtdWx0aXBsZSBzZW50ZW5jZXMsIHdpbGwgc3RpbGwgc3BsaXQgdG8gYXBwcm9wcmlhdGUgd29yZHMgYnV0IG5vdCBzZXBhcmF0ZVxuICAgICAqIGl0IHVwIGluIHRvIHNlcGFyYXRlIHNlbnRlbmNlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgZW50cnkgcG9pbnQgZG9lcyBhZGRpdGlvbmFsIGNoZWNrIHRoYXQgZG9lcyBvY2N1ciBpbiBlYWNoIHN0ZXAgb24gaW1wbC4gIEF0IHRoZSB0b3AgbmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgKiBzZWxlY3Rpb24gaXMgd2l0aCBhIGhpZ2hlciBlbGVtZW50IHRoYXQgd3JhcHMgdXAgdGhlIHRleHQgaW4gc3NtbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwX3NlbnRlbmNlT2JqXG4gICAgICovXG4gICAgcHJvY2Vzc1RleHRUb1NwZWFrSW5TZW50ZW5jZU9iamVjdCAoKVxuICAgIHtcbiAgICAgICAgLy8gT25jZSBoYXMgY2FsY3VsYXRlZCB0aGUgY29tcG9uZW50cywgY2hlY2sgaWYgYW55IGFyZSBuZXN0ZWQgaW4gaGlnaGVyIFNTTUwgdGhhdCB3YXMgb3V0c2lkZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIC8vIGJ1dCBjb3ZlcnMgcGFydCBvciBhbGwgb2YgaXQuXG4gICAgICAgIHRoaXMucHJvY2Vzc1RleHRUb1NwZWFrSW5TZW50ZW5jZU9iamVjdEltcGwoKTtcblxuICAgICAgICB2YXIgZWxlbXMgPSB0aGlzLmdldENvbnRlbnRzKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgZWxlbWVudHMgYXJlIGluIG5lc3RlZCBTU01MLiAgTm90ZSBkbyBub3QgYWxsb3cgY2hhbmdlIGluIG1pZCB3b3JkIHNvIG9ubHkgY2hlY2sgdGhlXG4gICAgICAgIC8vIHN0YXJ0IHJlZi4gIEV2ZW4gaWYgc29tZWhvdyBzZXQgdG8gY2hhbmdlIG1pZCB3b3JkLCBpdCB3aWxsIGNvbnRpbnVlIHdpdGggaW5zdHJ1Y3Rpb24gdG8gZW5kIG9mIHRoZSB3b3JkLlxuICAgICAgICBmb3IodmFyIGk9MDtpPGVsZW1zLmxlbmd0aDtpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gZWxlbXNbaV07XG4gICAgICAgICAgICB2YXIgZWxlbU5vZGUgPSBlbGVtLmdldEZpcnN0Tm9kZSgpO1xuICAgICAgICAgICAgaWYoZWxlbU5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzTmVzdGVkU3NtbChlbGVtTm9kZSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRJbldyYXBwaW5nU3NtbChlbGVtcywgaSwgZWxlbU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgbm9kZSBpcyBpbiBhbiBlbGVtZW50IHRoYXQgU1NNTCBvciBuZXN0ZWQgU1NNTC5cbiAgICAgKiBAcGFyYW0gcF9ub2RlXG4gICAgICovXG4gICAgICAgIGlzTmVzdGVkU3NtbChwX25vZGUpXG4gICAge1xuICAgICAgICB2YXIgdG9wID0gcF9ub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgdmFyIHRtcCA9IHBfbm9kZTtcblxuICAgICAgICB3aGlsZSh0bXAgIT0gdG9wICYmIHRtcCAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih0aGlzLmNoZWNrRm9yU3NtbEF0dHJpYnV0ZSh0bXApICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXAgPSB0bXAucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG5ldyBlbGVtZW50cyBpZiBuZWVkIHRvIG5lc3QgaXQuXG4gICAgICogTWF5IG5lZWQgdG8gbWVyZ2UgZm9sbG93aW5nIGl0ZW1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcF9lbGVtcyBUaGUgZnVsbCBhcnJheVxuICAgICAqIEBwYXJhbSBwX25Qb3MgcG9zaXRpb24gaW4gYXJyYXlcbiAgICAgKiBAcGFyYW0gcF9ub2RlIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgKi9cbiAgICAgICAgaW5zZXJ0SW5XcmFwcGluZ1NzbWwocF9lbGVtcywgcF9uUG9zLCBwX25vZGUpXG4gICAge1xuICAgICAgICB2YXIgdG9wID0gcF9ub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgdmFyIHRtcCA9IHBfbm9kZTtcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG5cbiAgICAgICAgd2hpbGUodG1wICE9IHRvcCAmJiB0bXAgIT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdG1wID0gdG1wLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZih0aGlzLmNoZWNrRm9yU3NtbEF0dHJpYnV0ZSh0bXApICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHdyYXBFbGVtZW50ID0gdGhpcy5jaGVja0ZvclNzbWxBdHRyaWJ1dGUodG1wKTtcbiAgICAgICAgICAgICAgICBpZih3cmFwRWxlbWVudC5jYW5Db250YWluQ29udGVudCgpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB3aXRoIHRoaXMsIGFuZCBtYXliZSBzdXNlcXVlbnQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcFRvQmVDb250YWluZWQgPSBwX2VsZW1zW3BfblBvc107XG4gICAgICAgICAgICAgICAgICAgIHBfZWxlbXNbcF9uUG9zXSA9IHdyYXBFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB3cmFwRWxlbWVudC5zZXRDb250ZW50cyhbdG1wVG9CZUNvbnRhaW5lZF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHN1YnNlcXVlbnQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqPXBfblBvcysxO2o8cF9lbGVtcy5sZW5ndGg7aisrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wRm9sbG93aW5nID0gcF9lbGVtc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBGb2xsb3dpbmdOb2RlID0gdG1wRm9sbG93aW5nLmdldEZpcnN0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3Nkb20uY2hlY2tJZkVsZW1lbnRJbnNpZGVFbGVtZW50KHRtcEZvbGxvd2luZ05vZGUsIHRtcCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gVGhpcyB3aWxsIGFsc28gYmUgaW5jbHVkZWQgaW4gdGhlIHNhbWUgb25lLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9CZUNvbnRhaW5lZCA9IHBfZWxlbXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcEVsZW1lbnQuYWRkQ29udGVudCh0bXBUb0JlQ29udGFpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwX2VsZW1zLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeyAgIC8vIHJlcGxhY2Ugd2l0aCB0aGlzLCBhbmQgbWF5YmUgc3VzZXF1ZW50IGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIHBfZWxlbXNbcF9uUG9zXSA9IHdyYXBFbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHN1YnNlcXVlbnQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqPXBfblBvcysxO2o8cF9lbGVtcy5sZW5ndGg7aisrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wRm9sbG93aW5nID0gcF9lbGVtc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBGb2xsb3dpbmdOb2RlID0gdG1wRm9sbG93aW5nLmdldEZpcnN0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3Nkb20uY2hlY2tJZkVsZW1lbnRJbnNpZGVFbGVtZW50KHRtcEZvbGxvd2luZ05vZGUsIHRtcCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICAgLy8gVGhpcyB3aWxsIGFsc28gYmUgaW5jbHVkZWQgaW4gdGhlIHNhbWUgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBfZWxlbXMuc3BsaWNlKGosMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGN1bGF0ZXMgdGhlIG9iamVjdHMgY29udGFpbmVkIGluIHRoZSByYW5nZSBwcm92aWRlZC4gIEl0IHdpbGwgYXNzdW1lIGl0IGlzIHNpbmdsZSBzZW50ZW5jZSxcbiAgICAgKiBzbyBpZiBwYXNzZWQgdGV4dCB3aXRoIG11bHRpcGxlIHNlbnRlbmNlcywgd2lsbCBzdGlsbCBzcGxpdCB0byBhcHByb3ByaWF0ZSB3b3JkcyBidXQgbm90IHNlcGFyYXRlXG4gICAgICogaXQgdXAgaW4gdG8gc2VwYXJhdGUgc2VudGVuY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBfc2VudGVuY2VPYmpcbiAgICAgKi9cbiAgICAgICAgcHJvY2Vzc1RleHRUb1NwZWFrSW5TZW50ZW5jZU9iamVjdEltcGwoKVxuICAgIHsgICAvLyBpdGVyYXRlIG92ZXIgcmFuZ2UgdG8gZ2V0IHRleHQsXG4gICAgICAgIC8vIFdoZW4gbW92aW5nIHRvIG5leHQsIGZpcnN0IGNoZWNrIHdpdGggZ29CeVN0eWxlLFxuICAgICAgICAvLyAgaWYgaGl0IG5vbiBzdHlsZSBub2RlIHRoZW4gdHJlYXQgdGhhdCBhcyBhIHNlbnRlbmNlIGJyZWFrXG4gICAgICAgIC8vIGFuZCBhZGQgYSBmdWxsIHN0b3AsIHRoZW4gbG9vayB0byBuZXh0IHdpdGggZ29CeVN0eWxlID0gZmFsc2UsIGFzIHdlIGRvIHdhbnQgdG8gZ28gYmV5b25kIHRoYXQgcG9pbnRcbiAgICAgICAgLy8gVGhpcyBpcyB0byBhbGxvdyA8ZGl2PmE8L2Rpdj5iIHRvIGJlIGEuIGIgcmF0aGVyIHRoYW4gYWJcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG5cbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZURhdGEgPSBuZXcgVGV4dE92ZXJSYW5nZUJlYW5DbGFzcyh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5zZXR1cENoZWNrKHN0YXRlRGF0YSk7XG5cbiAgICAgICAgICAgIHN0YXRlRGF0YS5zdGFydFJlZlB0ID0gc3Nkb20ucndfZ2V0UmVmUHQoc3RhdGVEYXRhLmxlZnROb2RlLCBzdGF0ZURhdGEubGVmdE9mZnNldCk7XG4gICAgICAgICAgICBzdGF0ZURhdGEuZW5kUmVmUHQgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUoc3RhdGVEYXRhLmN1cnJlbnROb2RlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5jaGVja0lmVG9vTG9uZyhzdGF0ZURhdGEpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjdXJOb2RlID0gc3RhdGVEYXRhLmN1cnJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmKHNzZG9tLmlzU3BlY2lhbENhc2UoY3VyTm9kZSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNwZWNpYWxDYXNlKHN0YXRlRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY3VyTm9kZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFbGVtZW50KHN0YXRlRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY3VyTm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUZXh0Tm9kZShzdGF0ZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIC8vIG90aGVyIG5vZGUgdHlwZSAoaWUgY29tbWVudClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvTmV4dE5vZGUoc3RhdGVEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImVyciBwcm9jZXNzVGV4dFRvU3BlYWtJblNlbnRlbmNlT2JqZWN0SW1wbDpcIisgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWxpZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUZXh0Tm9kZShwX2RhdGEpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGRvbU5hdiA9IG5ldyBEb21OYXZpZ2F0aW9uKCk7XG4gICAgICAgIC8vIEdldCB0ZXh0IGZvciBjdXJyZW50IG5vZGUuXG4gICAgICAgIHZhciBjdXJOb2RlID0gcF9kYXRhLmN1cnJlbnROb2RlO1xuICAgICAgICB2YXIgY3VyVHh0ID0gZG9tTmF2LmdldFRleHRGcm9tTm9kZShjdXJOb2RlKTtcbiAgICAgICAgaWYoY3VyVHh0ID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN1clR4dCA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBzdGFydCBvciBlbmQgdGV4dCBub2RlIGFuZCBub3QgdG8gdXNlIHRoZSBlbnRpcmUgdGV4dCBub2RlLlxuICAgICAgICB2YXIgbk9mZnNldCA9IDA7XG4gICAgICAgIGlmKHBfZGF0YS5yaWdodE5vZGUgPT0gY3VyTm9kZSAmJiBwX2RhdGEucmlnaHRPZmZzZXQgPiAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgY3VyVHh0ID0gY3VyVHh0LnN1YnN0cmluZygwLCBwX2RhdGEucmlnaHRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHBfZGF0YS5sZWZ0Tm9kZSA9PSBjdXJOb2RlICYmIHBfZGF0YS5sZWZ0T2Zmc2V0ID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgY3VyVHh0ID0gY3VyVHh0LnN1YnN0cmluZyhwX2RhdGEubGVmdE9mZnNldCk7XG4gICAgICAgICAgICBuT2Zmc2V0ID0gcF9kYXRhLmxlZnRPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvL3Byb2Nlc3MgdGhlIHRleHRcblxuICAgICAgICBpZihjdXJUeHQubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgIHBfZGF0YS5zdG9yZWRUZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICB7ICAgLy8gbm8gdGV4dCBhbmQgbm8gc3RvcmVkIHRleHQgc28gc3RhcnQgbm90IHJlYWNoZWQgeWV0LlxuICAgICAgICAgICAgcF9kYXRhLnN0YXJ0UmVmUHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaWYocF9kYXRhLnN0YXJ0UmVmUHQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHBfZGF0YS5zdG9yZWRUZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgeyAgIC8vIHJlYWNoZWQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0LCBzdG9yZSB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgIHBfZGF0YS5zdGFydFJlZlB0ID0gc3Nkb20ucndfZ2V0UmVmUHQoY3VyTm9kZSwgbk9mZnNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgdGV4dCwgYnJlYWtpbmcgYXQgZWFjaCB3b3JkIHRvIHN0b3JlIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICB2YXIgblBvcyA9IHNzZG9tLnJ3X2dldEJyZWFrSW5DdXJyZW50V29yZChjdXJUeHQpO1xuICAgICAgICAgICAgd2hpbGUoblBvcyA+IC0xKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEJyZWFrIGluIG1pZGRsZSBvZiB0ZXh0LCBhZGQgdGV4dCBiZWZvcmUgYnJlYWsgdG8gcHJldmlvdXMgdGV4dCBpZiBpdCBleGlzdHMuXG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgdGV4dCB1cCB0byBicmVhayBhbmQgbGVhdmUgdGV4dCBhZnRlciBicmVhayBmb3IgbmV4dCBsb29wXG4gICAgICAgICAgICAgICAgdmFyIHN0cldvcmRUb0FkZCA9IHBfZGF0YS5zdG9yZWRUZXh0ICsgY3VyVHh0LnN1YnN0cmluZygwLCBuUG9zICsgMSk7XG4gICAgICAgICAgICAgICAgcF9kYXRhLnN0b3JlZFRleHQgPSB0aGlzLmZpbHRlcldvcmRUb1NwZWFrKHN0cldvcmRUb0FkZCk7XG5cbiAgICAgICAgICAgICAgICBpZihwX2RhdGEuZW5kUmVmUHQgPT0gbnVsbCB8fCBuUG9zICE9IDApXG4gICAgICAgICAgICAgICAgeyAgIC8vIElmIHBvaW50IGlzIGF0IHN0YXJ0IG9mIHRoZSBub2RlIHRoZW4gY2FuIHVzZSB0aGUgcHQgc2V0IGF0IHRoZSBlbmQgb2YgdGhlIGxhc3Qgbm9kZSBpZiBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgblBvcyA+IDAgYWx3YXlzIG5lZWQgbmV3IHB0IHdoZXRoZXIgZXhpc3RzIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICBwX2RhdGEuZW5kUmVmUHQgPSBzc2RvbS5yd19nZXRSZWZQdChjdXJOb2RlLCBuUG9zICsgbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2lsbCBwcm9jZXNzIGl0IGlmIHN1aXRhYmxlIHdvcmQgc3RvcmVkLlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0b3JlZFRleHRUb1dvcmRPYmplY3QocF9kYXRhKTtcblxuICAgICAgICAgICAgICAgIC8vc3BlZWNoIGxlbmd0aCBjaGVja1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuY2hlY2tJZlRvb0xvbmcocF9kYXRhKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBfZGF0YS5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgbmV4dCByYW5nZSBzdGFydGVkXG4gICAgICAgICAgICAgICAgbk9mZnNldCArPSBuUG9zICsgMTtcbiAgICAgICAgICAgICAgICBjdXJUeHQ9IGN1clR4dC5zdWJzdHJpbmcoblBvcyArIDEpO1xuXG4gICAgICAgICAgICAgICAgcF9kYXRhLnN0YXJ0UmVmUHQgPSBzc2RvbS5yd19nZXRSZWZQdChjdXJOb2RlLCBuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBwX2RhdGEuZW5kUmVmUHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG5Qb3MgPSBzc2RvbS5yd19nZXRCcmVha0luQ3VycmVudFdvcmQoY3VyVHh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoY3VyVHh0Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gdGV4dCByZW1haW5pbmcgdG8gYmUgcHJvY2Vzc2VkIHRoYXQgZG9lcyBub3QgZW5kIHdpdGggc2VudGVuY2UgYnJlYWsuICBXaWxsIGNvbnRpbnVlIHRvIG5leHQgbG9vcC5cbiAgICAgICAgICAgICAgICBwX2RhdGEuc3RvcmVkVGV4dCArPSBjdXJUeHQ7XG4gICAgICAgICAgICAgICAgLy8gc2V0IGVuZCByZWYgcHQgdG8gZW5kIG9mIGN1cnJlbnQgbm9kZSAob3IgbGVzcyBpZiByaWdodCBtb3N0KVxuICAgICAgICAgICAgICAgIHBfZGF0YS5lbmRSZWZQdCA9IHNzZG9tLnJ3X2dldFJlZlB0KGN1ck5vZGUsIGN1clR4dC5sZW5ndGggKyBuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZihwX2RhdGEuZW5kUmVmUHQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB7ICAgLy8gZXJyb3IgY2hlY2ssIGlmIGNhbm5vdCBnZXQgZW5kIHJlZiBjYW5ub3Qgc3BlYWsgdGhlIHN0b3JlZCB0ZXh0LCBzZXQgZW1wdHkgdG8gcHJldmVudCBudWxsIGV4Y2VwdGlvbiBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgcF9kYXRhLnN0b3JlZFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgYXQgZW5kXG4gICAgICAgICAgICBpZihjdXJOb2RlID09IHBfZGF0YS5yaWdodE5vZGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU3RvcmVkVGV4dFRvV29yZE9iamVjdChwX2RhdGEpO1xuICAgICAgICAgICAgICAgIHBfZGF0YS5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3ZlVG9OZXh0Tm9kZShwX2RhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSB0ZXh0IG5lZWRzIHRvIGJlIGFsdGVyZWRcbiAgICAgKiBAcGFyYW0gcF9zdHJUZXh0XG4gICAgICovXG4gICAgICAgIGZpbHRlcldvcmRUb1NwZWFrKHBfc3RyVGV4dClcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgdXRpbHMgPSBuZXcgVXRpbGl0aWVzKCk7XG4gICAgICAgIGlmKHV0aWxzLnRyaW0ocF9zdHJUZXh0KSA9PSBcIipcIilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGlmIHVzZSBtYXRocyBhbmQgKiBpcyBpbmNsdWRlZCB0aGVuIGtlZXAuXG4vLyAgICAgICAgICB0b2RvICBpZighICgvKmdfYk1hdGhzU3ltYm9scyAmJiovIHNzZG9tLnJ3X21hdGhzU3ltYm9sQ2hlY2soXCIqXCIpKSApXG4vLyAgICAgICAgICAgIHsgICAvLyBub3JtYWwgY2FzZSBzbyByZW1vdmUgc28gZG9lcyBub3Qgc2F5IFwiYXN0ZXJpeFwiLlxuLy8gICAgICAgICAgICAgICAgcF9zdHJUZXh0ID0gXCJcIjtcbi8vICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBfc3RyVGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGhhbmRsZXMgbm9uIHNwZWNpYWwgY2FzZSBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIgdGhpcyBjYW4gaW5jbHVkZSBTU01MIGVsZW1lbnQgaGFuZGxpbmcuXG4gICAgICogQHBhcmFtIHBfZGF0YVxuICAgICAqL1xuICAgICAgICBoYW5kbGVFbGVtZW50KHBfZGF0YSlcbiAgICB7XG4gICAgICAgIHZhciBjdXJOb2RlID0gcF9kYXRhLmN1cnJlbnROb2RlO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBTU01MXG4gICAgICAgIHZhciBzc21sRWxlbSA9IHRoaXMuY2hlY2tGb3JTc21sQXR0cmlidXRlKGN1ck5vZGUpO1xuXG4gICAgICAgIGlmKHNzbWxFbGVtICE9IG51bGwpLy90b2RvXG4gICAgICAgIHsgICAvLyBuZXN0IGl0ZW1zIGluc2lkZSBhbiBTU01MIGVsZW1lbnQuICBUaGlzIGlzIGFsd2F5cyB3b3JkIGJyZWFrLlxuLy8gICAgICAgICAgICB0aGlzLm1vdmVTdG9yZWRUZXh0VG9Xb3JkT2JqZWN0KHBfZGF0YSk7XG4vL1xuLy8gICAgICAgICAgICBpZihjdXJOb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMClcbi8vICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgLy8gc2V0IGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IHdpdGggZXZlcnl0aGluZyBjcmVhdGVkIGJ5IG5lc3RlZCBjYWxsLlxuLy8gICAgICAgICAgICAgICAgdmFyIG5ld0xlZnRDYXJldCA9IG5ldyBUSENhcmV0KGN1ck5vZGUuZmlyc3RDaGlsZCwgMCwgdHJ1ZSk7XG4vLyAgICAgICAgICAgICAgICB2YXIgbmV3UmlnaHRDYXJldCA9IG5ldyBUSENhcmV0KGN1ck5vZGUubGFzdENoaWxkLFxuLy8gICAgICAgICAgICAgICAgICAgICgoY3VyTm9kZS5sYXN0Q2hpbGQubm9kZVR5cGU9PTMpP2N1ck5vZGUubGFzdENoaWxkLm5vZGVWYWx1ZS5sZW5ndGg6LTEpLFxuLy8gICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcbi8vICAgICAgICAgICAgICAgIHZhciBuZXdTZW50T2JqID0gbmV3IFNlbnRlbmNlT2JqZWN0KG5ldyBUSENhcmV0UmFuZ2UobmV3TGVmdENhcmV0LCBuZXdSaWdodENhcmV0KSk7XG4vLyAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUZXh0VG9TcGVha0luU2VudGVuY2VPYmplY3RJbXBsKG5ld1NlbnRPYmopO1xuLy8gICAgICAgICAgICAgICAgaWYobmV3U2VudE9iai5pc1ZhbGlkKCkpXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgc3NtbEVsZW0uc2V0Q29udGVudHMobmV3U2VudE9iai5nZXRDb250ZW50cygpKTtcbi8vICAgICAgICAgICAgICAgICAgICBwX2RhdGEuc2VudGVuY2VPYmplY3QuYWRkQ29udGVudChzc21sRWxlbSk7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgZWxzZSBpZihzc21sRWxlbSBpbnN0YW5jZW9mIFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uQnJlYWtFbGVtZW50KVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICBwX2RhdGEuc2VudGVuY2VPYmplY3QuYWRkQ29udGVudChzc21sRWxlbSk7XG4vLyAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgIC8vIG1vdmUgdG8gbmV4dCwgYXMgc3BlY2lhbCBjYXNlIG5ldmVyIGdvIHRvIGNoaWxkIG5vZGVzXG4vLyAgICAgICAgICAgIHBfZGF0YS5jdXJyZW50Tm9kZSA9IFNTRE9NLmdldE5leHROb2RlSWdub3JlQ2hpbGRyZW4oY3VyTm9kZSwgZmFsc2UsIHBfZGF0YS5yaWdodE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaXMgYnJlYWsgZWxlbWVudFxuLy8gICAgICAgICAgICBpZihTcGVlY2hTdHJlYW0ucGF1c2VIYW5kbGVyLmlzUGF1c2VFbGVtZW50KGN1ck5vZGUpKSAvL3RvZG9cbi8vICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgbW92ZVN0b3JlZFRleHRUb1dvcmRPYmplY3QocF9kYXRhKTtcbi8vXG4vL1xuLy8gICAgICAgICAgICAgICAgdmFyIG5UaW1lID0gU3BlZWNoU3RyZWFtLnBhdXNlSGFuZGxlci5nZXRQYXVzZVRpbWVGcm9tTm9kZShjdXJOb2RlKTtcbi8vICAgICAgICAgICAgICAgIGlmKCFpc05hTihuVGltZSkpXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgdmFyIHNpbGVuY2VFbGVtID0gbmV3IFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uU2lsZW5jZU9iamVjdChcIlwiICsgblRpbWUpO1xuLy8gICAgICAgICAgICAgICAgICAgIHBfZGF0YS5zZW50ZW5jZU9iamVjdC5hZGRDb250ZW50KHNpbGVuY2VFbGVtKTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1vdmVUb05leHROb2RlKHBfZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb3ZlVG9OZXh0Tm9kZShwX2RhdGEpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGRvbU5hdiA9IG5ldyBEb21OYXZpZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjdXJOb2RlID0gcF9kYXRhLmN1cnJlbnROb2RlO1xuXG4gICAgICAgIC8vIG1vdmUgdG8gbmV4dCwgY2hlY2sgZm9yIGJyZWFrIHBvaW50cyAoZGl2IHAgZXRjKVxuICAgICAgICB2YXIgdG1wTm90ZSA9IGRvbU5hdi5nZXROZXh0Tm9kZShjdXJOb2RlLCB0cnVlLCBwX2RhdGEucmlnaHROb2RlKTtcbiAgICAgICAgaWYodG1wTm90ZSA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBoaXQgYSBicmVhayBwb2ludCwgbW92ZSBhbnkgc3RvcmVkIHRleHQgdG8gd29yZCBvYmplY3RcbiAgICAgICAgICAgIHBfZGF0YS5zdG9yZWRUZXh0ID0gdGhpcy5nZXRUZXh0T3ZlclJhbmdlVG9TcGVha0FkZEZ1bGxTdG9wKHBfZGF0YS5zdG9yZWRUZXh0KTtcbiAgICAgICAgICAgIHRoaXMubW92ZVN0b3JlZFRleHRUb1dvcmRPYmplY3QocF9kYXRhKTtcblxuICAgICAgICAgICAgcF9kYXRhLmN1cnJlbnROb2RlID0gZG9tTmF2LmdldE5leHROb2RlKGN1ck5vZGUsIGZhbHNlLCBwX2RhdGEucmlnaHROb2RlKTtcblxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcF9kYXRhLmN1cnJlbnROb2RlID0gdG1wTm90ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYWRkcyBhIGZ1bGwgc3RvcCB0byBlbmQgb2YgdGhlIHRleHQgdG8gbWFrZSB0aGUgc3BlZWNoIGVuZ2luZSB0cmVhdCBpdCBhcyBhIHNlbnRlbmNlIHdoZW4gc3BlYWtpbmcgaXQuXG4gICAgICogVGhpcyBpcyBmb3IgbmljaGUgY2FzZSB3aGVyZSByYW5nZSBpbmNsdWRlcyBzZW50ZW5jZSBicmVhayBlbGVtZW50cyB3aXRob3V0IHRoZSBmaXJzdCBzZW50ZW5jZSBlbmRpbmcgaW5cbiAgICAgKiBmdWxsIHN0b3AuICBUaGlzIHdvdWxkIGxlYWQgdG8gJ2EgYicgcmF0aGVyIHRoYW4gJ2EuIGInIGJldHdlZW4gc2VudGVuY2VzIHNvIHdvdWxkIG5vdCBwYXVzZSBjb3JyZWN0bHlcbiAgICAgKiB3aGVuIHJlYWRpbmcuXG4gICAgICogQHBhcmFtIHBfc3RvcmVkVGV4dFxuICAgICAqL1xuICAgICAgICBnZXRUZXh0T3ZlclJhbmdlVG9TcGVha0FkZEZ1bGxTdG9wKHBfc3RvcmVkVGV4dClcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgdG1wTGVuID0gcF9zdG9yZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWxyZWFkeSBlbmRzIHdpdGggJy4nIG9yICcuICdcbiAgICAgICAgaWYodG1wTGVuID4gMSAmJiBwX3N0b3JlZFRleHQuc3Vic3RyKHRtcExlbiAtIDIsIDIpID09IFwiLiBcIilcbiAgICAgICAge1xuICAgICAgICAgICAgLy9ubyBuZWVkIHRvIGFkZCB0byBpdFxuICAgICAgICAgICAgcmV0dXJuIHBfc3RvcmVkVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRtcExlbiA+IDAgJiYgcF9zdG9yZWRUZXh0LnN1YnN0cih0bXBMZW4gLSAxLCAxKSA9PSBcIi5cIilcbiAgICAgICAge1xuICAgICAgICAgICAgLy9qdXN0IGFkZCB0aGUgc3BhY2VcbiAgICAgICAgICAgIHJldHVybiBwX3N0b3JlZFRleHQgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgbGFzdCBjaGFyYWN0ZXIsIG9ubHkgYWRkIGEgZnVsbCBzdG9wIGFmdGVyIGEgbGV0dGVyLlxuICAgICAgICAgICAgLy8od2l0aCBudW1iZXIgbWF5IGhpdCBzcGVlY2ggZW5naW5lIGJ1ZyBhbmQgc2F5ICdvbmUgcG9pbnQnIGZvciAxLilcbiAgICAgICAgICAgIHZhciB1dGlscyA9IG5ldyBVdGlsaXRpZXMoKTtcbiAgICAgICAgICAgIHZhciB0eHQgPSB1dGlscy50cmltRW5kVEgocF9zdG9yZWRUZXh0KTtcbiAgICAgICAgICAgIHZhciBjID0gdHh0LmNoYXJDb2RlQXQodHh0Lmxlbmd0aCAtIDEpO1xuXG4gICAgICAgICAgICBpZihzc2RvbS5yd19pc0xldHRlcihjKSB8fCBjID4gMTI3KVxuICAgICAgICAgICAgeyAgIC8vIGFkZCB0aGUgJy4gJ1xuICAgICAgICAgICAgICAgIHJldHVybiAgcF9zdG9yZWRUZXh0ICsgXCIuIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBwX3N0b3JlZFRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aGF0IHRoZSB0b29sYmFyIGNvbnNpZGVycyBzcGVjaWFsIGNhc2VzIChsaWtlIHNwYW4gcHJvbj0uLi4pXG4gICAgICogQHBhcmFtIHBfZGF0YVxuICAgICAqL1xuICAgICAgICBoYW5kbGVTcGVjaWFsQ2FzZShwX2RhdGEpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGRvbU5hdiA9IG5ldyBEb21OYXZpZ2F0aW9uKCk7XG4gICAgICAgIC8vIEVuc3VyZSBhbnkgc3RvcmVkIHRleHQgaXMgcHJvY2Vzc2VkIGJlZm9yZSBoYW5kbGluZyBzcGVjaWFsIGNhc2UuXG4gICAgICAgIHRoaXMubW92ZVN0b3JlZFRleHRUb1dvcmRPYmplY3QocF9kYXRhKTtcblxuICAgICAgICB2YXIgY3VyTm9kZSA9IHBfZGF0YS5jdXJyZW50Tm9kZTtcblxuICAgICAgICAvL0dldCB0ZXh0XG4gICAgICAgIHBfZGF0YS5zdG9yZWRUZXh0ID0gZG9tTmF2LmdldFRleHRGcm9tTm9kZShjdXJOb2RlKTtcblxuICAgICAgICAvL0dldCByZWYgcHRzXG4gICAgICAgIGlmKHNzZG9tLmlzU3BlY2lhbENhc2VIaWdobGlnaHRhYmxlKGN1ck5vZGUpKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gZG9tTmF2LmdldEZpcnN0Q2hpbGRUZXh0Tm9kZShjdXJOb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSBkb21OYXYuZ2V0TGFzdENoaWxkVGV4dE5vZGUoY3VyTm9kZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBpZihmaXJzdE5vZGUgIT0gbnVsbCAmJiBsYXN0Tm9kZSAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKGZpcnN0Tm9kZS5ub2RlVHlwZSA9PSAzICYmIGxhc3ROb2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwX2RhdGEuc3RhcnRSZWZQdCA9IHNzZG9tLnJ3X2dldFJlZlB0KGZpcnN0Tm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHBfZGF0YS5lbmRSZWZQdCA9IHNzZG9tLnJ3X2dldFJlZlB0KGxhc3ROb2RlLCBsYXN0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHsgICAvLyBzaG91bGQgYmUgZm9yIHRhZ05hbWUgaXMgXCJtYXRoXCIgZm9yIG1hdGhtbCBvciBmaXJzdE5vZGUuaXNNYXRoSmF4XG4gICAgICAgICAgICAgICAgICAgIHBfZGF0YS5zdGFydFJlZlB0ID0gc3Nkb20ucndfZ2V0UmVmUHQoZmlyc3ROb2RlLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHBfZGF0YS5lbmRSZWZQdCA9IHNzZG9tLnJ3X2dldFJlZlB0KGxhc3ROb2RlLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBfZGF0YS5zdGFydFJlZlB0ID0gc3Nkb20ucndfZ2V0UmVmUHQoY3VyTm9kZSwgLTEpO1xuICAgICAgICAgICAgICAgIHBfZGF0YS5lbmRSZWZQdCA9IHBfZGF0YS5zdGFydFJlZlB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcF9kYXRhLnN0YXJ0UmVmUHQgPSBzc2RvbS5yd19nZXRSZWZQdChjdXJOb2RlLCAtMSk7XG4gICAgICAgICAgICBwX2RhdGEuZW5kUmVmUHQgPSBwX2RhdGEuc3RhcnRSZWZQdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3JlIHdvcmRcbiAgICAgICAgdGhpcy5tb3ZlU3RvcmVkVGV4dFRvV29yZE9iamVjdChwX2RhdGEpO1xuXG4gICAgICAgIC8vIG1vdmUgdG8gbmV4dCwgYXMgc3BlY2lhbCBjYXNlIG5ldmVyIGdvIHRvIGNoaWxkIG5vZGVzXG4gICAgICAgIHBfZGF0YS5jdXJyZW50Tm9kZSA9IGRvbU5hdi5nZXROZXh0Tm9kZUlnbm9yZUNoaWxkcmVuKGN1ck5vZGUsIGZhbHNlLCBwX2RhdGEucmlnaHROb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgY3VycmVudCBzdG9yZWQgdGV4dCB0byB0aGUgc2VudGVuY2UsIGFzIGxvbmcgYXMgaXMgc3BlYWthYmxlIGFuZCBhbHNvIGlmIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZVxuICAgICAqIHNldC5cbiAgICAgKiBAcGFyYW0gcF9kYXRhXG4gICAgICovXG4gICAgICAgIG1vdmVTdG9yZWRUZXh0VG9Xb3JkT2JqZWN0KHBfZGF0YSlcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICBpZihzc2RvbS5yd19pc1dvcmRTcGVha2FibGUocF9kYXRhLnN0b3JlZFRleHQpICYmXG4gICAgICAgICAgICBwX2RhdGEuc3RhcnRSZWZQdCAhPSBudWxsICYmXG4gICAgICAgICAgICBwX2RhdGEuZW5kUmVmUHQgIT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRtcCA9IG5ldyBXb3JkT2JqZWN0KFxuICAgICAgICAgICAgICAgIG5ldyBUSFJhbmdlKHBfZGF0YS5ib2R5LCBwX2RhdGEuc3RhcnRSZWZQdCwgcF9kYXRhLmVuZFJlZlB0KSxcbiAgICAgICAgICAgICAgICBwX2RhdGEuc3RvcmVkVGV4dCk7XG4gICAgICAgICAgICBwX2RhdGEuc2VudGVuY2VPYmplY3QuYWRkQ29udGVudCh0bXApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZShwX2RhdGEpO1xuICAgIH1cblxuICAgIGNsZWFyU3RhdGUocF9kYXRhKVxuICAgIHtcbiAgICAgICAgcF9kYXRhLnN0YXJ0UmVmUHQgPSBudWxsO1xuICAgICAgICBwX2RhdGEuZW5kUmVmUHQgPSBudWxsO1xuICAgICAgICBwX2RhdGEuc3RvcmVkVGV4dCA9IFwiXCI7XG4gICAgfVxuXG4gICAgY2hlY2tJZlRvb0xvbmcocF9kYXRhKVxuICAgIHtcbiAgICAgICAgdmFyIE1BWF9XT1JEQ09VTlRfVE9fU1BFQUsgPSA1MDA7IC8vdG9kb1xuICAgICAgICAvL3NwZWVjaCBsZW5ndGggY2hlY2tcbiAgICAgICAgaWYoTUFYX1dPUkRDT1VOVF9UT19TUEVBSyA+IDAgJiYgcF9kYXRhLnNlbnRlbmNlT2JqZWN0LmdldFdvcmRDb3VudCgpID4gTUFYX1dPUkRDT1VOVF9UT19TUEVBSylcbiAgICAgICAgeyAgIC8vIHRvbyBsb25nXG4vLyAgICAgICAgICAgIGlmKGdfYlNwZWVjaENhY2hlR2VuZXJhdGVGbGFnKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICB0aHJvdyBcIkZ1bGwgc2VsZWN0aW9uIHdpbGwgbm90IGJlIHNwb2tlbiBkdWUgdG8gaXRzIGxlbmd0aC5cIjtcbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICBlbHNlXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIHJ3X2FsZXJ0KFwiRnVsbCBzZWxlY3Rpb24gd2lsbCBub3QgYmUgc3Bva2VuIGR1ZSB0byBpdHMgbGVuZ3RoLlwiKTtcbi8vICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cENoZWNrKHBfZGF0YSlcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICB2YXIgZG9tTmF2ID0gbmV3IERvbU5hdmlnYXRpb24oKTtcbiAgICAgICAgLy8gQXQgc3RhcnQgbmVlZCB0byBjaGVjayBpZiB0aGUgc3RhcnRpbmcgbm9kZSBpcyBzdWl0YWJsZSBwbGFjZS5cbiAgICAgICAgLy8gSWYgaXQgaXMgYW4gZWxlbWVudCBhbmQgbm90IGEgc3BlY2lhbCBjYXNlIG5lZWQgdG8gbW92ZSB0byBuZXh0IHRleHQgbm9kZS5cbiAgICAgICAgLy8gSW5jbHVkZSBtb3Zpbmcgb3ZlciBicmVha3MgaWYgbm8gbWF0Y2ggYmVmb3JlIHRoYXQsIGlmIG5vdGhpbmcgYmVmb3JlIGJyZWFrLCB0aGVuIG5vdGhpbmcgdG8gYWRkLlxuICAgICAgICBpZihwX2RhdGEubGVmdE5vZGUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYoIXNzZG9tLmlzU3BlY2lhbENhc2UocF9kYXRhLmxlZnROb2RlKSAmJiB0aGlzLmNoZWNrRm9yU3NtbEF0dHJpYnV0ZShwX2RhdGEubGVmdE5vZGUpID09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcF9kYXRhLmxlZnROb2RlID0gZG9tTmF2LmdldE5leHROb2RlQWxsb3dNb3ZlVG9DaGlsZChwX2RhdGEuY3VycmVudE5vZGUsIGZhbHNlLCBwX2RhdGEucmlnaHROb2RlKTtcbiAgICAgICAgICAgICAgICBwX2RhdGEubGVmdE9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzc21sXG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNoZWNrcyBmb3IgU1NNTCB3aGVyZSB0aGUgU1NNTCBpcyBpbmNsdWRlZCBpbiB0aGUgSFRNTCBhcyBhdHRyaWJ1dGUgU1NNTCBhbmQgc2VwYXJhdGUgYXR0cmlidWVcbiAgICAgKiBnaXZpbmcgdGhlIGRldGFpbHMuICBTbyBzc21sPVwic3ViICBhbGlhcz1cIi4uLlwiXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcF9jdXJOb2RlXG4gICAgICovXG4gICAgICAgIGNoZWNrRm9yU3NtbEF0dHJpYnV0ZShwX2N1ck5vZGUpXG4gICAge1xuICAgICAgICBpZihwX2N1ck5vZGUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2tGb3JTc21sTm9OYW1lc3BhY2UocF9jdXJOb2RlKTtcbiAgICAgICAgICAgIGlmKHJlc3VsdCAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2hlY2tGb3JTc21sTmFtZXNwYWNlKHBfY3VyTm9kZSk7XG4gICAgICAgICAgICBpZihyZXN1bHQgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBzc21sIGluIGZvcm1hdCBzc21sOjxjb25maWc+PVwiXCIgLi4uXG4gICAgICpcbiAgICAgKiBBY2NvcmRpbmcgdG8gc3RhbmRhcmQgZm9yIHRoaXMgKHNvIGZhcikgd2l0aCB0aGlzIHRoZXJlIHNob3VsZCBiZSBhIHBhZ2UgbGV2ZWwgdmFsdWVcbiAgICAgKiBAcGFyYW0gcF9jdXJOb2RlXG4gICAgICovXG4gICAgICAgIGNoZWNrRm9yU3NtbE5hbWVzcGFjZShwX2N1ck5vZGUpXG4gICAge1xuICAgICAgICAvL3RvZG9cbi8vICAgICAgICB2YXIgaHRtbEVsZW0gPSBwX2N1ck5vZGUub3duZXJEb2N1bWVudC5ib2R5LnBhcmVudE5vZGU7XG4vLyAgICAgICAgaWYocndfZ2V0QXR0cmlidXRlKGh0bWxFbGVtLCBcInhtbG5zOnNzbWxcIikpXG4vLyAgICAgICAge1xuLy8gICAgICAgICAgICAvLyBjaGVjayBmb3IgcGFnZSBsZXZlbCBhbHBoYWJldFxuLy8gICAgICAgICAgICB2YXIgc3RyQWxwaGEgPSByd19nZXRBdHRyaWJ1dGUoaHRtbEVsZW0sIFNTTUxfTkFNRVNQQUNFICsgXCI6XCIgKyBTU01TX0FUVFJJQlVURVMuQUxQSEFCRVQpO1xuLy9cbi8vICAgICAgICAgICAgLy8gdG9kbyBzd2l0Y2ggdG8gdXNpbmcgcndfZ2V0QXR0cmlidXRlXG4vL1xuLy8gICAgICAgICAgICBpZihyd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01MX05BTUVTUEFDRSArIFwiOlwiICsgU1NNU19BVFRSSUJVVEVTLlBIKSkgIC8vUEhPTkVNRVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICB2YXIgc3RyTG9jYWxBbHBoYSA9IHJ3X2dldEF0dHJpYnV0ZShwX2N1ck5vZGUsIFNTTUxfTkFNRVNQQUNFICsgXCI6XCIgKyBTU01TX0FUVFJJQlVURVMuQUxQSEFCRVQpO1xuLy8gICAgICAgICAgICAgICAgdmFyIHN0clBoID0gcndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNTF9OQU1FU1BBQ0UgKyBcIjpcIiArIFNTTVNfQVRUUklCVVRFUy5QSCk7XG4vL1xuLy8gICAgICAgICAgICAgICAgaWYoc3RyTG9jYWxBbHBoYSA9PSBudWxsKVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIHN0ckxvY2FsQWxwaGEgPSBzdHJBbHBoYTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgICAgICBpZihzdHJMb2NhbEFscGhhICE9IG51bGwgJiYgc3RyUGggIT0gbnVsbClcbi8vICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uUGhvbmVtZUVsZW1lbnQocF9jdXJOb2RlLCBzdHJMb2NhbEFscGhhLCBzdHJQaCk7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgIGlmKHJ3X2dldEF0dHJpYnV0ZShwX2N1ck5vZGUsIFNTTUxfTkFNRVNQQUNFICsgXCI6XCIgKyBTU01TX0FUVFJJQlVURVMuQUxJQVMpKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICB2YXIgc3RyQWxpYXMgPSByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01MX05BTUVTUEFDRSArIFwiOlwiICsgU1NNU19BVFRSSUJVVEVTLkFMSUFTICk7IC8vc3ViXG4vL1xuLy8gICAgICAgICAgICAgICAgaWYoc3RyQWxpYXMgIT0gbnVsbClcbi8vICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uU3ViRWxlbWVudChwX2N1ck5vZGUsIHN0ckFsaWFzKTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgICAgaWYocndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNTF9OQU1FU1BBQ0UgKyBcIjpcIiArIFNTTVNfQVRUUklCVVRFUy5JTlRFUlBSRVRBUykpXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIHZhciBzdHJJbnQgPSByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01MX05BTUVTUEFDRSArIFwiOlwiICsgU1NNU19BVFRSSUJVVEVTLklOVEVSUFJFVEFTICk7IC8vc2F5YXNcbi8vICAgICAgICAgICAgICAgIHZhciBzdHJGb3JtYXQgPSByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01MX05BTUVTUEFDRSArIFwiOlwiICsgU1NNU19BVFRSSUJVVEVTLkZPUk1BVCApOyAvL3NheWFzXG4vL1xuLy8gICAgICAgICAgICAgICAgaWYoc3RySW50ICE9IG51bGwpXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGVlY2hTdHJlYW0uc3BlZWNoRG9tLlNheWFzRWxlbWVudChwX2N1ck5vZGUsIHN0ckludCwgc3RyRm9ybWF0KTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgICAgaWYocndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNTF9OQU1FU1BBQ0UgKyBcIjpcIiArIFNTTVNfVFlQRVMuRU1QSEFTSVMpKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICB2YXIgc3RyTGV2ZWwgPSByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01MX05BTUVTUEFDRSArIFwiOlwiICsgU1NNU19BVFRSSUJVVEVTLkxFVkVMICk7IC8vZW1waGFzaXNcbi8vXG4vLyAgICAgICAgICAgICAgICBpZihzdHJMZXZlbCAhPSBudWxsKVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3BlZWNoU3RyZWFtLnNwZWVjaERvbS5FbXBoYXNpc0VsZW1lbnQocF9jdXJOb2RlLCBzdHJMZXZlbCk7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgIGlmKHJ3X2dldEF0dHJpYnV0ZShwX2N1ck5vZGUsIFNTTUxfTkFNRVNQQUNFICsgXCI6XCIgKyBTU01TX1RZUEVTLkJSRUFLKSlcbi8vICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgdmFyIHN0clRpbWUgPSByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01MX05BTUVTUEFDRSArIFwiOlwiICsgU1NNU19BVFRSSUJVVEVTLlRJTUUgKTsgLy9icmVha1xuLy8gICAgICAgICAgICAgICAgdmFyIHN0clN0cmVuZ3RoID0gcndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNTF9OQU1FU1BBQ0UgKyBcIjpcIiArIFNTTVNfQVRUUklCVVRFUy5TVFJFTkdUSCApOyAvL2JyZWFrXG4vL1xuLy8gICAgICAgICAgICAgICAgaWYoc3RyVGltZSAhPSBudWxsKVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3BlZWNoU3RyZWFtLnNwZWVjaERvbS5CcmVha0VsZW1lbnQocF9jdXJOb2RlLCBzdHJUaW1lLCBzdHJTdHJlbmd0aCk7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIH1cbi8vXG4vL1xuLy8gICAgICAgICAgICBpZihyd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01MX05BTUVTUEFDRSArIFwiOlwiICsgU1NNU19UWVBFUy5QUk9TT0RZKSlcbi8vICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgdmFyIHN0clBpdGNoID0gcndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNTF9OQU1FU1BBQ0UgKyBcIjpcIiArIFNTTVNfQVRUUklCVVRFUy5QSVRDSCApOyAvL3Byb3NvZHlcbi8vICAgICAgICAgICAgICAgIHZhciBzdHJSYXRlID0gcndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNTF9OQU1FU1BBQ0UgKyBcIjpcIiArIFNTTVNfQVRUUklCVVRFUy5SQVRFICk7IC8vcHJvc29keVxuLy8gICAgICAgICAgICAgICAgdmFyIHN0clZvbHVtZSA9IHJ3X2dldEF0dHJpYnV0ZShwX2N1ck5vZGUsIFNTTUxfTkFNRVNQQUNFICsgXCI6XCIgKyBTU01TX0FUVFJJQlVURVMuVk9MVU1FICk7IC8vcHJvc29keVxuLy9cbi8vICAgICAgICAgICAgICAgIGlmKHN0clRpbWUgIT0gbnVsbClcbi8vICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uUHJvc29keUVsZW1lbnQocF9jdXJOb2RlLCBzdHJQaXRjaCwgc3RyUmF0ZSwgc3RyVm9sdW1lKTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgZm9yIHRoZSBzc21sIGZvcm1hdCBvZiAgc3NtbD1cIjx0eXBlPlwiIDxjb25maWcgbmFtZT49XCJcIlxuICAgICAqIEBwYXJhbSBwX2N1ck5vZGVcbiAgICAgKi9cbiAgICAgICAgY2hlY2tGb3JTc21sTm9OYW1lc3BhY2UocF9jdXJOb2RlKVxuICAgIHtcbiAgICAgICAgLy90b2RvXG4vLyAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4vLyAgICAgICAgaWYoc3Nkb20ucndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgdGhpcy5TU01MX05BTUVTUEFDRSkpXG4vLyAgICAgICAge1xuLy8gICAgICAgICAgICB2YXIgc3RyU3NtbFR5cGUgPSBzc2RvbS5yd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCB0aGlzLlNTTUxfTkFNRVNQQUNFKTtcbi8vICAgICAgICAgICAgLy8gaGFzIHNzbWxcbi8vICAgICAgICAgICAgaWYoc3RyU3NtbFR5cGUgPT0gdGhpcy5TU01TX1RZUEVTLlBIT05FTUUpXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIHZhciBzdHJBbHBoYSA9IFwiaXBhXCI7XG4vLyAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhbHBoYWJldCB2YWx1ZSBpbiBlbGVtZW50XG4vLyAgICAgICAgICAgICAgICBpZihzc2RvbS5yd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCB0aGlzLlNTTVNfQVRUUklCVVRFUy5BTFBIQUJFVCkgIT09IG51bGwpXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgc3RyQWxwaGEgPSBzc2RvbS5yd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCB0aGlzLlNTTVNfQVRUUklCVVRFUy5BTFBIQUJFVCk7XG4vLyAgICAgICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGVlY2hTdHJlYW0uc3BlZWNoRG9tLlBob25lbWVFbGVtZW50KHBfY3VyTm9kZSwgc3RyQWxwaGEsIHJ3X2dldEF0dHJpYnV0ZShwX2N1ck5vZGUsIFNTTVNfQVRUUklCVVRFUy5QSCkpO1xuLy8gICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICBpZihzdHJTc21sVHlwZSA9PSBTU01TX1RZUEVTLlNVQilcbi8vICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgaWYocndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNU19BVFRSSUJVVEVTLkFMSUFTKSlcbi8vICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uU3ViRWxlbWVudChwX2N1ck5vZGUsIHJ3X2dldEF0dHJpYnV0ZShwX2N1ck5vZGUsIFNTTVNfQVRUUklCVVRFUy5BTElBUykpO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICBpZihzdHJTc21sVHlwZSA9PSBTU01TX1RZUEVTLlNBWUFTKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICBpZihyd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01TX0FUVFJJQlVURVMuSU5URVJQUkVUQVMpKVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3BlZWNoU3RyZWFtLnNwZWVjaERvbS5TYXlhc0VsZW1lbnQocF9jdXJOb2RlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01TX0FUVFJJQlVURVMuSU5URVJQUkVUQVMpLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01TX0FUVFJJQlVURVMuRk9STUFUKSk7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIH1cbi8vXG4vL1xuLy8gICAgICAgICAgICBpZihzdHJTc21sVHlwZSA9PSBTU01TX1RZUEVTLkVNUEhBU0lTKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwZWVjaFN0cmVhbS5zcGVlY2hEb20uRW1waGFzaXNFbGVtZW50KHBfY3VyTm9kZSxcbi8vICAgICAgICAgICAgICAgICAgICByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01TX0FUVFJJQlVURVMuTEVWRUwpKTtcbi8vICAgICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgICAgaWYoc3RyU3NtbFR5cGUgPT0gU1NNU19UWVBFUy5CUkVBSylcbi8vICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGVlY2hTdHJlYW0uc3BlZWNoRG9tLkJyZWFrRWxlbWVudChwX2N1ck5vZGUsXG4vLyAgICAgICAgICAgICAgICAgICAgcndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNU19BVFRSSUJVVEVTLlRJTUUpLFxuLy8gICAgICAgICAgICAgICAgICAgIHJ3X2dldEF0dHJpYnV0ZShwX2N1ck5vZGUsIFNTTVNfQVRUUklCVVRFUy5TVFJFTkdUSCkpO1xuLy8gICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICBpZihzdHJTc21sVHlwZSA9PSBTU01TX1RZUEVTLlBST1NPRFkpXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3BlZWNoU3RyZWFtLnNwZWVjaERvbS5Qcm9zb2R5RWxlbWVudChwX2N1ck5vZGUsXG4vLyAgICAgICAgICAgICAgICAgICAgcndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNU19BVFRSSUJVVEVTLlBJVENIKSxcbi8vICAgICAgICAgICAgICAgICAgICByd19nZXRBdHRyaWJ1dGUocF9jdXJOb2RlLCBTU01TX0FUVFJJQlVURVMuUkFURSksXG4vLyAgICAgICAgICAgICAgICAgICAgcndfZ2V0QXR0cmlidXRlKHBfY3VyTm9kZSwgU1NNU19BVFRSSUJVVEVTLlZPTFVNRSkpO1xuLy8gICAgICAgICAgICB9XG4vLyAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cblxuXG5cblxuXG4gICAgLy90b2RvIHRvIGJlIHJlbW92ZWRcbiAgICAvKipcbiAgICAgKiBUaGlzIGNoZWNrcyBpZiBjb21tYW5kcyBpbiB0aGUgSFRNTCB0byBiZSByZWFkIGFwcGx5IHRvIHRoZSBzcGVlY2guXG4gICAgICovXG4gICAgY2hlY2tGb3JDb21tYW5kcyAoKVxuICAgIHtcbiAgICAgICAgaWYoZ19iVXNlQ29tbWFuZHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzZW50ZW5jZXMgPSB0aGlzLmdldFNlbnRlbmNlcygpO1xuXG4gICAgICAgICAgICB2YXIgc2VudGVuY2U7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvcihpPTA7IGk8c2VudGVuY2VzLmxlbmd0aDsgaSsrKSAgLy9ub3RlIGFycmF5IGNhbiBpbmNyZWFzZSBkdXJpbmcgbG9vcCwgc28ga2VlcCBsZW5ndGggY2hlY2sgaW4gbG9vcCBub3Qgc3RvcmVkIGJlZm9yZS5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZW50ZW5jZSA9IHNlbnRlbmNlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENhcmV0ID0gc2VudGVuY2UuZ2V0Q2FyZXRSYW5nZSgpLmxlZnRDYXJldDtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRDYXJldCA9IHNlbnRlbmNlLmdldENhcmV0UmFuZ2UoKS5yaWdodENhcmV0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RWxlbWVudCA9IHJ3X2ZpbmRDb21tYW5kTm9kZShsZWZ0Q2FyZXQubm9kZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBuZWVkcyB0byBicmVha1xuICAgICAgICAgICAgICAgIHZhciBuZXdSaWdodENvbW1hbmRDYXJldCA9IHJ3X2NoZWNrRm9yQ29tbWFuZENoYW5nZShsZWZ0Q2FyZXQubm9kZSwgcmlnaHRDYXJldC5ub2RlLCBzdGFydEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYobmV3UmlnaHRDb21tYW5kQ2FyZXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB7ICAgLy8gc3BsaXQgdGhlIHNlbnRlbmNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTZW50ZW5jZSA9IHNlbnRlbmNlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2xsb3dpbmdTZW50ZW5jZSA9IHNlbnRlbmNlLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1JhbmdlID0gbmV3IFRIQ2FyZXRSYW5nZShsZWZ0Q2FyZXQsIG5ld1JpZ2h0Q29tbWFuZENhcmV0KTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sbG93aW5nTGVmdENhcmV0ID0gbmV3UmlnaHRDb21tYW5kQ2FyZXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9sbG93aW5nTGVmdENhcmV0LmZvcndhcmRCaWFzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9sbG93aW5nTGVmdENhcmV0ID0gU1NET00ubW92ZUNhcmV0KGZvbGxvd2luZ0xlZnRDYXJldCwgMCwgZmFsc2UpOyAgICAgLy8gaWYgYXQgZW5kIG9mIGVsZW1lbnQsIHRoaXMgbW92ZXMgdG8gc3RhcnQgb2YgdGhlIG5leHQgb25lLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9sbG93aW5nUmFuZ2UgPSBuZXcgVEhDYXJldFJhbmdlKGZvbGxvd2luZ0xlZnRDYXJldCwgcmlnaHRDYXJldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV3U2VudGVuY2Uuc2V0Q2FyZXRSYW5nZShuZXdSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvbGxvd2luZ1NlbnRlbmNlLnNldENhcmV0UmFuZ2UoZm9sbG93aW5nUmFuZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpbiB0byB0aGUgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIHNlbnRlbmNlcy5zcGxpY2UoaSwgMSwgbmV3U2VudGVuY2UsIGZvbGxvd2luZ1NlbnRlbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFNlbnRlbmNlcyhzZW50ZW5jZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGtldmluIG9uIDA2LzA0LzE2LlxuICovXG4vKipcbiAqIENyZWF0ZWQgYnkgSW50ZWxsaUogSURFQS5cbiAqIFVzZXI6IHN0dWFydFxuICogRGF0ZTogMDIvMDYvMTVcbiAqIFRpbWU6IDEzOjU5XG4gKiBUaGlzIGlzIGZvciBhIHdvcmQgb2YgYSBwYWdlIHN0b3JlZCBpbiB3YXkgdG8gYXNzaXN0IHRvb2xiYXIgc3BlZWNoLlxuICovXG5pbXBvcnQge0Jhc2VPYmplY3R9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vU2VudGVuY2UvQmFzZU9iamVjdCdcbi8qKlxuICogUHVibGljIEFQSVxuICogSW5oZXJpdCBmcm9tIEJhc2VPYmplY3RcbiAqXG4gKiBnZXRXb3JkXG4gKiBzZXRQcm9udW5jaWF0aW9uXG4gKiBnZXRQcm9udW5jaWF0aW9uXG4gKiBpc092ZXJyaWRpbmdUZXh0XG4gKiBnZXRTcG9rZW5UZXh0XG4gKlxuICogQHBhcmFtIHBfcmFuZ2UgVEhSYW5nZVxuICogQHBhcmFtIHBfc3RyV29yZCB0aGUgdGV4dCBvZiB0aGUgd29yZFxuICovXG5leHBvcnQgY2xhc3MgV29yZE9iamVjdCBleHRlbmRzIEJhc2VPYmplY3R7XG4gICAgY29uc3RydWN0b3IocF9yYW5nZSwgcF9zdHJXb3JkKSB7XG4gICAgICAgIHN1cGVyKDEpLy90b2RvXG4gICAgICAgIHRoaXMuc2V0UmFuZ2UocF9yYW5nZSk7XG5cbiAgICAgICAgdGhpcy5tX3N0cldvcmQgPSBwX3N0cldvcmQ7ICAgICAgLy8gV29yZCBmb3IgdGhlIGdpdmVuIG9iamVjdC4gIFJlYWQgb25seS5cbiAgICAgICAgdGhpcy5tX3N0clByb251bmNpYXRpb24gPSBudWxsOyAgLy8gSWYgd29yZCBpcyB0byBiZSBjaGFuZ2VkLCBpdCBpcyBnaXZlbiBhIHByb251bmNpYXRpb24gdG8gb3ZlcnJpZGUgaXQuXG4gICAgfVxuXG4gICAgLy8gZ2V0dGVycyAvIHNldHRlcnNcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB3b3JkIHNldCB0byB0aGlzIG9iamVjdFxuICAgICAqL1xuICAgIGdldFdvcmQgKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fc3RyV29yZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcF9zdHJQcm9uXG4gICAgICovXG4gICAgc2V0UHJvbnVuY2lhdGlvbiAocF9zdHJQcm9uKVxuICAgIHtcbiAgICAgICAgdGhpcy5tX3N0clByb251bmNpYXRpb24gPSBwX3N0clByb247XG4gICAgfTtcblxuXG4gICAgZ2V0UHJvbnVuY2lhdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9zdHJQcm9udW5jaWF0aW9uO1xuICAgIH07XG5cbiAgICAvLyBpbXBsXG5cbiAgICAvKipcbiAgICAgKk92ZXJyaWRlIGZyb20gYmFzZSB0eXBlXG4gICAgICovXG4gICAgaXNPdmVycmlkaW5nVGV4dCAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1fc3RyUHJvbnVuY2lhdGlvbiAhPSBudWxsKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBmcm9tIGJhc2UgdHlwZVxuICAgICAqL1xuICAgIGdldFNwb2tlblRleHQgKClcbiAgICB7XG4gICAgICAgIHZhciBzdHI7XG4gICAgICAgIGlmKHRoaXMubV9zdHJQcm9udW5jaWF0aW9uICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0ciA9IHRoaXMubV9zdHJQcm9udW5jaWF0aW9uIDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0ciA9IHRoaXMubV9zdHJXb3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAvL3RvZG8gcmV0dXJuIFNwZWVjaFN0cmVhbS5zcGVlY2hEb20udXRpbC5maWx0ZXJXb3JkKHN0cik7XG5cbiAgICB9XG5cbn1cblxuXG4iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW4gb24gMDYvMDQvMTYuXG4gKi9cblxuXG5pbXBvcnQge0Jhc2VPYmplY3R9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vU2VudGVuY2UvQmFzZU9iamVjdCdcbmltcG9ydCB7U1NET019IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL1NTRE9NJ1xuaW1wb3J0IHtTZW50ZW5jZU9iamVjdH0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9TZW50ZW5jZS9TZW50ZW5jZU9iamVjdCdcbmltcG9ydCB7VEhDYXJldH0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USENhcmV0J1xuaW1wb3J0IHtVdGlsaXRpZXN9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVXRpbGl0aWVzL1V0aWxpdGllcydcbmltcG9ydCB7VEhDYXJldFJhbmdlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIQ2FyZXRSYW5nZSdcbmltcG9ydCB7VEhEb21SYW5nZX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USERvbVJhbmdlJ1xuaW1wb3J0IHtEb21TZW50ZW5jZXN9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL0RvbVNlbnRlbmNlcydcblxuLyoqXG4gKiBDcmVhdGVkIGJ5IEludGVsbGlKIElERUEuXG4gKiBVc2VyOiBzdHVhcnRcbiAqIERhdGU6IDAyLzA2LzE1XG4gKiBUaW1lOiAxMzo1OVxuICogVGhpcyBpcyBmb3IgYSBzZWN0aW9uIG9mIGEgcGFnZSBzdG9yZWQgaW4gd2F5IHRvIGFzc2lzdCB0b29sYmFyIHNwZWVjaC4gIEl0IG1heSBpbmNsdWRlIG11bHRpcGxlIHNlbnRlbmNlcy5cbiAqIE5vdCBuZWNlc3NhcnkgdGhlIGVudGlyZSBkb2N1bWVudCBvZiBwYWdlLlxuICpcbiAqIERlcGVuZGVuY3kgIFNTRE9NXG4gKi9cblxuLyoqXG4gKiBUaGUgU3BlZWNoT2JqZWN0IGNvbnRhaW5zIHRleHQgZnJvbSBhbiBIVE1MIHBhZ2UgdG8gYmUgc3Bva2VuLiAgU3BsaXQgdXAgaW4gdG8gU2VudGVuY2VPYmplY3RzLlxuICpcbiAqIFB1YmxpYyBBUElcbiAqIEluaGVyaXQgZnJvbSBCYXNlT2JqZWN0XG4gKlxuICogc2V0U2VudGVuY2VzXG4gKiBnZXRTZW50ZW5jZXNcbiAqIHNldEJhdGNoXG4gKiBpc0JhdGNoXG4gKiBwcm9jZXNzU2VudGVuY2VcbiAqIGdldEZpcnN0U2VudGVuY2VcbiAqXG4gKlxuICogQWxsIHRoaXMgZnVuY3Rpb25zLlxuICovXG5leHBvcnQgY2xhc3MgU3BlZWNoT2JqZWN0IGV4dGVuZHMgQmFzZU9iamVjdHtcbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICBzdXBlcigzKTsvL3RvZG9cblxuICAgICAgICB0aGlzLm1fYkJhdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuU1NNTF9OQU1FU1BBQ0UgPSBcInNzbWxcIjtcblxuICAgICAgICB0aGlzLlNTTVNfVFlQRVMgPSB7XG4gICAgICAgICAgICBTVUI6XCJzdWJcIixcbiAgICAgICAgICAgIFBIT05FTUU6XCJwaG9uZW1lXCIsXG4gICAgICAgICAgICBTQVlBUzpcInNheS1hc1wiLFxuICAgICAgICAgICAgRU1QSEFTSVM6XCJlbXBoYXNpc1wiLFxuICAgICAgICAgICAgQlJFQUs6XCJicmVha1wiLFxuICAgICAgICAgICAgUFJPU09EWTpcInByb3NvZHlcIlxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdGhpcy5TU01TX0FUVFJJQlVURVMgPSB7XG4gICAgICAgICAgICBBTFBIQUJFVDpcImFscGhhYmV0XCIsXG4gICAgICAgICAgICBQSDpcInBoXCIsXG4gICAgICAgICAgICBBTElBUzpcImFsaWFzXCIsXG4gICAgICAgICAgICBJTlRFUlBSRVRBUzpcImludGVycHJldC1hc1wiLFxuICAgICAgICAgICAgRk9STUFUOlwiZm9ybWF0XCIsXG5cbiAgICAgICAgICAgIExFVkVMOlwibGV2ZWxcIixcbiAgICAgICAgICAgIFNUUkVOR1RIOlwic3RyZW5ndGhcIixcbiAgICAgICAgICAgIFRJTUU6XCJ0aW1lXCIsXG4gICAgICAgICAgICBQSVRDSDpcInBpdGNoXCIsXG4gICAgICAgICAgICBSQVRFOlwicmF0ZVwiLFxuICAgICAgICAgICAgVk9MVU1FOlwidm9sdW1lXCJcblxuICAgICAgICB9O1xuICAgICAgIHRoaXMuc2VudGVuY2VObz0wO1xuICAgIH1cblxuICAgIC8vIGdldHRlcnMgLyBzZXR0ZXJzXG4gICAgLyoqXG4gICAgICogV3JhcHBlciBmb3Igc2V0Q29udGVudHMgY2FsbC5cbiAgICAgKiBAcGFyYW0gcF9jb250ZW50c1xuICAgICAqL1xuICAgIHNldFNlbnRlbmNlcyAocF9jb250ZW50cylcbiAgICB7XG4gICAgICAgIHRoaXMuc2V0Q29udGVudHMocF9jb250ZW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcHBlciBmb3IgZ2V0Q29udGVudHNcbiAgICAgKi9cbiAgICBnZXRTZW50ZW5jZXMgKClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgc2V0QmF0Y2ggKHBfYkJhdGNoKVxuICAgIHtcbiAgICAgICAgdGhpcy5tX2JCYXRjaCA9IHBfYkJhdGNoO1xuICAgIH1cbiAgICBpc0JhdGNoICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2JCYXRjaDtcbiAgICB9XG5cbiAgICBnZXROZXh0U2VudGVuY2UoY29udGlub3VzUmVhZGluZyl7XG4gICAgICAgIHRoaXMuc2VudGVuY2VObysrO1xuICAgICAgICB2YXIgc2VudGVuY2VzID0gdGhpcy5nZXRTZW50ZW5jZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuc2VudGVuY2VObyA8IHNlbnRlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vY2hlY2sgdGhhdCB0ZXN0IGlzIHdvcmRzIGluIHRoaXMgc2VudGVuY2Ugc28gdGhhdCB3ZSBkb24ndCByZXR1cm4gYSBibGFuayBzZW50ZW5jZVxuICAgICAgICAgICAgLy8gd2hlbiB0aGVyZSBhcmUgc3RpbGwgc2VudGVuY2VzIHRvIHJlYWQuXG4gICAgICAgICAgICBpZiAoc2VudGVuY2VzW3RoaXMuc2VudGVuY2VOb10uZ2V0V29yZHMoKS5sZW5ndGg9PTApe1xuICAgICAgICAgICAgICAgIHJldHVybiAgdGhpcy5nZXROZXh0U2VudGVuY2UoY29udGlub3VzUmVhZGluZyk7XG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbnRlbmNlc1t0aGlzLnNlbnRlbmNlTm9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRpbm91c1JlYWRpbmcpe1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBzZW50ZW5jZXNbc2VudGVuY2VzLmxlbmd0aC0xXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGxhc3QuZ2V0Q2FyZXRSYW5nZSgpO1xuICAgICAgICAgICAgbGFzdC5tX3JhbmdlLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHZhciBjYXJldFJhbmdlID0gbmV3IFRIQ2FyZXRSYW5nZSAobGFzdC5tX3JhbmdlLmJvZHksXG4gICAgICAgICAgICAgICAgbGFzdC5tX3JhbmdlLnN0YXJ0UmVmLnBhdGgsXG4gICAgICAgICAgICAgICAgbGFzdC5tX3JhbmdlLnN0YXJ0UmVmLm9mZnNldCxcbiAgICAgICAgICAgICAgICBsYXN0Lm1fcmFuZ2UuZW5kUmVmLnBhdGgsXG4gICAgICAgICAgICAgICAgbGFzdC5tX3JhbmdlLmVuZFJlZi5vZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGRvbVNlbnQgPSBuZXcgRG9tU2VudGVuY2VzKCk7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBkb21TZW50LmdldFNlbnRlbmNlRnJvbVBvaW50KGNhcmV0UmFuZ2UubGVmdENhcmV0KTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gZG9tU2VudC5nZXROZXh0U2VudGVuY2UocmFuZ2UsbnVsbCk7XG4gICAgICAgICAgICB2YXIgc2VudGVuY2UgPSB0aGlzLnByb2Nlc3NTZW50ZW5jZShuZXh0KTtcbiAgICAgICAgICAgIHRoaXMubV9jb250ZW50cy5sZW5ndGg9MDtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VudGVuY2VzKC4uLnNlbnRlbmNlKTtcbiAgICAgICAgICAgIHRoaXMuc2VudGVuY2VObz0wO1xuICAgICAgICAgICAgaWYgKHNlbnRlbmNlWzBdLmdldFdvcmRzKCkubGVuZ3RoPT0wKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gIHRoaXMuZ2V0TmV4dFNlbnRlbmNlKGNvbnRpbm91c1JlYWRpbmcpO1xuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZW50ZW5jZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50U2VudGVuY2UoKXtcbiAgICAgICAgdmFyIHNlbnRlbmNlcyA9IHRoaXMuZ2V0U2VudGVuY2VzKCk7XG4gICAgICAgIGlmICh0aGlzLnNlbnRlbmNlTm8gPCBzZW50ZW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VudGVuY2VzW3RoaXMuc2VudGVuY2VOb107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2VudGVuY2VzW3NlbnRlbmNlcy5sZW5ndGggLTFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGdldEZpcnN0U2VudGVuY2UgKClcbiAgICB7XG4gICAgICAgIHRoaXMuc2VudGVuY2VObz0wO1xuICAgICAgICBpZih0aGlzLmdldFNlbnRlbmNlcygpLmxlbmd0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlbnRlbmNlcygpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgcHJvY2Vzc1JhbmdlKHRoRG9tUmFuZ2UsaG92ZXJTcGVhayl7XG4gICAgICAgIHRoaXMuc2V0U2VudGVuY2VzKFtdKTsvL2NsZWFyIHRoZSBhcnJheVxuICAgICAgICB0aGlzLnNlbnRlbmNlTm89MDtcbiAgICAgICAgdmFyIGNhcmV0UmFuZ2UgPSBuZXcgVEhDYXJldFJhbmdlKHRoRG9tUmFuZ2UuYm9keSxcbiAgICAgICAgICAgIHRoRG9tUmFuZ2Uuc3RhcnRSZWYucGF0aCxcbiAgICAgICAgICAgIHRoRG9tUmFuZ2Uuc3RhcnRSZWYub2Zmc2V0LFxuICAgICAgICAgICAgdGhEb21SYW5nZS5lbmRSZWYucGF0aCxcbiAgICAgICAgICAgIHRoRG9tUmFuZ2UuZW5kUmVmLm9mZnNldCk7XG5cbiAgICAgICAgaWYgKHRoRG9tUmFuZ2Uuc3RhcnRDYXJldC5ub2RlLnRhZ05hbWUgJiYgdGhEb21SYW5nZS5zdGFydENhcmV0Lm5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT1cInRleHRhcmVhXCIpe1xuICAgICAgICAgICAgbGV0IHNlbnQgPSBuZXcgU2VudGVuY2VPYmplY3QoY2FyZXRSYW5nZSk7XG4gICAgICAgICAgICBzZW50LnNldFdvcmRzKHRoRG9tUmFuZ2Uuc3RhcnRDYXJldC5ub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIHNlbnQubV9zdHJSYXdUZXh0PXRoRG9tUmFuZ2Uuc3RhcnRDYXJldC5ub2RlLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXRTZW50ZW5jZXMoc2VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZG9tU2VudCA9IG5ldyBEb21TZW50ZW5jZXMoKTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvbVNlbnQuZ2V0U2VudGVuY2VGcm9tUG9pbnQoY2FyZXRSYW5nZS5sZWZ0Q2FyZXQpO1xuXG4gICAgICAgICAgICB2YXIgc2VudGVuY2VzID0gbmV3IEFycmF5KClcbiAgICAgICAgICAgIHZhciBzZW50ZW5jZSA9IHRoaXMucHJvY2Vzc1NlbnRlbmNlKHJhbmdlKTtcbiAgICAgICAgICAgIHNlbnRlbmNlcy5wdXNoKC4uLnNlbnRlbmNlKTtcbiAgICAgICAgICAgIGlmICghaG92ZXJTcGVhaylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzTW9yZVNlbnRlbmNlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFNlbnRlbmNlID0gZG9tU2VudC5nZXROZXh0U2VudGVuY2UocmFuZ2UsIGNhcmV0UmFuZ2UucmlnaHRDYXJldC5ub2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNlbnRlbmNlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U2VudGVuY2UubGVmdENhcmV0Lm5vZGUgIT0gY2FyZXRSYW5nZS5yaWdodENhcmV0Lm5vZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U2VudGVuY2UubGVmdENhcmV0Lm9mZnNldCA8IGNhcmV0UmFuZ2UucmlnaHRDYXJldC5vZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW50ZW5jZSA9IHRoaXMucHJvY2Vzc1NlbnRlbmNlKG5leHRTZW50ZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbnRlbmNlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW50ZW5jZXMucHVzaCguLi5zZW50ZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV4dFNlbnRlbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc01vcmVTZW50ZW5jZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc01vcmVTZW50ZW5jZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGhhc01vcmVTZW50ZW5jZXMpXG5cbiAgICAgICAgICAgICAgICBpZiAoc2VudGVuY2VzLmxlbmd0aCA9PSAxICYmIHJhbmdlLnJpZ2h0Q2FyZXQub2Zmc2V0ID4gY2FyZXRSYW5nZS5yaWdodENhcmV0Lm9mZnNldCAmJlxuICAgICAgICAgICAgICAgICAgICBjYXJldFJhbmdlLnJpZ2h0Q2FyZXQub2Zmc2V0ICE9IGNhcmV0UmFuZ2UubGVmdENhcmV0Lm9mZnNldClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNlbnRlbmNlcyA9IHRoaXMucHJvY2Vzc1NlbnRlbmNlKGNhcmV0UmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRTZW50ZW5jZXMoc2VudGVuY2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpbXBsXG5cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgZ2l2ZW4gcmFuZ2UgZm9yIHRoZSBmaXJzdCBzZW50ZW5jZSB0byBiZSByZWFkIGluIGl0LlxuICAgICAqIFZhcmlvdXMgYXNwZWN0cyBtaWdodCByZXN1bHQgaW4gdGhlIHJhbmdlIG9mIHRoZSBzZW50ZW5jZSBiZWluZyB0cnVuY2F0ZWQuXG4gICAgICogQHBhcmFtIHBfY2FyZXRSYW5nZVxuICAgICAqL1xuICAgIHByb2Nlc3NTZW50ZW5jZSAocF9jYXJldFJhbmdlKVxuICAgIHtcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHJhbmdlIHRvIGdldCB0ZXh0LCBzdG9yZSBhcyBhcnJheSBvZiBzZW50ZW5jZXNcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHJhbmdlIGV4aXN0cyBhbmQgaGFzIHZhbGlkIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLlxuICAgICAgICAgICAgaWYoIXRoaXMuY2hlY2tSYW5nZShwX2NhcmV0UmFuZ2UpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsaWQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbGVhciBjb250ZW50c1xuICAgICAgICAgICAgLy90aGlzLnNldFNlbnRlbmNlcyhbXSk7XG5cbiAgICAgICAgICAgIC8vIEFzc3VtZSBjb250YWlucyBzZW50ZW5jZSwgc3RhcnQgd2l0aCB0aGF0IHRpbGwgZGlzY292ZXIgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTZW50ZW5jZSA9IG5ldyBTZW50ZW5jZU9iamVjdChwX2NhcmV0UmFuZ2UpO1xuXG4gICAgICAgICAgICAvLyBHZXQgc2VudGVuY2VzIGFzIHNwbGl0IGJ5IGxhbmd1YWdlIGlmIG5lY2Vzc2FyeSwgcmV0dXJucyBhbiBhcnJheSBvZiBTZW50ZW5jZU9iamVjdHMuXG4gICAgICAgICAgICB2YXIgc2VudGVuY2VzID0gdGhpcy5zcGxpdFNlbnRlbmNlQnlMYW5ndWFnZShjdXJyZW50U2VudGVuY2UpO1xuICAgICAgICAgICAgaWYoc2VudGVuY2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsaWQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgY29udGVudHMgb2YgdGhpcyBzcGVlY2ggb2JqZWN0IHRvIGJlIHRoZSBhcnJheSBvZiBzZW50ZW5jZSBvYmplY3RzIChvbmUgc2VudGVuY2Ugb3Igc2V2ZXJhbCBpZiBzcGxpdCBidXkgbGFuZ3VhZ2UpXG4gICAgICAgICAgICAvL3RoaXMuc2V0U2VudGVuY2VzKHNlbnRlbmNlcyk7XG5cblxuICAgICAgICAgICAgLy90b2RvIGNoZWNrIHRoYXQgY29ycmVjdCB0byByZW1vdmUgdGhpcy4gIEluc3RlYWQgb2YgYnJlYWtpbmcgaGVyZSwgYnJlYWsgc2hvdWxkIGJlIGluIHRhcmdldCBzZWxlY3Rpb25cbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGRvbmUgdXNpbmcgbG9naWMgdG8gbW92ZSB0byBuZXh0IHRhcmdldCBub3QgZ29pbmcgcGFzdCBjbWQgYnJlYWtzLlxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGN1c3RvbSB0ZXh0aGVscCBjb21tYW5kcyB0aGF0IHdvdWxkIGJyZWFrIHVwIGEgc2VudGVuY2UuXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdXNlIHdoYXQgaXMgY3VycmVudGx5IHNldCBhcyB0aGUgY29udGVudHMuXG4gICAgICAgICAgICAvL2NoZWNrRm9yQ29tbWFuZHMoKTtcblxuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gIFRoZSBtYWluIHByb2Nlc3Npbmcgb2NjdXJzIGhlcmUuXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAvL3RvZG8gdmFyIG5MZW4gPSAodGhpcy5tX2JCYXRjaD90aGlzLmdldFNlbnRlbmNlcygpLmxlbmd0aDoxKTtcbiAgICAgICAgICAgIHZhciBuTGVuID0gc2VudGVuY2VzLmxlbmd0aFxuICAgICAgICAgICAgLy8gaWYgb25seSB3YW50IHRoZSBmaXJzdCBzZW50ZW5jZSB3aWxsIGp1c3QgcHJvY2VzcyB0aGUgZmlyc3QgYW5kIG90aGVycyBvYnRhaW5lZCBsYXRlci5cblxuICAgICAgICAgICAgZm9yKHZhciBpPTA7aTxuTGVuO2krKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBwb3B1bGF0ZSBzZW50ZW5jZSB3aXRoIGVsZW1lbnRzIGluIGl0cyByYW5nZVxuICAgICAgICAgICAgICAgIGlmICghc2VudGVuY2VzW2ldLmlzTWF0aE1MKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VudGVuY2VzW2ldLnByb2Nlc3NUZXh0VG9TcGVha0luU2VudGVuY2VPYmplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBwb3B1bGF0ZSBzZW50ZW5jZSB3aXRoIHRoZSB0ZXh0IHRvIHNwZWFrXG4gICAgICAgICAgICAgICAvLyB0b2RvIHZhciB0bXAgPSBuZXcgU3BlZWNoU3RyZWFtLnNwZWVjaERvbS5TcGVlY2hCdWlsZGVyKFNwZWVjaFN0cmVhbS5TcGVlY2hSZXF1ZXN0Qm9va21hcmtzLkFMTCk7XG4gICAgICAgICAgICAgICAgLy90bXAucHJvY2Vzc1RleHQodGhpcy5nZXRTZW50ZW5jZXMoKVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VudGVuY2VzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJlcnIgU3BlZWNoT2JqZWN0IHByb2Nlc3NTZW50ZW5jZTpcIiArIFwifFwiKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnNldFZhbGlkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBjaGVja3MgaWYgbGFuZ3VhZ2UgY2hhbmdlcyBvdmVyIHRoZSByYW5nZSBhbmQgdHJ1bmNhdGVzIGFjY29yZGluZ2x5LCBhbHNvIGlmIHRoZXJlIGlzIGEgdm9pY2Ugc2V0XG4gICAgICogb3RoZXIgdGhhbiBwYWdlIGRlZmF1bHQgdGhpcyBpcyBhZGRlZCB0byB0aGUgc2VudGVuY2UuXG4gICAgICpcbiAgICAgKiBJZiBubyBjaGFuZ2VzLCByZXR1cm5zIG9yaWdpbmFsIHNlbnRlbmNlLlxuICAgICAqIEBwYXJhbSBwX2N1cnJlbnRTZW50ZW5jZVxuICAgICAqIHJldHVybnMgYXJyYXkgb2Ygc2VudGVuY2VzLiAoU2VudGVuY2VPYmplY3QpXG4gICAgICovXG4gICAgIHNwbGl0U2VudGVuY2VCeUxhbmd1YWdlIChwX2N1cnJlbnRTZW50ZW5jZSlcbiAgICB7XG4gICAgICAgIHZhciBjYXJldFJhbmdlID0gcF9jdXJyZW50U2VudGVuY2UuZ2V0Q2FyZXRSYW5nZSgpO1xuICAgICAgICB2YXIgbGVmdENhcmV0ID0gY2FyZXRSYW5nZS5sZWZ0Q2FyZXQ7XG4gICAgICAgIHZhciByaWdodENhcmV0ID0gY2FyZXRSYW5nZS5yaWdodENhcmV0O1xuICAgICAgICB2YXIgYkluVHJhbnNsYXRlUG9wdXAgPSBmYWxzZTtcbiAgICAgICAgaWYoZmFsc2UpLy90b2RvIWdfYlZvaWNlRnJvbUxhbmdGbGFnKVxuICAgICAgICB7ICAgLy8gaWYgaW5zaWRlIGEgdHJhbnNsYXRpb24gcG9wdXAgc2NyZWVuIHN0aWxsIHdhbnQgdG8gY2hlY2sgZm9yIGxhbmcgZmxhZ1xuICAgICAgICAgICAgLy8gZXZlbiB3aGVuIHR1cm5lZCBvZmYgZm9yIHRoZSByZXN0IG9mIHRoZSBwYWdlLlxuXG4gICAgICAgICAgICB2YXIgdG1wTm9kZSA9IGxlZnRDYXJldC5ub2RlO1xuICAgICAgICAgICAgdmFyIHRtcElkO1xuICAgICAgICAgICAgdmFyIHRtcENsYXNzO1xuXG4gICAgICAgICAgICB3aGlsZSh0bXBOb2RlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYodG1wTm9kZS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wSWQgPSB0bXBOb2RlLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0bXBDbGFzcyA9IHRtcE5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodG1wQ2xhc3MgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG1wQ2xhc3MuaW5kZXhPZihcImNvbnRlbnRUcmFuc2xhdGVcIikgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiSW5UcmFuc2xhdGVQb3B1cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZih0bXBJZCAhPSBudWxsICYmIHRtcElkLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRtcElkID09IFwicndwb3B1cHRyYW5zXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkluVHJhbnNsYXRlUG9wdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRtcElkLmluZGV4T2YoXCJyd01lYW5pbmdcIikhPTAgJiYgdG1wSWQuaW5kZXhPZihcInJ3SGVhZFdvcmRcIikhPSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgcndNZWFuaW5nIHdhbnQgdG8ga2VlcCBnb2luZyB1cCBvdGhlcndpc2UgYnJlYWsgYXMgYW55IG90aGVyIGlkIG1lYW5zIG5vdCBpbiB0cmFucyBwb3B1cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG1wTm9kZSA9IHRtcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBjdXN0b20gdm9pY2UgdGFnXG4gICAgICAgIGlmKGZhbHNlIC8qdG9kbyBnX2JWb2ljZUZyb21MYW5nRmxhZyovIHx8IGJJblRyYW5zbGF0ZVBvcHVwKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RyVm9pY2UgPSByd19nZXRWb2ljZVNldEZvck5vZGUobGVmdENhcmV0Lm5vZGUpO1xuICAgICAgICAgICAgaWYoc3RyVm9pY2UgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwX2N1cnJlbnRTZW50ZW5jZS5zZXRWb2ljZShzdHJWb2ljZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vQ2hlY2sgZm9yIGNhc2Ugb2Ygb25lIHNlbnRlbmNlIHdpdGggbXVsdGlwbGUgbGFuZyAuLi5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGxhbmcgY2hhbmdlcyBvdmVyIGNvdXJzZSBvZiB0aGUgcmFuZ2UuICBJZiBzbyBuZWVkIHRvIGxpbWl0IHRoZSByYW5nZSB0byBzaW5nbGUgbGFuZ3VhZ2UuXG4gICAgICAgICAgICB2YXIgbmV3UmlnaHRDYXJldCA9IHJ3X2NoZWNrRm9yVm9pY2VDaGFuZ2UobGVmdENhcmV0Lm5vZGUsIHJpZ2h0Q2FyZXQubm9kZSwgc3RyVm9pY2UpO1xuICAgICAgICAgICAgaWYobmV3UmlnaHRDYXJldCAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzZWNvbmRTZW50ZW5jZUNhcmV0ID0gbmV3UmlnaHRDYXJldC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHNlY29uZFNlbnRlbmNlQ2FyZXQuZm9yd2FyZEJpYXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlY29uZFNlbnRlbmNlQ2FyZXQgPSBTU0RPTS5tb3ZlQ2FyZXQoc2Vjb25kU2VudGVuY2VDYXJldCwgMCwgZmFsc2UpOyAgLy9zdGlsbCBiZXR3ZWVuIHNhbWUgcG9pbnRzIGJ1dCBtb3ZlcyB0byAnYmVmb3JlIG5leHQnIHJhdGhlciB0aGFuICdhZnRlciBwcmV2aW91cycsIHdoaWNoIG1pZ2h0IGJlIGRpZmZlcmVudCBwbGFjZXMgaW4gdGhlIERPTS5cblxuICAgICAgICAgICAgICAgIHZhciBsZWZ0TmV3Q2FyZXRSYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UobGVmdENhcmV0LCBuZXdSaWdodENhcmV0KTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHROZXdDYXJldFJhbmdlID0gbmV3IFRIQ2FyZXRSYW5nZShzZWNvbmRTZW50ZW5jZUNhcmV0LCByaWdodENhcmV0KTtcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kU2VudGVuY2UgPSBwX2N1cnJlbnRTZW50ZW5jZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgcF9jdXJyZW50U2VudGVuY2Uuc2V0Q2FyZXRSYW5nZShsZWZ0TmV3Q2FyZXRSYW5nZSk7XG4gICAgICAgICAgICAgICAgc2Vjb25kU2VudGVuY2Uuc2V0Q2FyZXRSYW5nZShyaWdodE5ld0NhcmV0UmFuZ2UpO1xuICAgICAgICAgICAgICAgIHNlY29uZFNlbnRlbmNlLnNldFZvaWNlKG51bGwpOyAvLyB3aWxsIGhhdmUgY29waWVkIGZyb20gZmlyc3QsIHdoaWNoIG1pZ2h0IG5vdCBhcHBseVxuXG4gICAgICAgICAgICAgICAgLy8gcmFuZ2UgaGFzIGJlZW4gcmVkdWNlZCwgbWFrZSBzdXJlIHN0aWxsIGhhcyBzcGVlY2hcbiAgICAgICAgICAgICAgICB2YXIgdHh0ID0gbGVmdE5ld0NhcmV0UmFuZ2UudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZih0eHQubGVuZ3RoID09IDAgfHwgIXJ3X2lzV29yZFNwZWFrYWJsZSh0eHQpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3Qgc2VudGVuY2UgaXMgbm90IHZhbGlkLiAgQXNzdW1pbmcgdGhhdCBnb3QgaGVyZSB3aXRoIHZhbGlkIHNlbnRlbmNlLCB0byBzcGVha2FibGUgcGFydFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBub3cganVzdCBpbiB0aGUgc2Vjb25kIHNlbnRlbmNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWNvbmQgc2VudGVuY2UsIG1pZ2h0IG5lZWQgdG8gYmUgc3BsaXQgZnVydGhlci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwbGl0U2VudGVuY2VCeUxhbmd1YWdlKHNlY29uZFNlbnRlbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcEFyciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0bXBBcnIucHVzaChwX2N1cnJlbnRTZW50ZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIHRtcEFyciA9IHRtcEFyci5jb25jYXQoc3BsaXRTZW50ZW5jZUJ5TGFuZ3VhZ2Uoc2Vjb25kU2VudGVuY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcEFycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBzcGxpdCBzbyBqdXN0IHJldHVybiBjdXJyZW50IHNlbnRlbmNlXG4gICAgICAgIHJldHVybiBbcF9jdXJyZW50U2VudGVuY2VdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHJhbmdlLCByZXR1cm4gZmFsc2Ugb24gZXJyb3IuXG4gICAgICogQHBhcmFtIHBfY2FyZXRSYW5nZVxuICAgICAqL1xuICAgICBjaGVja1JhbmdlIChwX2NhcmV0UmFuZ2UpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgaWYocF9jYXJldFJhbmdlID09IG51bGwgfHxcbiAgICAgICAgICAgIHBfY2FyZXRSYW5nZS5sZWZ0Q2FyZXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgcF9jYXJldFJhbmdlLnJpZ2h0Q2FyZXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgcF9jYXJldFJhbmdlLmxlZnRDYXJldC5ub2RlID09IG51bGwgfHxcbiAgICAgICAgICAgIHBfY2FyZXRSYW5nZS5yaWdodENhcmV0Lm5vZGUgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgc3RhcnQgb3IgZW5kIHBvaW50IG5lZWRzIHRvIGJlIG1vdmVkLlxuXG4gICAgICAgIHZhciBsZWZ0Q2FyZXQgPSBwX2NhcmV0UmFuZ2UubGVmdENhcmV0O1xuICAgICAgICB2YXIgcmlnaHRDYXJldCA9IHBfY2FyZXRSYW5nZS5yaWdodENhcmV0O1xuXG4gICAgICAgIC8vIHRoZSBsZWZ0IG5vZGUgYW5kIHJpZ2h0IG5vZGUgbWlnaHQgYmUgaW5zaWRlIGEgdGV4dCBub2RlIHRoYXQgaXMgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgLy8gc3VjaCBhbmQgYSBzcGFuIHdpdGggYSBwcm9uIHRhZy4gIFRoaXMgd2lsbCBiZSBtaXNzZWQgaWYgc2VsZWN0aW9uIHN0YXJ0cyBpbnNpZGUgaXQuXG4gICAgICAgIHZhciB0bXBQYXIgPSBzc2RvbS5jaGVja0ZvclNwZWNpYWxQYXJlbnQobGVmdENhcmV0Lm5vZGUpO1xuICAgICAgICBpZih0bXBQYXIgIT0gbnVsbClcbiAgICAgICAgeyAgIC8vIGlmIGNoYW5nZSByYW5nZSBoZXJlLCBkb250IHRoaW5rIGl0IG5lZWRzIHRvIGJlIHBhc3NlZCBiYWNrIHRocm91Z2hcbiAgICAgICAgICAgIGxlZnRDYXJldC5ub2RlID0gdG1wUGFyO1xuICAgICAgICAgICAgbGVmdENhcmV0LnNldFNwZWNpYWxDYXNlKHRydWUpO1xuICAgICAgICAgICAgcF9jYXJldFJhbmdlLmxlZnRDYXJldCA9IGxlZnRDYXJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcFBhciA9IHNzZG9tLmNoZWNrRm9yU3BlY2lhbFBhcmVudChyaWdodENhcmV0Lm5vZGUpO1xuICAgICAgICBpZih0bXBQYXIgIT0gbnVsbClcbiAgICAgICAgeyAgIC8vIGlmIGNoYW5nZSByYW5nZSBoZXJlLCBkb250IHRoaW5rIGl0IG5lZWRzIHRvIGJlIHBhc3NlZCBiYWNrIHRocm91Z2hcbiAgICAgICAgICAgIHJpZ2h0Q2FyZXQubm9kZSA9IHRtcFBhcjtcbiAgICAgICAgICAgIHJpZ2h0Q2FyZXQuc2V0U3BlY2lhbENhc2UodHJ1ZSk7XG4gICAgICAgICAgICBwX2NhcmV0UmFuZ2UucmlnaHRDYXJldCA9IHJpZ2h0Q2FyZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cblxuXG5cblxuXG5cblxuXG4iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW4gb24gMzEvMDMvMTYuXG4gKi9cblxuXG5cbi8vIERlcGVuZGFudCBvbiBTU0RPTVxuXG5cbi8vIE5CIGFjY29yZGluZyB0byBvbmUgc2l0ZSBJIHNob3VsZCB1c2UgQ2xhc3NOYW1lLnByb3RvdHlwZS5tZXRob2RuYW1lID0gZnVuY3Rpb24oKXt9XG4vLyByYXRoZXIgdGhhbiBwdXQgaW5zaWRlIGluaXRpYWwgZnVuY3Rpb24gdGhpcy5tZXRob2RuYW1lID0gZnVuY3Rpb24oKXt9XG4vLyBkdWUgdG8gbGF0ZXIgaGF2aW5nIG1lbW9yeSBsZWFrcyBpbiBJRS4gIE5lZWQgdG8gY2hlY2sgdGhpcyBsYXRlci5cblxuLypcbiAvKipcbiAqIFRoaXMgaG9sZHMgYSBwb2ludCBpbiB0aGUgdGV4dCBpbiB0aGUgZG9jdW1lbnQuXG4gKiBJdCBpcyBtYXJrZWQgYnkgYSB0ZXh0IG5vZGUgYW5kIGFuIG9mZnNldCBpbiB0aGF0IG5vZGUuXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdGVtcG9yYXJpbHksIGlmIHN0b3JlZCBmb3IgbGF0ZXIgbWF5IGJlY29tZSBpbnZhbGlkLlxuICpcbiAqIEBwYXJhbSBwX25vZGUgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSBwX25PZmZzZXQgaW50ZWdlciBvZmZzZXRcbiAqIEBwYXJhbSBwX2JGb3J3YXJkQmlhcyBib29sZWFuXG4gKi9cbmV4cG9ydCBjbGFzcyBUSENhcmV0XG57XG4gICAgY29uc3RydWN0b3IocF9ub2RlLCBwX25PZmZzZXQsIHBfYkZvcndhcmRCaWFzKVxuICAgIHtcbiAgICAgICAgdGhpcy5ub2RlID0gcF9ub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHBfbk9mZnNldDtcbiAgICAgICAgdGhpcy5mb3J3YXJkQmlhcyA9IHBfYkZvcndhcmRCaWFzO1xuICAgICAgICB0aGlzLnNwZWNpYWxDYXNlID0gZmFsc2U7XG5cbi8vICAgICAgICAvLyAoVW5pdCB0ZXN0IG5vdGUgZXh0ZXJuYWwgZGVwZW5kZW5jeSlcbi8vICAgICAgICBpZiAoU1NET00uY2hlY2tGb3JTcGVjaWFsUGFyZW50KHRoaXMubm9kZSkgIT0gbnVsbCkge1xuLy8gICAgICAgICAgICB0aGlzLnNwZWNpYWxDYXNlID0gdHJ1ZTtcbi8vICAgICAgICAgICAgLy90aGlzLm9mZnNldCA9IDA7XG4vLyAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFNwZWNpYWxDYXNlICAocF9iU3BlY2lhbENhc2UpIHtcbiAgICAgICAgdGhpcy5zcGVjaWFsQ2FzZSA9IHBfYlNwZWNpYWxDYXNlO1xuICAgICAgICBpZiAocF9iU3BlY2lhbENhc2UpIHtcbiAgICAgICAgICAgIC8vdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgaXNTcGVjaWFsQ2FzZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNpYWxDYXNlO1xuICAgIH07XG5cbiAgICAvKiBDaGVja3MgaWYgaXMgdmFsaWQgY2FyZXQgcG9zaXRpb24gaW4gdGhlIGRvbSwgaWUgaXMgdGV4dCBub2RlIHdpdGggb2Zmc2V0IGluc2lkZSB0aGUgbm9kZS5cbiAgICAgVGhpcyBpcyB0byBjaGVjayB0aGF0IGl0IGNhbiBiZSB1c2VkIHRvIGFjY2VzcyBpdGVtIGluIGRvbSB3aXRoIHJhbmdlIG9iamVjdCBmb3IgZXhhbXBsZS5cbiAgICAgSWYgc28gcmV0dXJuIHRydWUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuKi9cbiAgICBjaGVjayAgKCkge1xuICAgICAgICB2YXIgYlZhbGlkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubm9kZSA9PSBudWxsIHx8IHRoaXMubm9kZS5wYXJlbnROb2RlID09IG51bGwpIHsgICAvLyBkb2Vzbid0IGV4aXN0IG9yIGlzIG9ycGhhbmVkIHNvIG5vIHVzZVxuICAgICAgICAgICAgYlZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlICE9IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlID09IDEgJiYgdGhpcy5zcGVjaWFsQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpcyB2YWxpZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYlZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vZmZzZXQgPCAwIHx8IHRoaXMub2Zmc2V0ID4gdGhpcy5ub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBiVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYlZhbGlkO1xuICAgIH07XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICAgIHZhciB0eHQgPSBcIlRIXCIgKyBcIkNhcmV0IFwiOyAgLy9zcGxpdCBkdWUgdG8gb2JmdXNjYXRvciBsb2dpYyAgKElmIGRpZG4ndCBzcGxpdCBpdCB3b3VsZG50IG9iZnVzY2F0ZSBUSENhcmV0KVxuICAgICAgICBpZiAodGhpcy5ub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgIHR4dCArPSB0aGlzLm5vZGUubm9kZVZhbHVlICsgXCIgXCIgKyB0aGlzLm5vZGUucGFyZW50Tm9kZS50YWdOYW1lICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIHR4dCArPSB0aGlzLm5vZGUudGFnTmFtZSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHR4dCArPSB0aGlzLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIHR4dDtcbiAgICB9O1xuXG4gICAgZXF1YWxzICAocF9jYXJldCkge1xuICAgICAgICBpZiAocF9jYXJldCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlID09IHBfY2FyZXQubm9kZSAmJlxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPT0gcF9jYXJldC5vZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZEJpYXMgPT0gcF9jYXJldC5mb3J3YXJkQmlhcztcbiAgICB9O1xuXG4gICAgY2xvbmUgICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHRoaXMubm9kZSwgdGhpcy5vZmZzZXQsIHRoaXMuZm9yd2FyZEJpYXMpO1xuICAgIH1cbn1cblxuXG5cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbiBvbiAwMS8wNC8xNi5cbiAqL1xuaW1wb3J0IHtUSENhcmV0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIQ2FyZXQnXG5pbXBvcnQge1NTRE9NfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9TU0RPTSdcbmltcG9ydCB7RG9tTmF2aWdhdGlvbn0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9ET00vRG9tTmF2aWdhdGlvbidcbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9BdHRyaWJ1dGUnXG5cbmV4cG9ydCBjbGFzcyBUSENhcmV0UmFuZ2VcbntcbiAgICBjb25zdHJ1Y3RvcihwX3RoZUJvZHksIHBfc3RyUGF0aExlZnQsIHBfblBvc0xlZnQsXG4gICAgICAgICAgICAgICAgcF9zdHJQYXRoUmlnaHQsIHBfblBvc1JpZ2h0KVxuICAgIHtcbiAgICAgICAgdGhpcy5sZWZ0Q2FyZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnJpZ2h0Q2FyZXQgPSBudWxsO1xuXG4gICAgICAgIGlmIChwX3RoZUJvZHkgIT1udWxsICYmIHBfc3RyUGF0aExlZnQhPW51bGwgJiYgcF9uUG9zTGVmdCE9bnVsbCAmJlxuICAgICAgICAgICAgcF9zdHJQYXRoUmlnaHQhPW51bGwgJiYgcF9uUG9zUmlnaHQhPW51bGwgKSB7XG4gICAgICAgICAgICB0aGlzLmdldENhcmV0UGFpckZyb21Eb21Qb3NpdGlvbihwX3RoZUJvZHksIHBfc3RyUGF0aExlZnQsIHBfblBvc0xlZnQsXG4gICAgICAgICAgICAgICAgcF9zdHJQYXRoUmlnaHQsIHBfblBvc1JpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldENhcmV0UmFuZ2UgKGxlZnQscmlnaHQpe1xuICAgICAgICB0aGlzLmxlZnRDYXJldCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHRDYXJldCA9IHJpZ2h0O1xuICAgIH1cbiAgICBlcXVhbHMgKHBfY2FyZXRSYW5nZSkge1xuICAgICAgICBpZiAocF9jYXJldFJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRDYXJldC5lcXVhbHMocF9jYXJldFJhbmdlLmxlZnRDYXJldCkgJiZcbiAgICAgICAgICAgIHRoaXMucmlnaHRDYXJldC5lcXVhbHMocF9jYXJldFJhbmdlLnJpZ2h0Q2FyZXQpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dE92ZXJDYXJldFJhbmdlKCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgVXNlIHRoaXMgdG8gZ2V0IHRoZSB0ZXh0IGdpdmVuIGEgY2FyZXQgcmFuZ2UuICBUaGlzIGdldHMgdGhlIGV4YWN0IHRleHQgbm90IHRha2luZyBzdWJzdGl0dXRpb25zIGZvciBzcGVlY2guXG4gICAgIFdpbGwgb25seSBpbmNsdWRlIGNvbnRlbnQgb2YgdGV4dCBub2RlcyBhbmQgZWxlbWVudHMgdGhhdCBhcmUgaW1hZ2VzIHdpdGggbXNnLlxuICAgICAqL1xuICAgIGdldFRleHRPdmVyQ2FyZXRSYW5nZSAoKVxuICAgIHsgICAvLyBpdGVyYXRlIG92ZXIgcmFuZ2UgdG8gZ2V0IHRleHRcbiAgICAgICAgdmFyIHNzZG9tID0gbmV3IFNTRE9NKCk7XG4gICAgICAgIHRyeVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiggdGhpcy5sZWZ0Q2FyZXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHRDYXJldCA9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGVmdENhcmV0ID0gdGhpcy5sZWZ0Q2FyZXQ7XG4gICAgICAgICAgICB2YXIgcmlnaHRDYXJldCA9IHRoaXMucmlnaHRDYXJldDtcblxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0gbGVmdENhcmV0Lm5vZGU7XG4gICAgICAgICAgICB2YXIgcmlnaHROb2RlID0gcmlnaHRDYXJldC5ub2RlO1xuXG4gICAgICAgICAgICB2YXIgdG1wVHh0O1xuICAgICAgICAgICAgdmFyIHN0clJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgZWxlbUxpc3QgPSBzc2RvbS5nZXROb2Rlc092ZXJSYW5nZShsZWZ0Tm9kZSwgcmlnaHROb2RlKTtcblxuICAgICAgICAgICAgaWYoZWxlbUxpc3QgIT0gbnVsbCAmJiBlbGVtTGlzdC5sZW5ndGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGVsZW1MaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBlbGVtTGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoZWxlbS5ub2RlVHlwZSA9PSAzICYmIGVsZW0ucGFyZW50Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT0gXCJ0ZXh0YXJlYVwiKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBUeHQgPSBlbGVtLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodE5vZGUgPT0gbGVmdE5vZGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clJlc3VsdCArPSB0bXBUeHQuc3Vic3RyaW5nKGxlZnRDYXJldC5vZmZzZXQsIHJpZ2h0Q2FyZXQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihlbGVtID09IGxlZnROb2RlICYmIGxlZnRDYXJldC5vZmZzZXQgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clJlc3VsdCArPSB0bXBUeHQuc3Vic3RyKGxlZnRDYXJldC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihlbGVtID09IHJpZ2h0Tm9kZSAmJiByaWdodENhcmV0Lm9mZnNldCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0clJlc3VsdCArPSB0bXBUeHQuc3Vic3RyaW5nKDAsIHJpZ2h0Q2FyZXQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJSZXN1bHQgKz0gdG1wVHh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICBzdHJSZXN1bHQgKz0gdG1wVHh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZWxlbS5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcImltZ1wiICYmIHJ3X2dldEF0dHJpYnV0ZShlbGVtLCBcIm1zZ1wiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJSZXN1bHQgPSByd19nZXRBdHRyaWJ1dGUoZWxlbSwgXCJtc2dcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdHJSZXN1bHQudHJpbVRIKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZXJyKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVycm9yIGdldFRleHRPdmVyQ2FyZXRSYW5nZTogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLypcbiAgICAgQ29udmVydCBUSENhcmV0UmFuZ2UgdG8gVEhSYW5nZVxuICAgICAqL1xuICAgIHJ3X2dldFRIUmFuZ2VGcm9tVEhDYXJldFJhbmdlKClcbiAgICB7XG4gICAgICAgIGlmKHRoaXMgPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5sZWZ0Q2FyZXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5yaWdodENhcmV0ID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vXCJFcnJvciBjb252ZXJ0aW5nIFRIQ2FyZXRSYW5nZSB0byBUSFJhbmdlXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJhbmdlKHRoaXMubGVmdENhcmV0Lm5vZGUub3duZXJEb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgdGhpcy5yd19nZXRSZWZQdCh0aGlzLmxlZnRDYXJldC5ub2RlLCB0aGlzLmxlZnRDYXJldC5vZmZzZXQpLFxuICAgICAgICAgICAgdGhpcy5yd19nZXRSZWZQdCh0aGlzLnJpZ2h0Q2FyZXQubm9kZSwgdGhpcy5yaWdodENhcmV0Lm9mZnNldCkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgIEZ1bmN0aW9uIHRvIGdldCBsZWZ0IGFuZCByaWdodCBjYXJldCBwb2ludHMgZm9yIGEgcmFuZ2UuXG4gICAgIFVzZSB0aGlzIHRvIGNoZWNrIGZvciB0aGUgY2FzZSB3ZXJlIHRoZSBsZWZ0IGFuZCByaWdodCBwb2ludCBhcmUgdGhlIHNhbWVcbiAgICAgYXMgb3RoZXJ3aXNlIHdpbGwgZ2V0IHRoZSByaWdodCBjYXJldCBiZWZvcmUgdGhlIGxlZnQgZHVlIHRvIHRoZSBmb3J3YXJkIGJpYXNcbiAgICAgKGUuZy4gPGI+YWI8L2I+Y2QgIGlmIHBvaW50IGlzIHRvIGFmdGVyIGIsIHdpdGggZm9yd2FyZCBiaWFzIHdpbGwgZ2V0IHBvaW50XG4gICAgIGJlZm9yZSB0aGUgYyBhbmQgd2l0aG91dCBmb3J3YXJkIGJpYXMgd2lsbCBnZXQgYWZ0ZXIgdGhlIGIuICBTYW1lIGxvZ2ljYWxseSBpbiB0ZXh0IG9yZGVyXG4gICAgIGJ1dCBhcyBpbiBkaWZmZXJlbnQgbm9kZXMgYW5kIHRoZSBzZWNvbmQgYmVmb3JlIHRoZSBmaXJzdCB0aGlzIGNhc2VzIHByb2JsZW1zLilcbiAgICAgV2l0aCB0aGlzIGZ1bmN0aW9uIGtub3cgdGhhdCB0aGUgdHdvIGNhcmV0cyBhcmUgbGlua2VkIHNvIGNhbiBlbnN1cmUgdGhhdCB0aGUgc2Vjb25kXG4gICAgIGlzIG5vdCBiZWZvcmUgdGhlIGZpcnN0LlxuICAgICAqL1xuICAgIGdldENhcmV0UGFpckZyb21Eb21Qb3NpdGlvbiAocF90aGVCb2R5LCBwX3N0clBhdGhMZWZ0LCBwX25Qb3NMZWZ0LFxuICAgICAgICBwX3N0clBhdGhSaWdodCwgcF9uUG9zUmlnaHQpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdGhpcy5sZWZ0Q2FyZXQgPSBzc2RvbS5nZXRDYXJldEZyb21Eb21Qb3NpdGlvbihwX3RoZUJvZHksIHBfc3RyUGF0aExlZnQsIHBfblBvc0xlZnQsIHRydWUpO1xuXG4gICAgICAgIHZhciByaWdodENhcmV0O1xuICAgICAgICBpZihwX3N0clBhdGhMZWZ0ID09IHBfc3RyUGF0aFJpZ2h0ICYmIHBfblBvc0xlZnQgPj0gcF9uUG9zUmlnaHQpXG4gICAgICAgIHsgICAvLyBBbHNvIGNhdGNoIGNhc2Ugb2YgcmlnaHQgcG9zIGJlaW5nIGxlc3MgdGhhdCBsZWZ0IHBvcyBpbiBzYW1lIG5vZGUuICBTaG91bGQgbm90IGhhcHBlbiBidXRcbiAgICAgICAgICAgIC8vIGlmIHRoYXQgb2NjdXJzIGlzIGEgYnVnIGJ1dCB0aGlzIHNob3VsZCBwcmV2ZW50IHdvcnN0IGVmZmVjdHMgb2YgaXQgaWYgaXQgb2NjdXJzLlxuICAgICAgICAgICAgLy8gSWYgcmlnaHQgcGF0aCBnaXZlcyBub2RlIGJlZm9yZSBsZWZ0IG5vZGUgd2lsbCBzdGlsbCBidWcgYnV0IHRvbyBtdWNoIHRvIGNoZWNrIGV2ZXJ5IHRpbWUgaW4gdGhpcyBoaWdoIHVzZSBtZXRob2QuXG4gICAgICAgICAgICB0aGlzLnJpZ2h0Q2FyZXQgPSB0aGlzLmxlZnRDYXJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRDYXJldCA9IHNzZG9tLmdldENhcmV0RnJvbURvbVBvc2l0aW9uKHBfdGhlQm9keSwgcF9zdHJQYXRoUmlnaHQsIHBfblBvc1JpZ2h0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaWZmIGJldHdlZW4gdGhpcyBhbmQgZ2V0VGV4dE92ZXJDYXJldFJhbmdlIGlzIHRoYXQgdGhpcyBsb29rcyB0byB0aGUgc3BlY2lhbCBlbGVtZW50cywgdG8gc2VlIHdoYXQgaXMgYWN0dWFsbHlcbi8vIHRvIGJlIHNhaWQgbG9va2luZyB0byBhY3JvbnltIHN1YnN0aXR1dGlvbiBldGMuXG4vLyBOQiBldmVuIGlmIGZpbmQgdGhpcyBoYXMgbm8gdXNhZ2VzLCBpcyB1c2VkIGZvciB0ZXN0IHBhZ2UsIHNvIGRvIG5vdCByZW1vdmUhXG4gICAgLyogVXNlIHRoaXMgdG8gZ2V0IHRoZSB0ZXh0IGdpdmVuIGEgY2FyZXQgcmFuZ2UuICBUaGlzIGdldHMgdGhlIHRleHQgdG8gYmUgcmVhZCBvdXQuXG4gICAgIElmIHN0YXJ0cyBpbiBlbGVtZW50IHJhdGhlciB0aGFuIHRleHQgbm9kZSwgd2lsbCBtb3ZlIHRvIG5leHQgdGV4dCBub2RlIHdpdGhvdXQgYWRkaW5nIGFueSB0ZXh0LlxuICAgICBVbmxlc3MgaW1nIHdpdGggbXNnLlxuICAgICAqL1xuICAgIGdldFRleHRTcG9rZW5PdmVyQ2FyZXRSYW5nZSAocF90aENhcmV0UmFuZ2UpXG4gICAgeyAgIC8vIGl0ZXJhdGUgb3ZlciByYW5nZSB0byBnZXQgdGV4dFxuICAgICAgICBsZXQgZG9tTmF2ID0gbmV3IERvbU5hdmlnYXRpb24oKTtcbiAgICAgICAgbGV0IHNzZG9tID0gbmV3IFNTRE9NKCk7XG5cbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHBfdGhDYXJldFJhbmdlID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBwX3RoQ2FyZXRSYW5nZS5sZWZ0Q2FyZXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHBfdGhDYXJldFJhbmdlLnJpZ2h0Q2FyZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxlZnRDYXJldCA9IHBfdGhDYXJldFJhbmdlLmxlZnRDYXJldDtcbiAgICAgICAgICAgIHZhciByaWdodENhcmV0ID0gcF90aENhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0gbGVmdENhcmV0Lm5vZGU7XG4gICAgICAgICAgICB2YXIgcmlnaHROb2RlID0gcmlnaHRDYXJldC5ub2RlO1xuXG4gICAgICAgICAgICB2YXIgYlNwZWNpYWwgPSBzc2RvbS5pc1NwZWNpYWxDYXNlTmVzdGVkKGxlZnROb2RlKTtcbiAgICAgICAgICAgIGlmKGJTcGVjaWFsKVxuICAgICAgICAgICAgeyAgIC8vIHN0YXJ0cyBpbnNpZGUgc3BlY2lhbCBjYXNlLiAgQ2hlY2sgdG8gZW5zdXJlIGlzIG5vdCBuZXN0ZWQgdG9vIGRlZXAuXG4gICAgICAgICAgICAgICAgbGVmdE5vZGUgPSBzc2RvbS5jaGVja0ZvclNwZWNpYWxQYXJlbnQobGVmdE5vZGUpO1xuICAgICAgICAgICAgICAgIGxlZnRDYXJldCA9IG5ldyBUSENhcmV0KGxlZnROb2RlLCAwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJOb2RlID0gbGVmdE5vZGU7XG4gICAgICAgICAgICB2YXIgdHh0ID0gXCJcIjtcbiAgICAgICAgICAgIHdoaWxlKGN1ck5vZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiU3BlY2lhbCA9IHNzZG9tLmlzU3BlY2lhbENhc2UoY3VyTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYoYlNwZWNpYWwgfHwgY3VyTm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IGRvbU5hdi5nZXRUZXh0RnJvbU5vZGUoY3VyTm9kZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYodG1wICE9IG51bGwgJiYgdG1wICE9IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFiU3BlY2lhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXJOb2RlID09IHJpZ2h0Tm9kZSAmJiByaWdodENhcmV0Lm9mZnNldCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLnN1YnN0cmluZygwLCByaWdodENhcmV0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1ck5vZGUgPT0gbGVmdE5vZGUgJiYgbGVmdENhcmV0Lm9mZnNldCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLnN1YnN0cmluZyhsZWZ0Q2FyZXQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHR4dCArPSB0bXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoYlNwZWNpYWwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjdXJOb2RlID0gZG9tTmF2LmdldE5leHROb2RlSWdub3JlQ2hpbGRyZW4oY3VyTm9kZSwgZmFsc2UsIHJpZ2h0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGN1ck5vZGUgPSBkb21OYXYuZ2V0TmV4dE5vZGUoY3VyTm9kZSwgZmFsc2UsIHJpZ2h0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR4dC50cmltVEgoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlcnIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoTG9nKFwiRXJyb3IgZ2V0VGV4dE92ZXJDYXJldFJhbmdlOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4vLyAgICAvKlRoaXMgdXNlcyBhIHBvc2l0aW9uIGluIHRoZSBkb20gdG8gZ2V0IHRoZSB0ZXh0IG5vZGUgcmVmZXJyZWQgdG8uXG4vLyAgICAgVGhlIG9mZnNldCBpcyB1c2VkIHRvIGhhbmRsZSBjYXNlIHdlcmUgdGhlIHRhcmdldCBub2RlIGhhcyBiZWVuIHNwbGl0IGFuZFxuLy8gICAgIHRoZSB0YXJnZXQgd29yZCBpcyBub3QgaW4gdGhlIGZpcnN0IHBhcnQuICBTZXQgdG8gcF9uUG9zIHRvIDAgdG8gYWx3YXlzIGdldCB0aGVcbi8vICAgICBmaXJzdCB0ZXh0IG5vZGUgcmVnYXJkbGVzcyBvZiBzcGxpdC4gIFNldCBwX25Qb3MgdG8gLTEgdG8gZ2V0IHRoZSB0YXJnZXQgbm9kZVxuLy8gICAgIGV2ZW4gaWYgaXQgaXMgbm93IGFuIGVsZW1lbnQgYW5kIG5vdCBhIHRleHQgbm9kZS5cbi8vICAgICA8cD5cbi8vICAgICBOQiBjb3VudCBtdWx0aXBsZSB0ZXh0IG5vZGVzIHRvZ2V0aGVyIGFzIHNpbmdsZSBpdGVtLiAgVGV4dCBjb3VsZCBiZSBzcGxpdFxuLy8gICAgIHNpbmNlIHRoZSBjb3VudCBtYWRlLiAgQWxzbyB0byBtYXRjaCB0aGlzIHdoZW4gY291bnRpbmcgdGFrZSBhZGphY2VudCB0ZXh0IG5vZGVzIGFzIG9uZS5cbi8vICAgICA8cD5cbi8vICAgICBGb3Igc3BlY2lhbCBjYXNlLCBkaXJlY3RzIHRvIGVsZW1lbnQgbm9kZSBub3QgdGV4dCBub2RlLCBoZXJlIG5lZWQgdG8gdGFrZSBlaXRoZXIgc3RhcnQgb3IgZW5kIG9mIGNvbnRhaW5lZCB0ZXh0IGJhc2VkIG9uIHBfYkZvcndhcmRCaWFzXG4vLyAgICAgPHA+XG4vLyAgICAgcF90aGVCb2R5IHRvIGJvZHkgY29udGFpbmluZyB0aGUgbm9kZSB0aGF0IHBhdGggaXMgcmVmZXJlbmNlZCBmcm9tXG4vLyAgICAgcF9zdHJQYXRoIHRoZSBwYXRoIGZyb20gdGhlIGJvZHlcbi8vICAgICBwX25Qb3MgdGhlIG9mZnNldFxuLy8gICAgIHBfYkZvcndhcmRCaWFzIHNldCB0cnVlIGlmIGNhcmV0IGlzIHRvIHJlZmVyIHRvIGNoYXJhY3RlciBhZnRlciBpdHNlbGYsIGZhbHNlIGlmIGlzIHRvIHJlZmVyIHRvIGNoYXJhY3RlciBiZWZvcmUgaXRcbi8vICAgICA8cD4gUmV0dXJucyBUSENhcmV0IG9iamVjdCBjb250YWluaW5nIHRoZSBub2RlIGFuZCBvZmZzZXQuXG4vLyAgICAgKi9cbi8vICAgIGdldENhcmV0RnJvbURvbVBvc2l0aW9uIChwX3RoZUJvZHksIHBfc3RyUGF0aCwgcF9uUG9zLCBwX2JGb3J3YXJkQmlhcywgcF9iRm9yY2VTcGVjaWFsKVxuLy8gICAge1xuLy8gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuLy8gICAgICAgIHZhciBkb21OYXYgPSBuZXcgRG9tTmF2aWdhdGlvbigpO1xuLy8gICAgICAgIGlmKHR5cGVvZihwX2JGb3JjZVNwZWNpYWwpID09IFwidW5kZWZpbmVkXCIpXG4vLyAgICAgICAge1xuLy8gICAgICAgICAgICBwX2JGb3JjZVNwZWNpYWwgPSBmYWxzZTtcbi8vICAgICAgICB9XG4vL1xuLy8gICAgICAgIHRyeVxuLy8gICAgICAgIHtcbi8vICAgICAgICAgICAgaWYocF90aGVCb2R5ID09IG51bGwpXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuLy8gICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIC8vIEdldCB0aGUgbm9kZSBmcm9tIHRoZSBwb3NpdGlvbiBzdHJpbmdcbi8vICAgICAgICAgICAgdmFyIHRoZU5vZGUgPSB0aGlzLmdldE5vZGVGcm9tUG9zaXRpb24ocF90aGVCb2R5LCBwX3N0clBhdGgpO1xuLy9cbi8vICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgaXQgaXMgYSBzcGVjaWFsIGNhc2Vcbi8vXG4vLyAgICAgICAgICAgIGlmKHBfYkZvcmNlU3BlY2lhbClcbi8vICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgdmFyIHRtcENhcmV0ID0gbmV3IFRIQ2FyZXQodGhlTm9kZSwgMCwgcF9iRm9yd2FyZEJpYXMpO1xuLy8gICAgICAgICAgICAgICAgdG1wQ2FyZXQuc2V0U3BlY2lhbENhc2UodHJ1ZSk7XG4vLyAgICAgICAgICAgICAgICByZXR1cm4gdG1wQ2FyZXQ7XG4vLyAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgIHZhciB0bXBOb2RlID0gc3Nkb20uY2hlY2tGb3JTcGVjaWFsUGFyZW50KHRoZU5vZGUpO1xuLy9cbi8vICAgICAgICAgICAgaWYodG1wTm9kZSAhPSBudWxsKVxuLy8gICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICB0aGVOb2RlID0gdG1wTm9kZTtcbi8vXG4vLyAgICAgICAgICAgICAgICAvL2lmIG5vdCBhIGhpZ2hsaWdodGFibGUgb25lIHNob3VsZCBqdXN0IHJldHVybiB0aGUgaXRlbVxuLy8gICAgICAgICAgICAgICAgaWYoc3Nkb20uaXNTcGVjaWFsQ2FzZUhpZ2hsaWdodGFibGUodG1wTm9kZSkpXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgaWYocF9iRm9yd2FyZEJpYXMpXG4vLyAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGdldCBzdGFydFxuLy8gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gZG9tTmF2LmdldEZpcnN0Q2hpbGRUZXh0Tm9kZSh0aGVOb2RlLCBmYWxzZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0YXJ0Tm9kZSAhPSBudWxsKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIQ2FyZXQoc3RhcnROb2RlLCAwLCBwX2JGb3J3YXJkQmlhcyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBhcyBub24gaGlnaGxpZ2h0YWJsZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHRoZU5vZGUsIDAsIHBfYkZvcndhcmRCaWFzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICBlbHNlXG4vLyAgICAgICAgICAgICAgICAgICAgeyAgIC8vZ2V0IGVuZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGRvbU5hdi5nZXRMYXN0Q2hpbGRUZXh0Tm9kZSh0aGVOb2RlLCBmYWxzZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVuZE5vZGUgIT0gbnVsbClcbi8vICAgICAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZW5kTm9kZS5ub2RlVHlwZSA9PSAzKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhDYXJldChlbmROb2RlLCBlbmROb2RlLmxlbmd0aCwgcF9iRm9yd2FyZEJpYXMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8vIGlzIGltZyB3aXRoIG1zZywgbm90IGhpZ2hsaWdodGFibGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIQ2FyZXQoZW5kTm9kZSwgMCwgcF9iRm9yd2FyZEJpYXMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Vcbi8vICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8vIHRyZWF0IGFzIG5vbiBoaWdobGlnaHRhYmxlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIQ2FyZXQodGhlTm9kZSwgMCwgcF9iRm9yd2FyZEJpYXMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgZWxzZVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhDYXJldCh0bXBOb2RlLCAwLCBwX2JGb3J3YXJkQmlhcyk7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIH1cbi8vXG4vL1xuLy8gICAgICAgICAgICB2YXIgbk9mZnNldCA9IDA7XG4vLyAgICAgICAgICAgIGlmKCFwX2JGb3J3YXJkQmlhcylcbi8vICAgICAgICAgICAgeyAgIC8vIExvb2tpbmcgZm9yIGNhcmV0IHBvc2l0aW9uIGp1c3QgYmVmb3JlIHRoZSBwX25Qb3MgcG9pbnQgc28gbmVlZCB0byBiZSBjb21wYXJpbmcgdG8gKzEgcG9zaXRpb25cbi8vICAgICAgICAgICAgICAgICsrbk9mZnNldDtcbi8vICAgICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgICAgaWYocF9uUG9zID4gLTEpXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIC8vIGZvdW5kIG5vZGUsIGJ1dCBtYXkgaGF2ZSBiZWVuIHN1YnNlcXVlbnRseSBzcGxpdCwgc28gbmVlZCB0byBjaGVjayBwYXNzZWQgcG9zaXRpb25cbi8vICAgICAgICAgICAgICAgIC8vIGlzIGluc2lkZSBpdFxuLy8gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGRvZXNudCBnbyBwYXN0IHBhcmVudFxuLy8gICAgICAgICAgICAgICAgaWYodGhlTm9kZSA9PSBudWxsKVxuLy8gICAgICAgICAgICAgICAgeyAgIC8vZXJyb3Jcbi8vICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIHZhciBiTWF0Y2ggPSBmYWxzZTtcbi8vXG4vLyAgICAgICAgICAgICAgICB2YXIgZW5kTm9kZSA9IHRoZU5vZGUucGFyZW50Tm9kZTtcbi8vICAgICAgICAgICAgICAgIHZhciBsYXN0U2FmZU5vZGUgPSB0aGVOb2RlO1xuLy8gICAgICAgICAgICAgICAgdmFyIHRtcFR4dDtcbi8vXG4vLyAgICAgICAgICAgICAgICB3aGlsZSghYk1hdGNoKVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIGlmKHRoZU5vZGUubm9kZVR5cGUgPT0gMylcbi8vICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHRtcFR4dCA9IHRoZU5vZGUubm9kZVZhbHVlO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2hlY2sgaWYgaW4gXCIgKyB0aGVOb2RlLm5vZGVWYWx1ZSArIFwiICB3aGVyZSBvZmZzZXQgaXMgXCIgKyBuT2Zmc2V0ICsgXCIgYW5kIHBvcyBcIiArIHBfblBvcyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBfblBvcyA8IChuT2Zmc2V0ICsgdG1wVHh0Lmxlbmd0aCkpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHsgLy8gZm91bmRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJ5ZXNcIik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICBiTWF0Y2ggPSB0cnVlO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTYWZlTm9kZSA9IHRoZU5vZGU7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgKz0gdGhlTm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgdGhlTm9kZSA9IGRvbU5hdi5nZXROZXh0Tm9kZSh0aGVOb2RlLCBmYWxzZSwgZW5kTm9kZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodGhlTm9kZS5ub2RlVHlwZSA9PSAxKVxuLy8gICAgICAgICAgICAgICAgICAgIHsgICAvLyBjaGVjayBpZiBzcGVjaWFsIGNhc2Ugb2Ygbm9kZSwgaS5lLiBlbGVtZW50IHRoYXQgY2FuIGJlIHNwb2tlbiAoaW1nIHdpdGggbXNnKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICB0bXBOb2RlID0gc3Nkb20uY2hlY2tGb3JTcGVjaWFsUGFyZW50KHRoZU5vZGUpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICBpZih0bXBOb2RlICE9IG51bGwpXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZU5vZGUgPSB0bXBOb2RlO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlnaHQgaGF2ZSBmb3VuZCB0YXJnZXRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBvZmZzZXQgc2hvdWxkIG5vdCB0YWtlIGl0IG9uIHBhc3QgdGhpc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgcF9uUG9zIG1hdGNoZXMgbk9mZnNldCB0aGVuIG1hdGNoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbkRpZmYgPSBwX25Qb3MgLSBuT2Zmc2V0O1xuLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5EaWZmID4gMClcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNhcnJ5IG9uXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk9mZnNldCArPSAxO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJNYXRjaCA9IHRydWU7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGNoaWxkcmVuIHNvIGRvIG5vdCBpbmNsdWRlIHRleHQgb2Ygc3BlY2lhbCBub2RlIGFuZCBhbHNvIGluY2x1ZGUgdGhlICsxIGhlcmVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZU5vZGUgPSBkb21OYXYuZ2V0TmV4dE5vZGVJZ25vcmVDaGlsZHJlbih0aGVOb2RlLCBmYWxzZSwgZW5kTm9kZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVOb2RlID0gZG9tTmF2LmdldE5leHROb2RlKHRoZU5vZGUsIGZhbHNlLCBlbmROb2RlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGVOb2RlICsgXCIgXCIgKyB0aGVOb2RlLnRhZ05hbWUgKyBcIiBcIiArIHRoZU5vZGUubm9kZVZhbHVlKTtcbi8vICAgICAgICAgICAgICAgICAgICBpZih0aGVOb2RlID09IG51bGwgfHwgdGhlTm9kZSA9PSBlbmROb2RlKVxuLy8gICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAvLyBhbGVydChcIiBcIiArIHBfc3RyUGF0aCArIFwiIDw9PiBcIiArIHBfblBvcyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIC8vc2hvdWxkbnQgcmVhbGx5IGhhcHBlbiwgYnV0IGRvbnQgYWx3YXlzIGhhdmUgdmFsaWQgZGF0YSBzbyB0aGlzIGNhdGNoZXMgdGhlIGRvZGd5IGNhc2Vcbi8vICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGhhcHBlbiBkdWUgdG8gb2Zmc2V0IGNhbGN1bGF0aW9uIGJlaW5nIHdyb25nLCBzb21lIGVsZW1lbnRzIGNhbiBnaXZlIHVuZXhwZWN0ZWQgb2Zmc2V0LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyBkbyBub3Qga25vdyBleGFjdGx5IGhvdyB0aGUgZGlmZmVyZW50IGJyb3dzZXJzIHdvcmsgaXQgb3V0IGZvciB0aGVtc2VsdmVzLlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAvL0luIHRoaXMgY2FzZSB1c2UgbGFzdCBzYWZlIG9mZnNldCwgbW9zdCBsaWtlbHkgd29yayBvciBhdCBsZWFzdCBoaWdobGlnaHQgbW9zdCBvZiB3b3JkXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxhc3RTYWZlTm9kZSAhPSBudWxsKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVOb2RlID0gbGFzdFNhZmVOb2RlO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhlTm9kZS5ub2RlVHlwZSA9PSAzKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBvZiBuT2Zmc2V0IHNldCBiZWxvdyBpcyBwdXJlbHkgZG9uZSB0byBjYW5jZWwgb3V0IGluXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRpb24gZnVydGhlciBkb3duIGZvciBuZXcgVEhDYXJldFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgPSBwX25Qb3MgLSB0aGVOb2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAgIC8vIHN1Y2ggYXMgaW1nXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk9mZnNldCA9IDA7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXBfYkZvcndhcmRCaWFzKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbk9mZnNldDtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Vcbi8vICAgICAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICB9XG4vL1xuLy8gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInRoZU5vZGUgXCIgKyB0aGVOb2RlICsgXCIgICBcIiArIHRoZU5vZGUubm9kZVZhbHVlICsgXCIgIGZyb20gXCIgKyBwX3N0clBhdGgpO1xuLy8gICAgICAgICAgICAgICAgaWYocF9iRm9yd2FyZEJpYXMpXG4vLyAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHRoZU5vZGUsIHBfblBvcyAtIG5PZmZzZXQsIHBfYkZvcndhcmRCaWFzKTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGVsc2Vcbi8vICAgICAgICAgICAgICAgIHsgICAvLyByZW1lbWJlciB0byByZW1vdmUgdGhlIGV4dHJhIHBhcnQgYWRkZWQgb24gdG8gc3RvcCBnb2luZyB0byBuZXh0IG5vZGUuXG4vLyAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSENhcmV0KHRoZU5vZGUsIHBfblBvcyAtIChuT2Zmc2V0IC0gMSksIHBfYkZvcndhcmRCaWFzKTtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICBlbHNlXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhDYXJldCh0aGVOb2RlLCBwX25Qb3MsIHBfYkZvcndhcmRCaWFzKTtcbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgIH1cbi8vICAgICAgICBjYXRjaChlcnIpXG4vLyAgICAgICAgeyAgIC8vIExpa2VseSB0aGF0IHBhdGggaXMgbm8gbG9uZ2VyIHZhbGlkXG4vLyAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0Q2FyZXRGcm9tRG9tUG9zaXRpb24gZXJyb3I6IFwiICsgZXJyKTtcbi8vXG4vLyAgICAgICAgICAgIHJldHVybiBudWxsO1xuLy8gICAgICAgIH1cbi8vICAgIH1cbi8vXG4vL1xuLy9cbi8vICAgIC8qVXNlZCBieSBnZXRDYXJldEZyb21Eb21Qb3NpdGlvblxuLy8gICAgIHJldHVybnMgYSBub2RlIG9yIG51bGwgaWYgZXJyb3Igb2NjdXJzKi9cbi8vICAgIGdldE5vZGVGcm9tUG9zaXRpb24gKHBfdGhlQm9keSwgcF9zdHJQYXRoKVxuLy8gICAge1xuLy8gICAgICAgIHZhciBzc2RvbSAgPSBuZXcgU1NET00oKTtcbi8vICAgICAgICB2YXIgYXR0cmlidXRlICA9IG5ldyBBdHRyaWJ1dGUoKTtcbi8vICAgICAgICB2YXIgdGhlTm9kZSA9IHBfdGhlQm9keTtcbi8vXG4vLyAgICAgICAgLy8gbG9naWMgdG8gcmVtb3ZlIGNodW5rIHBhcnQgb2YgcGF0aFxuLy8gICAgICAgIGlmKHBfc3RyUGF0aC5sYXN0SW5kZXhPZihcIipcIikgPiAtMSlcbi8vICAgICAgICB7XG4vLyAgICAgICAgICAgIHZhciBuUG9zID0gcF9zdHJQYXRoLmxhc3RJbmRleE9mKFwiKlwiKTtcbi8vICAgICAgICAgICAgcF9zdHJQYXRoID0gcF9zdHJQYXRoLnN1YnN0cmluZyhuUG9zICsgMSk7XG4vLyAgICAgICAgfVxuLy9cbi8vICAgICAgICAvLyBwYXJzZSBvZmZzZXQgdmFsdWVzIGFuZCBpdGVyYXRlIGVuZCB0byBzdGFydCxcbi8vICAgICAgICAvL21vdmluZyBzZXQgbnVtYmVyIG9mIG5vZGVzIHRvIHJpZ2h0IGJlZm9yZSBnb2luZyB0byBuZXh0IGxldmVsXG4vLyAgICAgICAgdmFyIGFTdHIgPSBwX3N0clBhdGguc3BsaXQoXCJ+XCIpO1xuLy8gICAgICAgIHZhciBuTGVuID0gYVN0ci5sZW5ndGg7XG4vLyAgICAgICAgdmFyIGk7XG4vL1xuLy8gICAgICAgIGZvcihpID0gbkxlbiAtIDI7IGkgPiAtMTsgaS0tKVxuLy8gICAgICAgIHtcbi8vICAgICAgICAgICAgdGhlTm9kZSA9IHRoZU5vZGUuZmlyc3RDaGlsZDtcbi8vICAgICAgICAgICAgaWYodGhlTm9kZSA9PSBudWxsKVxuLy8gICAgICAgICAgICB7ICAgLy9lcnJvclxuLy8gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4vLyAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgdmFyIG5WYWw7XG4vLyAgICAgICAgICAgIGlmKGFTdHJbaV0ubGVuZ3RoID09IDApXG4vLyAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgIG5WYWwgPSAwO1xuLy8gICAgICAgICAgICB9XG4vLyAgICAgICAgICAgIGVsc2Vcbi8vICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgblZhbCA9IHBhcnNlSW50KGFTdHJbaV0sIDEwKTtcbi8vICAgICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgICAgLy8gVG8gY2hlY2sgZm9yIG11bHRpcGxlIHRleHQgbm9kZXMgdG9nZXRoZXJcbi8vXG4vLyAgICAgICAgICAgIHZhciBiSXNUZXh0ID0gZmFsc2U7XG4vLyAgICAgICAgICAgIHZhciBiV2FzTGFzdFRleHQgPSAodGhlTm9kZS5ub2RlVHlwZSA9PSAzKSB8fFxuLy8gICAgICAgICAgICAgICAgKHRoZU5vZGUubm9kZVR5cGUgPT0gMSAmJlxuLy8gICAgICAgICAgICAgICAgICAgIHRoZU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IFwic3BhblwiICYmXG4vLyAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnJ3X2dldEF0dHJpYnV0ZSh0aGVOb2RlLCBcInJ3c3RhdGVcIikgIT0gbnVsbCk7XG4vL1xuLy8gICAgICAgICAgICB3aGlsZShuVmFsID4gMClcbi8vICAgICAgICAgICAgeyAgIC8vIG5lZWQgdG8gbW92ZSByaWdodFxuLy8gICAgICAgICAgICAgICAgdGhlTm9kZSA9IHRoZU5vZGUubmV4dFNpYmxpbmc7XG4vL1xuLy8gICAgICAgICAgICAgICAgaWYodGhlTm9kZSA9PSBudWxsKVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuLy8gICAgICAgICAgICAgICAgfVxuLy9cbi8vICAgICAgICAgICAgICAgIGJJc1RleHQgPSAodGhlTm9kZS5ub2RlVHlwZSA9PSAzKSB8fFxuLy8gICAgICAgICAgICAgICAgICAgICh0aGVOb2RlLm5vZGVUeXBlID09IDEgJiZcbi8vICAgICAgICAgICAgICAgICAgICAgICAgdGhlTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJzcGFuXCIgLypTU0RBVC5wYWdlRGF0YS5zdHJIaWdobGlnaHRUYWcqLyAmJlxuLy8gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRoZU5vZGUsIFwicndzdGF0ZVwiKSAhPSBudWxsKTtcbi8vICAgICAgICAgICAgICAgIGlmKGJJc1RleHQgJiYgYldhc0xhc3RUZXh0KVxuLy8gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgIC8vIHRleHQgdG9nZXRoZXIga2VlcCBtb3Zpbmdcbi8vICAgICAgICAgICAgICAgICAgICAvLyBsZWF2ZSBiV2FzTGFzdFRleHQgYXMgaXNcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGVsc2Vcbi8vICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAtLW5WYWw7XG4vLyAgICAgICAgICAgICAgICAgICAgYldhc0xhc3RUZXh0ID0gYklzVGV4dDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgICAgICAgICAvLyBmb3IgYWxsIG5vbiB0ZXh0IHdpbGwgZGVjcmVhc2UgblZhbFxuLy8gICAgICAgICAgICAgICAgLy8gZm9yIG5vbiB0ZXh0IHRvIG5vbiB0ZXh0IHdpbGwgbGVhdmUgYldhc0xhc3RUZXh0IGZhbHNlXG4vLyAgICAgICAgICAgICAgICAvLyBmb3Igbm9uIHRleHQgdG8gdGV4dCB3aWxsIHNldCBiV2FzTGFzdFRleHQgdHJ1ZVxuLy9cbi8vICAgICAgICAgICAgICAgIC8vIGZvciB0ZXh0IHRvIHRleHQgd2lsbCBsZWF2ZSBhcyBpczsgYW5kIG5vIGRlY3JlYXNlIG9mIG5WYWxcbi8vICAgICAgICAgICAgICAgIC8vIGZvciB0ZXh0IHRvIG5vbiB0ZXh0IHdpbGwgc2V0IGJXYXNMYXN0VGV4dCB0byBmYWxzZTsgYW5kIGRlY3JlYXNlIG5WYWxcbi8vXG4vLyAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IGNhcmUgaGVyZSBpZiB0ZXh0IGlzIGVtcHR5IGhlcmUsIGlmIHRoYXQgaXMgYSBwcm9ibGVtIG5lZWQgdG8gcmVtb3ZlIGVtcHR5XG4vLyAgICAgICAgICAgICAgICAvLyB0ZXh0IGluIHRhZ3NlbnRlbmNlcyBtZXRob2QsIGFzIGlzIGRvbmUgd2l0aCBwa3Rcbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgIH1cbi8vICAgICAgICByZXR1cm4gdGhlTm9kZTtcbi8vICAgIH07XG5cblxuXG59XG5cbiIsIi8qKlxuICogQ3JlYXRlZCBieSBrZXZpbiBvbiAzMS8wMy8xNi5cbiAqL1xuLy8qISBVc2VkIGJ5IHNhZmFyaVJlYWRlclxuaW1wb3J0IHtUSENhcmV0UmFuZ2V9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhDYXJldFJhbmdlJ1xuaW1wb3J0IHtUSENhcmV0fSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL1RIQ2FyZXQnXG5pbXBvcnQge1RIRG9tUmVmUHR9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhEb21SZWZQdCdcbmltcG9ydCB7U1NET019IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL1NTRE9NJ1xuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL0F0dHJpYnV0ZSdcbmltcG9ydCAqIGFzIENvbnN0YW50cyBmcm9tICdzcmMvQ29uc3RhbnRzL0NvbnN0YW50cydcblxuXG4vKlRoaXMgaG9sZHMgdGhlIHJhbmdlIGluIGEgZG9tIGluIGEgd2F5IHRoYXQgd2lsbCBub3QgYmUgYnJva2VuIGJ5IG5vZGVzIGJlaW5nIHNwbGl0IHVwLlxuIEl0IGhvbGRzIHBvc2l0aW9ucyBieSBub2RlIHJlZiBhbmQgYnkgc3RyaW5nIG1hcHBpbmcgdG8gdGhlIG5vZGUuKi9cbmV4cG9ydCBjbGFzcyBUSERvbVJhbmdlXG57XG4gICAgY29uc3RydWN0b3IocF9zdGFydE5vZGUsIHBfblN0YXJ0T2Zmc2V0LCBwX2VuZE5vZGUsIHBfbkVuZE9mZnNldClcbiAgICB7XG4gICAgICAgIHRoaXMuYm9keSA9IHBfc3RhcnROb2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgdGhpcy5zdGFydENhcmV0ID0gbmV3IFRIQ2FyZXQocF9zdGFydE5vZGUsIHBfblN0YXJ0T2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5lbmRDYXJldCA9IG5ldyBUSENhcmV0KHBfZW5kTm9kZSwgcF9uRW5kT2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc3RhcnRSZWYgPSB0aGlzLnJ3X2dldFJlZlB0KHBfc3RhcnROb2RlLCBwX25TdGFydE9mZnNldCk7XG4gICAgICAgIHRoaXMuZW5kUmVmID0gdGhpcy5yd19nZXRSZWZQdChwX2VuZE5vZGUsIHBfbkVuZE9mZnNldCk7XG5cbiAgICB9XG5cbiAgICBnZXRQb3NpdGlvbkluRG9tIChwX3RoZU5vZGUpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgdmFyIHN0clBvcyA9IFwiXCI7XG4gICAgICAgIHZhciBuTGVmdENvdW50ID0gMDtcbiAgICAgICAgdmFyIHByZWZpeCA9IFwiXCI7XG4gICAgICAgIGlmKHBfdGhlTm9kZSAhPSBudWxsICYmIHBfdGhlTm9kZS5vd25lckRvY3VtZW50ICE9IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBiV2FzTGFzdFRleHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBiSXNUZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYm9kID0gcF90aGVOb2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIHdoaWxlKHBfdGhlTm9kZSAhPSBudWxsICYmIHBfdGhlTm9kZSAhPSBib2QpXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICBpZihzc2RvbS5pc1NwZWNpYWxDYXNlKHBfdGhlTm9kZSkpXG4gICAgICAgICAgICAgICAgeyAgIC8vIHJlc2V0IHBhdGggc28gZGlyZWN0cyBzdHJhaWdodCB0byB0aGlzXG4gICAgICAgICAgICAgICAgICAgIHN0clBvcyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJXYXNMYXN0VGV4dCA9IChwX3RoZU5vZGUubm9kZVR5cGUgPT0gMykgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBfdGhlTm9kZS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwX3RoZU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09IENvbnN0YW50cy5ISUdITElHSFRfVEFHICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHBfdGhlTm9kZSwgXCJyd3N0YXRlXCIpICE9IG51bGwpOyAgLy8gc2V0IHRydWUgaWYgdGV4dCBmb3Igb3JpZy5cbiAgICAgICAgICAgICAgICB2YXIgYU5vZGUgPSBwX3RoZU5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHdoaWxlKGFOb2RlICE9IG51bGwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiSXNUZXh0ID0gKGFOb2RlLm5vZGVUeXBlID09IDMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYU5vZGUubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBDb25zdGFudHMuSElHSExJR0hUX1RBRyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUoYU5vZGUsIFwicndzdGF0ZVwiKSAhPSBudWxsKTsgLy8gc2V0IGZvciBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYoYldhc0xhc3RUZXh0ICYmIGJJc1RleHQpXG4gICAgICAgICAgICAgICAgICAgIHsgICAvLyBkb250IGluY3JlbWVudCBmb3IgdHdvIHRleHQgbm9kZXMgdG9nZXRoZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrbkxlZnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhTm9kZSA9IGFOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgYldhc0xhc3RUZXh0ID0gYklzVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyUG9zID0gc3RyUG9zICsgbkxlZnRDb3VudCArIFwiflwiO1xuICAgICAgICAgICAgICAgIG5MZWZ0Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHBfdGhlTm9kZSA9IHBfdGhlTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmKHBfdGhlTm9kZSAhPSBudWxsICYmIHBfdGhlTm9kZS5nZXRBdHRyaWJ1dGUgIT0gbnVsbCAmJiBwX3RoZU5vZGUudGFnTmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR0bXAgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHBfdGhlTm9kZSwgXCJjaHVua1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYocF90aGVOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSBcInNwYW5cIiAmJiB0dG1wID09IFwiMVwiKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJQb3MgPSBhdHRyaWJ1dGUuZ2V0UG9zaXRpb25JbkRvbShwX3RoZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCIjXnRoKlwiICsgaW5uZXJQb3MgKyBcIiNedGgqXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHN0clBvcztcbiAgICB9O1xuXG4gICAgcndfZ2V0UmVmUHQocF9ub2RlLCBwX25PZmZzZXQpXG4gICAge1xuICAgICAgICB2YXIgUldUSF9HRU5FUkFURUQgPVwicndUSGdlblwiK1wiXCIgO1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBBdHRyaWJ1dGUoKTtcbiAgICAgICAgdHJ5XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGlmIHRleHQgbm9kZSB3YW50IHJlZiB0byBwYXJlbnQgd2l0aCBvZmZzZXQgdG8gZ2V0IHRvIHJpZ2h0IHBvaW50XG4gICAgICAgICAgICAvLyBpZiBwYXNzZWQgZWxlbWVudCB3YW50IGRpcmVjdCByZWYgdG8gaXQgYW5kIG9mZnNldCBpcyBpcnJlbGV2YW50XG4gICAgICAgICAgICBpZihwX25vZGUgPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYocF9ub2RlLm5vZGVUeXBlID09IDEgfHwgcF9ub2RlLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGV4dCBpcyBpbnNpZGUgc3BlY2lhbCBjYXNlXG5cbiAgICAgICAgICAgICAgICB2YXIgdG1wUGFyID0gc3Nkb20uY2hlY2tGb3JTcGVjaWFsUGFyZW50KHBfbm9kZSk7XG4gICAgICAgICAgICAgICAgaWYodG1wUGFyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgeyAgIC8vIGlzIGluIHNwZWNpYWwgY2FzZSBzbyBuZWVkIHRvIGV4dGVuZCByYW5nZSB0byBpbmNsdWRlIHdob2xlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSERvbVJlZlB0KHRoaXMuZ2V0UG9zaXRpb25JbkRvbSh0bXBQYXIpLCBwX25PZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGdldCBvZmZzZXQgb2YgcGFzc2VkIG5vZGVcbiAgICAgICAgICAgICAgICB2YXIgbk9mZnNldDtcblxuICAgICAgICAgICAgICAgIHZhciB0aGVQYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZihwX25vZGUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGVQYXJlbnQgPSBwX25vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdXNlcyBhIHByb2JsZW0gaW4gdGlueW1jZSwgbm90IHN1cmUgd2h5IHRoaXMgaXMgdGhlcmUsIGJ1dCBiZWVuIGxvbmcgdGltZSBzbyByaXNrIG9mIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYml6YXJyZSBzaWRlIGFmZmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAvL3RvZG8gY2hlY2sgaG93IHRoaXMgYWZmZWN0cyBzdGlja3kgbm90ZXMuXG4vLyAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNoZWNrIGZvciBzZWxlY3Rpbmcgbm9kZSB3aGVyZSBpcyBpbiB3aGl0ZXNwYWNlIG9ubHkgZWxlbWVudCwgbWlnaHQgb25seSBleGlzdCBvblxuLy8gICAgICAgICAgICAgICAgLy8gZmlyZWZveFxuLy8gICAgICAgICAgICAgICAgaWYocF9ub2RlLm5vZGVWYWx1ZS50cmltVEgoKS5sZW5ndGggPT0gMClcbi8vICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgIHBfbk9mZnNldCA9IDA7XG4vLyAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbk9mZnNldCA9IHRoaXMuZ2V0Tm9kZU9mZnNldF8ocF9ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhlUGFyZW50ID0gcF9ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRoZVBhcmVudCwgXCJyd3N0YXRlXCIpO1xuICAgICAgICAgICAgICAgIHZhciB0aGdlbkF0dHIgPSBhdHRyaWJ1dGUucndfZ2V0QXR0cmlidXRlKHRoZVBhcmVudCwgUldUSF9HRU5FUkFURUQpO1xuICAgICAgICAgICAgICAgIHdoaWxlKCAoYXR0ciAhPSBudWxsICYmIGF0dHIubGVuZ3RoID4gMCkgfHwgdGhnZW5BdHRyIT0gbnVsbCApXG4gICAgICAgICAgICAgICAgeyAgIC8vIEl0IGlzIGEgcndvbmxpbmUgYWRkZWQgZWxlbWVudCBtb3ZlIHVwIGFnYWluICggc3Mgc3Agb3IgY3NwKVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpcyBhdXRvZ2VuZXJhdGUgc3BhbiB0YWcgZm9yIHNwbGl0IHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyBvciBpZiBmb250IGVsZW1lbnQgYXMgdGhpcyBhZGRlZCBieSBJRSBmb3IgaGlnaGxpZ2h0aW5nXG4gICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgKz0gdGhpcy5nZXROb2RlT2Zmc2V0Xyh0aGVQYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGVQYXJlbnQgPSB0aGVQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUodGhlUGFyZW50LCBcInJ3c3RhdGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoZ2VuQXR0ciA9IGF0dHJpYnV0ZS5yd19nZXRBdHRyaWJ1dGUodGhlUGFyZW50LCBSV1RIX0dFTkVSQVRFRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHBfbk9mZnNldCA9PSAtMSlcbiAgICAgICAgICAgICAgICB7ICAgLy8gY2FzZSBvZiB0ZXh0IG5vZGUgaW4gYSBzcGVjaWFsIGNhc2UgKGFiYnIpXG4gICAgICAgICAgICAgICAgICAgIG5PZmZzZXQgPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSERvbVJlZlB0KHRoaXMuZ2V0UG9zaXRpb25JbkRvbSh0aGVQYXJlbnQpLCBuT2Zmc2V0ICsgcF9uT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaChpZ25vcmUpXG4gICAgICAgIHsgICAvLyBsaWtlbHkgaW52YWxpZCBub2RlIHBhc3NlZCBnaXZpbmcgbnVsbCBwYXJlbnRcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSB0ZXh0IG9mZnNldCBvZiB0aGUgbm9kZSBmcm9tIGFsbCB0ZXh0IGNvbnRhaW5lZCBieSB0aGUgcGFyZW50LlxuICAgIGdldE5vZGVPZmZzZXRfKHBfbm9kZSlcbiAgICB7XG4gICAgICAgIHZhciBzc2RvbSA9IG5ldyBTU0RPTSgpO1xuICAgICAgICBpZihwX25vZGUgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5PZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbGVmdE5vZGUgPSBwX25vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZihsZWZ0Tm9kZSAhPSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBuT2Zmc2V0ID0gc3Nkb20ucndfZ2V0Tm9kZU9mZnNldEltcGwobGVmdE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuT2Zmc2V0O1xuICAgIH1cblxuICAgIC8qVGhpcyBjaGVja3MgdGhhdCB0aGUgbm9kZXMgYXJlIHZhbGlkIGFuZCBpZiBub3QgdXBkYXRlcyB0aGVtKi9cbiAgICByZWZyZXNoICAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0Q2FyZXQuY2hlY2soKSA9PSBmYWxzZSB8fCB0aGlzLmVuZENhcmV0LmNoZWNrKCkgPT0gZmFsc2UpIHsgICAvLyBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBub2Rlc1xuXG4gICAgICAgICAgICB2YXIgY2FyZXRSYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UodGhpcy5ib2R5LFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZWYucGF0aCxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVmLm9mZnNldCxcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFJlZi5wYXRoLFxuICAgICAgICAgICAgICAgIHRoaXMuZW5kUmVmLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q2FyZXQgPSBjYXJldFJhbmdlLmxlZnRDYXJldDtcbiAgICAgICAgICAgIHRoaXMuZW5kQ2FyZXQgPSBjYXJldFJhbmdlLnJpZ2h0Q2FyZXQ7XG5cbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIG51bGwgd2hpY2ggd2lsbCBjYXVzZSBjcmFzaCwgYmVzdCByZWNvdmVyeSBpcyB0byBqdXN0IHNldCB0byBhbiBlbnB0eSBzZWxlY3Rpb24gdG8gYXZvaWQgY3Jhc2hpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0Q2FyZXQgPT0gbnVsbCAmJiB0aGlzLmVuZENhcmV0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q2FyZXQgPSBuZXcgVEhDYXJldChkb2N1bWVudC5ib2R5LCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZENhcmV0ID0gbmV3IFRIQ2FyZXQoZG9jdW1lbnQuYm9keSwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFydENhcmV0ID09IG51bGwgfHwgdGhpcy5lbmRDYXJldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRDYXJldCA9PSBudWxsKSB7ICAgLy8gZW5kIHZhbGlkLCBzdGFydCBmYWlsZWQsIGNvbGxhcHNlIHRvIGVuZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q2FyZXQgPSBuZXcgVEhDYXJldCh0aGlzLmVuZENhcmV0Lm5vZGUsIHRoaXMuZW5kQ2FyZXQub2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7ICAgLy8gc3RhcnQgdmFsaWQsIGVuZCBmYWlsZWQsIGNvbGxhcHNlIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FyZXQgPSBuZXcgVEhDYXJldCh0aGlzLnN0YXJ0Q2FyZXQubm9kZSwgdGhpcy5zdGFydENhcmV0Lm9mZnNldCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuLy8gZ2V0cyB0aGUgdGV4dCBvZiB0aGUgb2JqZWN0XG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgICBsZXQgc3Nkb20gPSBuZXcgU1NET00oKTtcblxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICBsZXQgdGhDYXJldFJhbmdlID0gbmV3IFRIQ2FyZXRSYW5nZSgpO1xuICAgICAgICB0aENhcmV0UmFuZ2Uuc2V0Q2FyZXRSYW5nZSh0aGlzLnN0YXJ0Q2FyZXQsdGhpcy5lbmRDYXJldCk7XG4gICAgICAgIHJldHVybiB0aENhcmV0UmFuZ2UuZ2V0VGV4dFNwb2tlbk92ZXJDYXJldFJhbmdlKHRoQ2FyZXRSYW5nZSk7XG4gICAgfTtcblxuICAgIC8vIGdldCByYW5nZSBvciB0ZXh0cmFuZ2VcbiAgICBnZXRSYW5nZU9iamVjdChwX2JvZHkpXG4gICAge1xuICAgICAgICBpZih0eXBlb2YocF9ib2R5KSA9PSAndW5kZWZpbmVkJyB8fCBwX2JvZHkgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgcF9ib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHZhciBkb2MgPSBwX2JvZHkub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlUmFuZ2UoKTtcblxuICAgfVxuXG4vLyBHZXQgYSByYW5nZSBvYmplY3QgcmVmZXJpbmcgdG8gdGhlIHN0YXJ0IHBvaW50IG9mIHRoaXNcbiAgZ2V0U3RhcnRBc1JhbmdlICAoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2VPYmplY3QodGhpcy5ib2R5KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGhpcy5zdGFydENhcmV0Lm5vZGUsIHRoaXMuc3RhcnRDYXJldC5vZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRFbmQodGhpcy5zdGFydENhcmV0Lm5vZGUsIHRoaXMuc3RhcnRDYXJldC5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcblxuLy8gR2V0IGEgcmFuZ2Ugb2JqZWN0IHJlZmVyaW5nIHRvIHRoZSBlbmQgcG9pbnQgb2YgdGhpc1xuICBnZXRFbmRBc1JhbmdlICAoKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2VPYmplY3QodGhpcy5ib2R5KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGhpcy5lbmRDYXJldC5ub2RlLCB0aGlzLmVuZENhcmV0Lm9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldEVuZCh0aGlzLmVuZENhcmV0Lm5vZGUsIHRoaXMuZW5kQ2FyZXQub2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICAvKkNvbXBhcmVzIHN0YXJ0IGFuZCBlbmQgcG9pbnRzKi9cbiAgICBlcXVhbHMgIChwX3RhcmdldCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRSZWYucGF0aCA9PSBwX3RhcmdldC5zdGFydFJlZi5wYXRoXG4gICAgICAgICAgICAmJiB0aGlzLnN0YXJ0UmVmLm9mZnNldCA9PSBwX3RhcmdldC5zdGFydFJlZi5vZmZzZXRcbiAgICAgICAgICAgICYmIHRoaXMuZW5kUmVmLnBhdGggPT0gcF90YXJnZXQuZW5kUmVmLnBhdGhcbiAgICAgICAgICAgICYmIHRoaXMuZW5kUmVmLm9mZnNldCA9PSBwX3RhcmdldC5lbmRSZWYub2Zmc2V0KTtcbiAgICB9O1xuXG4gICAgLypUaGlzIGNvbXBhcmVzIHJhbmdlIHdpdGggb3RoZXIgVEhEb21SYW5nZS4qL1xuICAgIGNvbXBhcmVSYW5nZSAgKHBfdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmVxdWFscyhwX3RhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBDb25zdGFudHMuVEhEb21SYW5nZV9UQVJHRVRfU0FNRTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICBwX3RhcmdldC5yZWZyZXNoKCk7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkU3RhcnQgPSB0aGlzLmdldFN0YXJ0QXNSYW5nZSgpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRFbmQgPSB0aGlzLmdldEVuZEFzUmFuZ2UoKTtcblxuICAgICAgICB2YXIgdGFyZ2V0U3RhcnQgPSBwX3RhcmdldC5nZXRTdGFydEFzUmFuZ2UoKTtcbiAgICAgICAgdmFyIHRhcmdldEVuZCA9IHBfdGFyZ2V0LmdldEVuZEFzUmFuZ2UoKTtcblxuICAgICAgICAvL3ZhciBuUmVzID0gcndfd2hpY2hOb2RlRmlyc3QodG1wLnN0YXJ0Tm9kZSwgdG1wLmVuZE5vZGUpO1xuICAgICAgICB2YXIgblN0YXJ0RGlmZjEgPSBzZWxlY3RlZFN0YXJ0LmNvbXBhcmVCb3VuZGFyeVBvaW50cyhcIlNUQVJUX1RPX1NUQVJUXCIsIHRhcmdldFN0YXJ0KTtcbiAgICAgICAgdmFyIG5TdGFydERpZmYyID0gc2VsZWN0ZWRTdGFydC5jb21wYXJlQm91bmRhcnlQb2ludHMoXCJTVEFSVF9UT19TVEFSVFwiLCB0YXJnZXRFbmQpO1xuICAgICAgICB2YXIgbkVuZERpZmYxID0gc2VsZWN0ZWRFbmQuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKFwiU1RBUlRfVE9fU1RBUlRcIiwgdGFyZ2V0U3RhcnQpO1xuICAgICAgICB2YXIgbkVuZERpZmYyID0gc2VsZWN0ZWRFbmQuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKFwiU1RBUlRfVE9fU1RBUlRcIiwgdGFyZ2V0RW5kKTtcblxuICAgICAgICB2YXIgblJlc3VsdCA9IENvbnN0YW50cy5USERvbVJhbmdlX0VSUk9SO1xuXG4gICAgICAgIC8vIGNvdmVyIHR3byBzcGVjaWFsIGNhc2VzIGZpcnN0IHRoYXQgYXJlIG1vc3QgY29tbW9uIHJlc3VsdHMgdGhlbiBkbyBzdGFydCBkaWZmIC0+IGVuZCBkaWZmIGNvbWJpbmF0aW9uc1xuICAgICAgICBpZiAoblN0YXJ0RGlmZjIgPiAtMSkgeyAgIC8vIFRhcmdldCBlbmRzIGJlZm9yZSB0aGlzIHN0YXJ0c1xuICAgICAgICAgICAgblJlc3VsdCA9IENvbnN0YW50cy5USERvbVJhbmdlX0FGVEVSX1RBUkdFVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuRW5kRGlmZjEgPCAxKSB7ICAgLy8gVGFyZ2V0IHN0YXJ0cyBhZnRlciB0aGlzIGVuZHNcbiAgICAgICAgICAgIG5SZXN1bHQgPSBDb25zdGFudHMuVEhEb21SYW5nZV9CRUZPUkVfVEFSR0VUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5TdGFydERpZmYxID09IC0xKSB7ICAgLy8gc3RhcnRzIGJlZm9yZSB0YXJnZXRcbiAgICAgICAgICAgIC8vIG5FbmREaWZmMSA8IDEgZG9uZSBhbHJlYWR5XG5cbiAgICAgICAgICAgIGlmIChuRW5kRGlmZjIgPT0gLTEpIHsgICAvLyBvdmVybGFwcyBzdGFydCBvZiB0YXJnZXRcbiAgICAgICAgICAgICAgICBuUmVzdWx0ID0gQ29uc3RhbnRzLlRIRG9tUmFuZ2VfT1ZFUkxBUFNfU1RBUlRfT0ZfVEFSR0VUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSAvLyBpZihuRW5kRGlmZjIgPiAtMSlcbiAgICAgICAgICAgIHsgICAvLyBpbmNsdWRlcyB0YXJnZXQgZnVsbHlcbiAgICAgICAgICAgICAgICBuUmVzdWx0ID0gQ29uc3RhbnRzLlRIRG9tUmFuZ2VfVEFSR0VUX0lOU0lERTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuU3RhcnREaWZmMSA9PSAwKSB7ICAgLy8gc3RhcnQgYXQgdGFyZ2V0IHN0YXJ0XG4gICAgICAgICAgICBpZiAobkVuZERpZmYyID09IC0xKSB7ICAgLy8gdGhpcyBpcyBlbnRpcmVseSBpbnNpZGUgdGFyZ2V0IHdpdGggc3RhcnRzIGF0IHNhbWUgcG9pbnRcbiAgICAgICAgICAgICAgICBuUmVzdWx0ID0gQ29uc3RhbnRzLlRIRG9tUmFuZ2VfVEFSR0VUX0lOQ0xVREVTX1RISVNfQVRfU1RBUlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuRW5kRGlmZjIgPT0gMCkgeyAgIC8vIGlzIGV4YWN0IG1hdGNoXG4gICAgICAgICAgICAgICAgblJlc3VsdCA9IENvbnN0YW50cy5USERvbVJhbmdlX1RBUkdFVF9TQU1FO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSAvL25FbmREaWZmMiA9PSAxXG4gICAgICAgICAgICB7ICAgLy8gc2FtZSBzdGFydCwgc2VsZWN0aW9uIGdvZXMgYmV5b25kIHRhcmdldFxuICAgICAgICAgICAgICAgIG5SZXN1bHQgPSBDb25zdGFudHMuVEhEb21SYW5nZV9UQVJHRVRfSU5TSURFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgLy8gaWYoblN0YXJ0RGlmZjEgPT0gMSlcbiAgICAgICAgeyAgIC8vIHN0YXJ0cyBhZnRlciBzdGFydCBvZiB0YXJnZXRcbiAgICAgICAgICAgIGlmIChuRW5kRGlmZjIgPT0gLTEpIHsgICAvLyB0aGlzIGlzIGVudGlyZWx5IGluc2lkZSB0YXJnZXQgKG5vIG1hdGNoaW5nIGJvdW5kYXJpZXMpXG4gICAgICAgICAgICAgICAgblJlc3VsdCA9IENvbnN0YW50cy5USERvbVJhbmdlX1RBUkdFVF9JTkNMVURFU19USElTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobkVuZERpZmYyID09IDApIHsgICAvLyB0aGlzIGlzIGVudGlyZWx5IGluc2lkZSB0YXJnZXQgd2l0aCBlbmRzIGF0IHNhbWUgcG9pbnRcbiAgICAgICAgICAgICAgICBuUmVzdWx0ID0gQ29uc3RhbnRzLlRIRG9tUmFuZ2VfVEFSR0VUX0lOQ0xVREVTX1RISVNfQVRfRU5EO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSAvL25FbmREaWZmMiA9PSAxXG4gICAgICAgICAgICB7ICAgLy8gb3ZlcmxhcHMgZW5kIG9mIHRhcmdldFxuICAgICAgICAgICAgICAgIG5SZXN1bHQgPSBDb25zdGFudHMuVEhEb21SYW5nZV9PVkVSTEFQU19FTkRfT0ZfVEFSR0VUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5SZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8vIG1vdmUgdG8gc2VwIGZpbGVcbi8vXG4vLyBGdW5jdGlvbnMgZm9yIHJhbmdlIGZvciBlYWNoIGJyb3dzZXJcbi8vXG4gICAgcndfZ2V0VGV4dEZyb21SYW5nZSgpXG4gICAge1xuICAgICAgICB2YXIgdHh0ID0gXCJcIjtcblxuICAgICAgICBpZih0aGlzLnRleHQpXG4gICAgICAgIHsgLy9JRVxuICAgICAgICAgICAgdHh0ID0gdGhpcy50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgeyAvLyBzYWZhcmkgLy9GaXJlRm94XG4gICAgICAgICAgICB0eHQgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4dDtcbiAgICB9XG5cbiAgICByd19nZXRUSENhcmV0UmFuZ2VGcm9tVEhEb21SYW5nZSgpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgaWYodGhpcy5zdGFydFJlZiA9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmVuZFJlZiA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBsZWZ0Q2FyZXQgPSBzc2RvbS5nZXRDYXJldEZyb21Eb21Qb3NpdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHksXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlZi5wYXRoLFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZWYub2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByaWdodENhcmV0ID0gc3Nkb20uZ2V0Q2FyZXRGcm9tRG9tUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LFxuICAgICAgICAgICAgICAgIHRoaXMuZW5kUmVmLnBhdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRSZWYub2Zmc2V0LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmKGxlZnRDYXJldCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgcmlnaHRDYXJldCAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRDYXJldFJhbmdlKGxlZnRDYXJldCwgcmlnaHRDYXJldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW4gb24gMzEvMDMvMTYuXG4gKi9cbi8vKiEgVXNlZCBieSBzYWZhcmlSZWFkZXJcblxuXG5cblxuLy9SZWZlcmVuY2UgdG8gYSBwb2ludCBpbiB0aGUgZG9tIHRoYXQgaXMgbm90IGxvc3QgYnkgdGV4dCBub2RlIHNwbGl0dGluZy5cbi8vIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGxvbmdlciB0ZXJtIHN0b3JhZ2Ugb2YgYSBwb3NpdGlvbi5cbmV4cG9ydCBjbGFzcyBUSERvbVJlZlB0XG57XG4gICAgY29uc3RydWN0b3IocF9zdHJQYXRoLCBwX25PZmZzZXQpXG4gICAge1xuICAgICAgICAvLyB0aGUgcGF0aCBpcyB0aGUgcGF0aCBhcyBvYnRhaW5lZCBieSBnZXRQb3NpdGlvbkluRG9tVEgoKSBhbmQgZ2l2ZXMgcGF0aCBmcm9tIHRoZSBib2R5IHRvIHRoZSBub2RlLlxuICAgICAgICB0aGlzLnBhdGggPSBwX3N0clBhdGg7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcF9uT2Zmc2V0O1xuXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gXCJUSERvbVJlZlB0IFwiICsgdGhpcy5wYXRoICsgXCIgXCIgKyB0aGlzLm9mZnNldDtcbiAgICB9O1xuXG4gICAgZ2V0UGF0aCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoO1xuICAgIH1cbiAgICBnZXRPZmZzZXQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2Zmc2V0O1xuICAgIH1cblxufVxuXG5cblxuLy8hKlxuXG5cblxuXG5cblxuXG5cbiIsIi8qKlxuKiBDcmVhdGVkIGJ5IGtldmluIG9uIDA1LzA0LzE2LlxuKi9cbi8vKiEgVXNlZCBieSBzYWZhcmlSZWFkZXJcbmltcG9ydCB7U1NET019IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vRE9NL1NTRE9NJ1xuaW1wb3J0IHtUSENhcmV0UmFuZ2V9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vVEhDYXJldFJhbmdlJ1xuXG4vLyBhbHQgdG8gVEhEb21SYW5nZSAsIG1pZ2h0IHJlcGxhY2UgaWYgd29ya3Mgb3V0XG4vLyBwX2JvZHkgICByZWZlcnMgdG8gYm9keSBub2RlIHBhdGhzIGFyZSBmcm9tLCBmb3IgZnJhbWUgcGFnZXMuXG4vLyBwX3JlZlB0TGVmdCAgIFRIRG9tUmVmUHRcbi8vIHBfcmVmUHRSaWdodCAgIFRIRG9tUmVmUHRcbmV4cG9ydCBjbGFzcyAgVEhSYW5nZSB7XG4gICAgY29uc3RydWN0b3IocF9ib2R5LCBwX3N0YXJ0UmVmUHQsIHBfZW5kUmVmUHQpIHtcbiAgICAgICAgdGhpcy5ib2R5ID0gcF9ib2R5O1xuICAgICAgICB0aGlzLnN0YXJ0UmVmID0gcF9zdGFydFJlZlB0O1xuICAgICAgICB0aGlzLmVuZFJlZiA9IHBfZW5kUmVmUHQ7XG5cbiAgICB9XG5cbiAgICAvKkNvbXBhcmVzIHN0YXJ0IGFuZCBlbmQgcG9pbnRzKi9cbiAgICBlcXVhbHMgKHBfdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiAoIHRoaXMuYm9keSA9PSBwX3RhcmdldC5ib2R5ICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVmLnBhdGggPT0gcF90YXJnZXQuc3RhcnRSZWYucGF0aCAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydFJlZi5vZmZzZXQgPT0gcF90YXJnZXQuc3RhcnRSZWYub2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLmVuZFJlZi5wYXRoID09IHBfdGFyZ2V0LmVuZFJlZi5wYXRoICYmXG4gICAgICAgICAgICB0aGlzLmVuZFJlZi5vZmZzZXQgPT0gcF90YXJnZXQuZW5kUmVmLm9mZnNldCk7XG4gICAgfVxuXG4vLyBHZXQgdGhlIHRleHQgZm9yIHRoZSByYW5nZSBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBicm93c2VyIHVzaW5nIHJhbmdlIG9iamVjdC5cbiAgICB0b1N0cmluZyAgKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldEFzUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChnX2JJRU9sZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFzUmFuZ2UoKS50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXNSYW5nZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuLy8gVGhpcyBpcyBUZXh0UmFuZ2UgZm9yIElFIGFuZCBSYW5nZSBmb3IgU0ZGXG4gICAgZ2V0QXNSYW5nZSAgKCkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAoZ19iSUVPbGQpIHtcbiAgICAgICAgICAgIHJhbmdlID0gcndfZ2V0QXNUZXh0UmFuZ2UodGhpcy5ib2R5LCB0aGlzLnN0YXJ0UmVmLnBhdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlZi5vZmZzZXQsIHRoaXMuZW5kUmVmLnBhdGgsIHRoaXMuZW5kUmVmLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByYW5nZSA9IFNTRE9NLmdldFJhbmdlT2JqZWN0KHRoaXMuYm9keSk7XG5cbiAgICAgICAgICAgIHZhciBjYXJldFJhbmdlID0gbmV3ICBuZXcgVEhDYXJldFJhbmdlKHRoaXMuYm9keSxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVmLnBhdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlZi5vZmZzZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRSZWYucGF0aCxcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFJlZi5vZmZzZXQpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q2FyZXQgPSBjYXJldFJhbmdlLmxlZnRDYXJldDtcbiAgICAgICAgICAgIHZhciBlbmRDYXJldCA9IGNhcmV0UmFuZ2UucmlnaHRDYXJldDtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0Q2FyZXQgIT0gbnVsbCAmJiBlbmRDYXJldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRDYXJldC5ub2RlLCBzdGFydENhcmV0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVuZENhcmV0Lm5vZGUsIGVuZENhcmV0Lm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJFcnJvciBpbiBUSFJhbmdlOmdldEFzUmFuZ2U6IEZhaWxlZCB0byBnZXQgdGhlIHN0YXJ0IG9yIGVuZCBjYXJldC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuICAgIGNsb25lICAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVEhSYW5nZSh0aGlzLmJvZHksIHRoaXMuc3RhcnRSZWYsIHRoaXMuZW5kUmVmKTtcbiAgICB9XG5cbiAgICByd19nZXRUSENhcmV0UmFuZ2VGcm9tVEhSYW5nZSgpXG4gICAge1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgaWYodGhpcy5zdGFydFJlZiA9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmVuZFJlZiA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBsZWZ0Q2FyZXQgPSBzc2RvbS5nZXRDYXJldEZyb21Eb21Qb3NpdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHksXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlZi5wYXRoLFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZWYub2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciByaWdodENhcmV0ID0gc3Nkb20uZ2V0Q2FyZXRGcm9tRG9tUG9zaXRpb24oXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5LFxuICAgICAgICAgICAgICAgIHRoaXMuZW5kUmVmLnBhdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRSZWYub2Zmc2V0LCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGlmKGxlZnRDYXJldCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgcmlnaHRDYXJldCAhPSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IG5ldyBUSENhcmV0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRDYXJldFJhbmdlKGxlZnRDYXJldCwgcmlnaHRDYXJldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8vISoiLCIvKipcbiAqIENyZWF0ZWQgYnkga2V2aW4gb24gMDQvMDQvMTYuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFRIUmV0dXJuT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGtldmluIG9uIDA2LzA0LzE2LlxuICovXG5pbXBvcnQge1NTRE9NfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0RPTS9TU0RPTSdcblxuZXhwb3J0IGNsYXNzIFRleHRPdmVyUmFuZ2VCZWFuQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHBfc2VudGVuY2VPYmplY3QpIHtcbiAgICAgICAgdmFyIHRtcCA9IHBfc2VudGVuY2VPYmplY3QuZ2V0Q2FyZXRSYW5nZSgpO1xuICAgICAgICB2YXIgc3Nkb20gPSBuZXcgU1NET00oKTtcbiAgICAgICAgLy8gc3RhcnQgZGF0YVxuICAgICAgICB0aGlzLnNlbnRlbmNlT2JqZWN0ID0gcF9zZW50ZW5jZU9iamVjdDtcbiAgICAgICAgdGhpcy5sZWZ0Tm9kZSA9IHRtcC5sZWZ0Q2FyZXQubm9kZTtcbiAgICAgICAgdGhpcy5yaWdodE5vZGUgPSB0bXAucmlnaHRDYXJldC5ub2RlO1xuICAgICAgICB0aGlzLmJvZHkgPSBzc2RvbS5nZXRCb2R5KHRoaXMubGVmdE5vZGUpO1xuICAgICAgICB0aGlzLmxlZnRPZmZzZXQgPSB0bXAubGVmdENhcmV0Lm9mZnNldDtcbiAgICAgICAgdGhpcy5yaWdodE9mZnNldCA9IHRtcC5yaWdodENhcmV0Lm9mZnNldDtcblxuICAgICAgICAvLyB2YXJ5aW5nIGRhdGFcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMubGVmdE5vZGU7XG4gICAgICAgIHRoaXMuc3RvcmVkVGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMuc3RhcnRSZWZQdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW5kUmVmUHQgPSBudWxsO1xuXG4gICAgICAgIC8vIFNvbWUgY29udmVuaWVuY2UgbWV0aG9kcz9cbiAgICB9XG59IiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGtldmluIG9uIDAxLzA0LzE2LlxuICovXG5cblN0cmluZy5wcm90b3R5cGUudHJpbVRIID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15bXFxzXFx4QTBdKy8sIFwiXCIpLnJlcGxhY2UoL1tcXHNcXHhBMF0rJC8sIFwiXCIpO1xufTtcblxuZXhwb3J0IGNsYXNzIFV0aWxpdGllc3tcbiAgICBjb25zdHJ1Y3Rvcigpe1xuXG4gICAgfVxuXG4gICAgdHJpbSAoc3RyaW5nKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9eW1xcc1xceEEwXSsvLCBcIlwiKS5yZXBsYWNlKC9bXFxzXFx4QTBdKyQvLCBcIlwiKTtcbiAgICB9XG5cbiAgICB0cmltRW5kVEggKHN0cmluZylcbiAgICB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcc1xceEEwXSskLywgXCJcIik7XG4gICAgfTtcblxuICAgIHJ3X2ZpbHRlckZvckh0bWwocF9zdHJUZXh0KVxuICAgIHtcbiAgICAgICAgdmFyIHN0ck91dCA9IHBfc3RyVGV4dC5yZXBsYWNlKC9cXHgyNi9nLCAnJmFtcDsnKTtcbiAgICAgICAgc3RyT3V0ID0gc3RyT3V0LnJlcGxhY2UoL1xceDNjL2csICcmbHQ7Jyk7XG4gICAgICAgIHN0ck91dCA9IHN0ck91dC5yZXBsYWNlKC9cXHgzZS9nLCAnJmd0OycpO1xuXG4gICAgICAgIHJldHVybiBzdHJPdXQ7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQge1NlbGVjdGlvbkNvbnRyb2xsZXJ9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vU2VsZWN0aW9uL1NlbGVjdGlvbkNvbnRyb2xsZXInXG5pbXBvcnQge1NwZWVjaEhpZ2hsaWdodE1hbmFnZXJ9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vSGlnaGxpZ2h0aW5nL1NwZWVjaEhpZ2hsaWdodE1hbmFnZXInXG5pbXBvcnQge1NwZWVjaE9iamVjdH0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9TcGVlY2hPYmplY3QnXG5pbXBvcnQge0hvdmVyU3BlYWt9IGZyb20gJ3NyYy9TcGVlY2hTdHJlYW0vU2VsZWN0aW9uL0hvdmVyU3BlYWsnXG5pbXBvcnQge1N0dWR5U2tpbGxzSGlnaGxpZ2h0aW5nfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0hpZ2hsaWdodGluZy9TdHVkeVNraWxsc0hpZ2hsaWdodGluZydcbmltcG9ydCB7UHJlZGljdGlvbn0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9QcmVkaWN0aW9uL1ByZWRpY3Rpb24nXG5pbXBvcnQge0V2ZW50QnVzfSBmcm9tICdzcmMvU3BlZWNoU3RyZWFtL0V2ZW50cy9FdmVudEJ1cydcbmltcG9ydCB7VEhEb21SYW5nZX0gZnJvbSAnc3JjL1NwZWVjaFN0cmVhbS9USERvbVJhbmdlJ1xuLy8gaW1wb3J0IHtCYWJlbFBvbHlmaWxsfSBmcm9tICdzcmMvcGx1Z2lucy9CYWJlbFBvbHlmaWxsJ1xuXG5cblxuXG5leHBvcnQgY2xhc3MgUGFyc2VyQVBJIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2FkTG9hZEZpbGVzLHVybCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIgPSBuZXcgU2VsZWN0aW9uQ29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLnNwZWVjaEhpZ2hsaWdodE1hbmFnZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmhvdmVyU3BlYWsgPSBuZXcgSG92ZXJTcGVhaygpO1xuICAgICAgICB0aGlzLnNwZWVjaE9iamVjdCA9IG5ldyBTcGVlY2hPYmplY3QoKTtcbiAgICAgICAgdGhpcy5zdHVkeVNraWxscyA9IG5ldyBTdHVkeVNraWxsc0hpZ2hsaWdodGluZygpO1xuICAgICAgICB0aGlzLmhvdmVyU3BlYWtPbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGhMb2FkZWQ9ZmFsc2U7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICBpZiAodHlwZW9mIChNYXRoSmF4KSE9XCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgTWF0aEpheC5BamF4LkxvYWQodXJsICsgXCJ0b01hdGhNTC5qc1wiKTtcbiAgICAgICAgICAgIHRoaXMubG9hZF9zY3JpcHQodXJsICsgXCJzcmVfYnJvd3Nlci5qc1wiKTtcbiAgICAgICAgICAgIHRoaXMubWF0aExvYWRlZD10cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlZGljdGlvbk9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlZGljdGlvbj1uZXcgUHJlZGljdGlvbigpO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgRXZlbnRCdXMoKVxuICAgICAgICBldmVudC5zdWJzY3JpYmUoXCJwYXVzZUhvdmVyXCIsdGhpcy5wYXVzZUhvdmVyLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmlzSG92ZXJTcGVha0VuYWJsZWQ9ZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0VXBpZnJhbWVzKCl7XG4gICAgICAgIGlmICh3aW5kb3cuZnJhbWVzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPTA7IGk8d2luZG93LmZyYW1lcy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5mcmFtZXNbaV0uZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsdGhpcy5pZnJhbWVDYWxsYmFjay5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgICAgIH1jYXRjaCAoZSl7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZnJhbWVDYWxsYmFjayhldmVudCl7XG5cbiAgICAgICAgaWYgKHRoaXMuaG92ZXJTcGVha09uICYmdGhpcy5zcGVlY2hDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5ob3ZlclNwZWFrLm1vdXNlTW92ZWQoZXZlbnQsdGhpcy5zcGVlY2hDYWxsYmFjaylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcmNlTG9hZE1hdGgoKXtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGhMb2FkZWQpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoTWF0aEpheCkhPVwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBNYXRoSmF4LkFqYXguTG9hZCh0aGlzLnVybCArIFwidG9NYXRoTUwuanNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkX3NjcmlwdCh0aGlzLnVybCArIFwic3JlX2Jyb3dzZXIuanNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRoTG9hZGVkPXRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXVzZUhvdmVyKCl7XG5cbiAgICAgICAgaWYgKHRoaXMuaG92ZXJTcGVha09uIHx8IHRoaXMuaXNIb3ZlclNwZWFrRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5ob3ZlclNwZWFrT24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaXNIb3ZlclNwZWFrRW5hYmxlZD10cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXVzZUhvdmVyVGltZXIgPXNldFRpbWVvdXQoKCkgPT4gdGhpcy51blBhdXNlSG92ZXIoKSwgMzAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNIb3ZlclNwZWFrRW5hYmxlZD1mYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVuUGF1c2VIb3Zlcigpe1xuICAgICAgICBpZiAodGhpcy5pc0hvdmVyU3BlYWtFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyU3BlYWtPbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhckhvdmVyU3BlYWsoKXtcbiAgICAgICAgdGhpcy5ob3ZlclNwZWFrLmNsZWFySG92ZXJTcGVhaygpO1xuICAgIH1cblxuICAgIGxvYWRfc2NyaXB0KCBzb3VyY2UgKSB7XG4gICAgICAgIHZhciBuZXdfc2NyaXB0ICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBuZXdfc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgbmV3X3NjcmlwdC5zcmMgPSBzb3VyY2U7XG4gICAgICAgIG5ld19zY3JpcHQuY2xhc3NOYW1lID0gJ015SW5qZWN0ZWRTY3JpcHQnO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKG5ld19zY3JpcHQpO1xuICAgIH1cblxuICAgIHByZWRpY3Rpb25FbmFibGVkKGVuYWJsZWQpe1xuICAgICAgICB0aGlzLnByZWRpY3Rpb25Pbj0gZW5hYmxlZDtcbiAgICB9XG5cbiAgICBnZXRQcmVkaWN0aW9uQ29vcmRpbmF0ZXMoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZGljdGlvbi5nZXRQb3NpdGlvbk9mUG9wdXAoKTtcbiAgICB9XG5cbiAgICBnZXRQcmVkaWN0aW9uU2VudGVuY2UoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZGljdGlvbi5nZXRTZW50ZW5jZSgpO1xuICAgIH1cblxuICAgIHByZWRpY3Rpb25JbnNlcnRUZXh0KHRleHQpe1xuICAgICAgICB0aGlzLnByZWRpY3Rpb24uaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgICB9XG5cbiAgICBpc0VkaXRhYmxlKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWRpY3Rpb24uaXNFZGl0YWJsZSgpO1xuICAgIH1cbiAgICBob3ZlclNwZWFrRW5hYmxlZChlbmFibGVkKXtcbiAgICAgICAgdGhpcy5ob3ZlclNwZWFrT249ZW5hYmxlZDtcbiAgICAgICAgdGhpcy5pc0hvdmVyU3BlYWtFbmFibGVkPWVuYWJsZWQ7XG4gICAgICAgIGlmICghZW5hYmxlZCl7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wYXVzZUhvdmVyVGltZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW91c2VPdmVyRXZlbnQoZXZlbnQsY2FsbGJhY2spe1xuICAgICAgICB0aGlzLnNwZWVjaENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0aGlzLmhvdmVyU3BlYWtPbikge1xuICAgICAgICAgICAgdGhpcy5ob3ZlclNwZWFrLm1vdXNlTW92ZWQoZXZlbnQsdGhpcy5zcGVlY2hDYWxsYmFjaylcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGF1c2VIb3ZlclRpbWVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlcmUgYXJlIGFueSBzZWxlY3Rpb25zXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGVyZSBhcmUgYW55IHNlbGVjdGlvbnMuXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLmhhc1NlbGVjdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgd29yZC4gSWYgbW9yZSB0aGFuIG9uZSB3b3JkIGlzIHNlbGVjdGVkIHRoZSBmaXJzdCB3b3JkIGluXG4gICAgICogdGhlIHNlbGVjdGlvbiB3aWxsIGJlIHJldHVybmVkLiBJZiBubyB3b3JkIGlzIHNlbGVjdGVkIHRoZSB3b3JkIGJlbG93IHRoZVxuICAgICAqIGN1cnNvciB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBjb250YWluaW5nIHRoZSB3b3JkLlxuICAgICAqL1xuICAgIGdldFdvcmQgKClcbiAgICB7XG5cbiAgICAgICAgdmFyIHdvcmRzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb249dGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3b3JkcyA9c2VsZWN0aW9uLnRvU3RyaW5nKCkuc3BsaXQoL1xccy8pO1xuXG4gICAgICAgICAgICBpZiAod29yZHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KHdvcmRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgdGV4dCB0aGF0IHdhcyBzZWxlY3RlZCBhbmQgaGlnaGxpZ2h0ZWQuXG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLmdldFNlbGVjdGlvblJhbmdlKCkudG9TdHJpbmcoKS5zcGxpdCgvXFxzLyk7XG4gICAgfVxuXG5cbiAgICBnZXRTZWxlY3Rpb25Mb2NhbCgpe1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBjbGVhclNlbGVjdGlvbl8oKXtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Db250cm9sbGVyLmNsZWFyU2VsZWN0aW9uXygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgd2ViIHBhZ2Ugc2VsZWN0aW9uLiBUaGlzIGlzIG5vdCB0aGUgaGlnaGxpZ2h0c1xuICAgICAqIHdlIGFkZC5cbiAgICAgKi9cbiAgICBjbGVhckJyb3dzZXJTZWxlY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5jbGVhckJyb3dzZXJTZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWdobGlnaHRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHRleHQgdGhhdCB3YXMgc2VsZWN0ZWQgYW5kIGhpZ2hsaWdodGVkLiBJZlxuICAgICAqICAgICAgICAgICAgICBub3RoaW5nIGlzIHNlbGVjdGVkIGFuIGVtcHR5IHN0cmluZyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqL1xuICAgIGhpbGl0ZVNlbGVjdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHNlbnRlbmNlPW51bGw7XG4gICAgICAgIGlmICh0aGlzLmhhc1NlbGVjdGlvbigpIHx8IHRoaXMuaG92ZXJTcGVha09uICkge1xuICAgICAgICAgICAgdGhpcy5zZW50ZW5jZU5vID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyU3BlYWtPbikge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuaG92ZXJTcGVhay5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWNoT2JqZWN0LnByb2Nlc3NSYW5nZShyYW5nZSx0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hPYmplY3QucHJvY2Vzc1JhbmdlKHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5nZXRTZWxlY3Rpb25SYW5nZSgpLGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbnRlbmNlPSB0aGlzLnNwZWVjaE9iamVjdC5nZXRGaXJzdFNlbnRlbmNlKCk7XG4gICAgICAgICAgICBpZiAoc2VudGVuY2UgJiYgc2VudGVuY2UuZ2V0UmF3VGV4dCgpPT1cIlwiKXtcbiAgICAgICAgICAgICAgICBzZW50ZW5jZT0gdGhpcy5zcGVlY2hPYmplY3QuZ2V0TmV4dFNlbnRlbmNlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJhbmdlO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGRvY1JhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBUSERvbVJhbmdlKGRvY1JhbmdlLnN0YXJ0Q29udGFpbmVyLCBkb2NSYW5nZS5zdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgZG9jUmFuZ2UuZW5kQ29udGFpbmVyLCBkb2NSYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jUmFuZ2U9ZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBUSERvbVJhbmdlKGRvY1JhbmdlLm9mZnNldE5vZGUsIGRvY1JhbmdlLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgZG9jUmFuZ2Uub2Zmc2V0Tm9kZSwgZG9jUmFuZ2Uub2Zmc2V0KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zcGVlY2hPYmplY3QucHJvY2Vzc1JhbmdlKHJhbmdlLHRydWUpO1xuICAgICAgICAgICAgc2VudGVuY2U9IHRoaXMuc3BlZWNoT2JqZWN0LmdldE5leHRTZW50ZW5jZSh0cnVlKTtcblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ29udHJvbGxlci5jbGVhckJyb3dzZXJTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHNlbnRlbmNlIT1udWxsKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHNlbnRlbmNlLmdldFdvcmRzKCk7XG4gICAgICAgICAgICBpZiAodGV4dC5sZW5ndGg9PTApe1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVjaEhpZ2hsaWdodE1hbmFnZXIgPSBuZXcgU3BlZWNoSGlnaGxpZ2h0TWFuYWdlcihzZW50ZW5jZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlY2hIaWdobGlnaHRNYW5hZ2VyLmhpZ2hsaWdodFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG5cblxuXG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0cyBhIHdvcmQgd2l0aCB0aGUgY3VycmVudCB3b3JkIGNvbG9ycy4gVXNlZCB0b1xuICAgICAqIGhpZ2hsaWdodCB0aGUgY3VycmVudGx5IHNwb2tlbiB3b3JkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3b3JkTm8gbnVtYmVyIG9mIHRoZSB3b3JkIHRvIGhpZ2hsaWdodC5cbiAgICAgKi9cbiAgICBoaWxpdGVXb3JkICh3b3JkTm8pXG4gICAge1xuICAgICAgICB0aGlzLnNwZWVjaEhpZ2hsaWdodE1hbmFnZXIuaGlnaGxpZ2h0V29yZCh3b3JkTm8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbnkgc3BlZWNoXG4gICAgICovXG4gICAgc3RvcCAoKVxuICAgIHtcbiAgICAgICAgdmFyIHNlbnRlbmNlID0gdGhpcy5zcGVlY2hPYmplY3QuZ2V0Q3VycmVudFNlbnRlbmNlKCk7XG4gICAgICAgIGlmIChzZW50ZW5jZSE9bnVsbCAmJiB0aGlzLnNwZWVjaEhpZ2hsaWdodE1hbmFnZXIhPW51bGwpe1xuICAgICAgICAgICAgdGhpcy5zcGVlY2hIaWdobGlnaHRNYW5hZ2VyLnVuSGlnaGxpZ2h0UmFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhpbGl0ZU5leHRTZW50ZW5jZSAoY29udGlub3VzUmVhZGluZylcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnNwZWVjaEhpZ2hsaWdodE1hbmFnZXIhPW51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlZWNoSGlnaGxpZ2h0TWFuYWdlci51bkhpZ2hsaWdodFJhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbnRlbmNlID0gdGhpcy5zcGVlY2hPYmplY3QuZ2V0TmV4dFNlbnRlbmNlKGNvbnRpbm91c1JlYWRpbmcpO1xuICAgICAgICB2YXIgdGV4dD1udWxsO1xuICAgICAgICBpZiAoc2VudGVuY2UhPSBudWxsKXtcbiAgICAgICAgICAgIHRleHQgPXNlbnRlbmNlLmdldFdvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLnNwZWVjaEhpZ2hsaWdodE1hbmFnZXIgPSBuZXcgU3BlZWNoSGlnaGxpZ2h0TWFuYWdlcihzZW50ZW5jZSk7XG4gICAgICAgICAgICB0aGlzLnNwZWVjaEhpZ2hsaWdodE1hbmFnZXIuaGlnaGxpZ2h0UmFuZ2Uoc2VudGVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuXG5cbiAgICBoaWdobGlnaHRTZWxlY3Rpb24gKGNvbG91cilcbiAgICB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25PYmplY3QgPSB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIuZ2V0U2VsZWN0aW9uT2JqZWN0KCk7XG4gICAgICAgIHRoaXMuc3R1ZHlTa2lsbHMuc3R1ZHlTa2lsbHNIVE1MSGlnaGxpZ2h0UmFuZ2UoY29sb3VyLHNlbGVjdGlvbk9iamVjdCk7XG4gICAgfVxuXG4gICAgY2xlYXJIaWdobGlnaHRzKCl7XG4gICAgICAgIHZhciBzZWxlY3Rpb25PYmplY3QgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb24oKSlcbiAgICAgICAge1xuICAgICAgICAgICAgc2VsZWN0aW9uT2JqZWN0PSB0aGlzLnNlbGVjdGlvbkNvbnRyb2xsZXIuZ2V0U2VsZWN0aW9uT2JqZWN0KClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0dWR5U2tpbGxzLnN0dWR5U2tpbGxzQ2xlYXJIaWdobGlnaHRzKGZhbHNlLHNlbGVjdGlvbk9iamVjdClcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3RzIGFsbCB0aGUgaGlnaGxpZ2h0cyBmcm9tdCBoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBoaWdobGlnaHRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQuXG4gICAgICovXG4gICAgY29sbGVjdEhpZ2hsaWdodHMgKHNvcnQsIGNvbG9ycykge1xuICAgICAgICB2YXIgaGlnaGxpZ2h0cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICBpZiAoc29ydD09Mikgey8vY29sbGVjdCBieSBjb2xvdXJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0cy5wdXNoKC4uLnRoaXMuc3R1ZHlTa2lsbHMuc3R1ZHlTa2lsbHNDb2xsYXRlRm9yQ29sb3VyKGNvbG9yc1tpXSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdobGlnaHRzLnB1c2goLi4udGhpcy5zdHVkeVNraWxscy5zdHVkeVNraWxsc0NvbGxhdGVGb3JDb2xvdXIoY29sb3JzKSlcbiAgICAgICAgfVxuICAgICAgICAvL2NhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybiBoaWdobGlnaHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3RzIHZvY2FiIHdvcmRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHdvcmRzIGhhdmUgYmVlbiBjb2xsZWN0ZWQuXG4gICAgICovXG4gICAgY29sbGVjdFZvY2FiV29yZHMgKGNhbGxiYWNrKVxuICAgIHtcblxuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgdm9pY2Ugbm90ZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBhZGRWb2ljZU5vdGUgKClcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqICBFbmQgb2YgdGhlIGlQYXJzZXIgaW50ZXJmYWNlIGltcGxlbWVudGF0aW9uICAgICAgICAgICAgICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuXG4gICAgY29sbGVjdFZvY2FicyAoY2FsbGJhY2ssIGNvbG9ycywgZmlsZU5hbWUpe1xuICAgICAgICByZXR1cm4gdGhpcy5zdHVkeVNraWxscy5mZXRjaFdvcmRzKCk7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiBNb3VzZSBldmVudHNcbiAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgb25Nb3VzZVVwKGV2ZW50KXtcbiAgICB9XG5cbiAgICBvbk1vdXNlRG93bihldmVudCl7XG4gICAgICAgIHRoaXMucHJlZGljdGlvbi5zZXRFZGl0Q29udHJvbChldmVudC50YXJnZXQpO1xuICAgIH1cblxuICAgIG9uS2V5RG93bihldmVudCl7XG4gICAgICAgIHRoaXMucHJlZGljdGlvbi5zZXRFZGl0Q29udHJvbChldmVudC50YXJnZXQpO1xuICAgIH1cbn1cbi8qKlxuICogUHVibGljIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gKiBAdHlwZSB7UGFyc2VyQVBJfVxuICovXG5cbnRleHRIZWxwLnBhcnNlcnM9IHRleHRIZWxwLnBhcnNlcnN8fCB7fTtcbnRleHRIZWxwLnBhcnNlcnMuSFRNTFBhcnNlckFQSSA9IHRleHRIZWxwLnBhcnNlcnMuSFRNTFBhcnNlckFQSSB8fCB7fTtcbnRleHRIZWxwLnBhcnNlcnMuSFRNTFBhcnNlckFQSSA9IFBhcnNlckFQSTtcblxuIiwiaW1wb3J0IFwic3JjL2FwaS9QYXJzZXJBUElcIjtcblxuIl19\n"],"sourceRoot":"/source/"}